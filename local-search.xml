<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式笔记（三）结构型模式</title>
    <link href="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="适配器模式介绍"><a href="#适配器模式介绍" class="headerlink" title="适配器模式介绍"></a>适配器模式介绍</h3><p>适配器模式的主要作用是把原本不兼容的接口通过适配修改做到统一，方便调用方使用。</p><p>变速箱通过不同齿轮之间的啮合，实现与不同转速的齿轮适配。</p><p>日常生活中用到的万能充电器、数据线和笔记本的转换接头，它们都为适配各种不同的接口进行了兼容。</p><p>除了日常生活中出现的各种物件适配的场景，在业务代码的开发中会有哪些场景呢？</p><p>在业务开发中，经常需要做不同接口的兼容，尤其是中台服务。中台需要把各个业务线的类型服务统一包装，再对外提供接口。</p><h3 id="MQ消息体兼容场景"><a href="#MQ消息体兼容场景" class="headerlink" title="MQ消息体兼容场景"></a>MQ消息体兼容场景</h3><p>随着公司业务的不断扩展，基础架构系统逐步成型，业务运营就需要开始做新用户的拉新和老用户的促活，从而保障DAU的增速，以及最终实现ROI转换</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-1.png" alt></p><p>这时就需要做一些营销系统，常见的有裂变、拉客，如邀请一位用户开户，或者邀请一位用户下单，平台就会返利，并且多邀多得。同时，随着拉新量的增多，平台开始设置每月首单返现等奖励。</p><p>开发这样一个营销系统就会遇到各种各样的MQ消息或接口，如果逐个开发，会耗费很高的成本，同时后期的扩展也有一定的难度。此时会希望有一个系统，配置后就能把外部的MQ接入，这些MQ就像上面提到的注册开户消息、商品下单消息等。而适配器的思想也恰恰可以运用在这里。需要强调的是，适配器不只可以适配接口，还可以适配一些属性信息。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2.png" alt></p><p>这里模拟了三个不同类型的MQ消息：create_account、OrderMq和POPOrderDelivered。在消息体中有一些必要的字段，如用户ID、时间和业务ID，但是每个MQ的字段名称并不同，就像用户ID在不同的MQ里也有不同的字段uId、userId等一样。另外，这里还提供了两种不同类型的接口：OrderService 用于查询内部订单的下单数量，POPOrderService用于查询第三方是否为首单。</p><p>后面需要把这些不同类型的MQ和接口进行适配兼容，这种场景在开发中也很常见。</p><p><strong>注册开户MQ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册开户MQ</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">create_account</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String number;      <span class="hljs-comment">// 开户编号</span><br>    <span class="hljs-keyword">private</span> String address;     <span class="hljs-comment">// 开户地</span><br>    <span class="hljs-keyword">private</span> Date accountDate;   <span class="hljs-comment">// 开户时间</span><br>    <span class="hljs-keyword">private</span> String desc;        <span class="hljs-comment">// 开户描述</span><br><br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在注册开户MQ消息体中，提供了四个核心属性：开户编号、开户地、开户时间和开户描述。</p><p><strong>内部订单MQ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内部订单MQ</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderMq</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String uid;           <span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-keyword">private</span> String sku;           <span class="hljs-comment">// 商品编号</span><br>    <span class="hljs-keyword">private</span> String orderId;       <span class="hljs-comment">// 订单ID</span><br>    <span class="hljs-keyword">private</span> Date createOrderTime; <span class="hljs-comment">// 下单时间</span><br>    <br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在内部订单MQ的消息体中，提供了四个核心属性：用户ID、商品编号、订单ID和下单时间。</p><p><strong>第三方订单MQ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单投递消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderDelivered</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String uId;     <span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-keyword">private</span> String orderId; <span class="hljs-comment">// 订单号</span><br>    <span class="hljs-keyword">private</span> Date orderTime; <span class="hljs-comment">// 下单时间</span><br>    <span class="hljs-keyword">private</span> Date sku;       <span class="hljs-comment">// 商品编号</span><br>    <span class="hljs-keyword">private</span> Date skuName;   <span class="hljs-comment">// 商品名称</span><br>    <span class="hljs-keyword">private</span> BigDecimal decimal; <span class="hljs-comment">// 商品金额</span><br>        <br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在第三方订单MQ的消息体中，提供了六个核心属性：用户ID、订单号、下单时间、商品编号、商品名称和商品金额。</p><p><strong>查询用户内部下单数量接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(POPOrderService.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">queryUserOrderCount</span><span class="hljs-params">(String userId)</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;自营商家，查询用户的订单是否为首单：&#123;&#125;&quot;</span>, userId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10L</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口主要用于查询用户在内部商家的下单数量。</p><p><strong>查询用户第三方下单首单接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(POPOrderService.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirstOrder</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;POP商家，查询用户的订单是否为首单：&#123;&#125;&quot;</span>, uId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口主要用于查询第三方订单是否为首单。</p><p>以上几项是不同的MQ及其接口的实现，后面将给这些MQ消息和接口做相应的适配，使程序的调用逻辑达到统一。</p><h3 id="违背设计模式实现"><a href="#违背设计模式实现" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>在大部分时候，各种MQ消息都在创建一个类用于消费，将它的MQ消息属性转换给自己的方法。</p><p>接下来同样先给出这种方式的实现过程，但是这里存在一个很大的问题：当MQ消息越来越多时，甚至达到几十个、几百个MQ消息后，中台服务应如何优化呢？</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-3.png" alt></p><p>这个工程中需要接收三个MQ消息，所以就有了三个对应的类create_accountMqService、OrderMqService、POPOrderDeliveredService。这和平时的代码几乎一样，如果MQ消息数量不多，则这种写法没什么问题；但如果是中台服务，随着对接服务数量的增加，需要考虑用一些设计模式来解决。</p><p><strong>MQ接收消息实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">create_accountMqService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        create_account mq = JSON.parseObject(message, create_account.class);<br>        mq.getNumber();<br>        mq.getAccountDate();<br>        <span class="hljs-comment">// ... 处理自己的业务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderMqService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        OrderMq mq = JSON.parseObject(message, OrderMq.class);<br>        mq.getUid();<br>        mq.getOrderId();<br>        mq.getCreateOrderTime();<br>        <span class="hljs-comment">// ... 处理自己的业务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderDeliveredService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        POPOrderDelivered mq = JSON.parseObject(message, POPOrderDelivered.class);<br>        mq.getuId();<br>        mq.getOrderId();<br>        mq.getOrderTime();<br>        <span class="hljs-comment">// ... 处理自己的业务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这三组MQ的消费类都是一样的，从这里也能看到它们的字段在使用上有一些相似。研发人员能够针对不规则的需求，按照统一的标准处理，降低开发成本，提高研发效率。</p><h3 id="适配器模式重构代码"><a href="#适配器模式重构代码" class="headerlink" title="适配器模式重构代码"></a>适配器模式重构代码</h3><p>适配器模式解决的主要问题是如何针对多种差异化类型的接口实现统一输出。在介绍工厂方法模式时，也提到过不同种类的奖品处理，其实也是适配器模式的应用。在本节中，还会再体现另外一个多种MQ消息接收的场景。把不同类型的消息中的属性字段做统一处理，便于减少后续人工硬编码方式对MQ的接收。如果没有开发过接收MQ消息的业务，会对这样的场景有些不理解。建议先了解MQ消息，即使没有了解，也不会影响对思路的理解。再者，本文展示的MQ兼容的核心部分，也是处理适配不同的类型字段。如果接收MQ消息后，在配置不同的消费类时不希望逐个开发消费MQ的类，那么可以使用代理类的方式处理。</p><p><strong>工程结构：</strong></p><p><img src alt><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-4.png" alt="image-4"></p><p>适配器模式的工程结构提供了两种适配方式的代码：接口适配（OrderAdapterService）和MQ适配（MQAdapter）。之所以不只做接口适配的案例，因为这样的开发很常见。所以把适配的思想应用到MQ消息体上，增加对多设计模式的认知。先做MQ适配，接收各种各样的MQ消息。当业务发展得很快时，需要下单用户满足首单条件时才给予奖励，在这种场景下再增加对接口适配的操作。</p><p><strong>MQ适配：</strong></p><p>为了满足产品功能的需求，提取此项功能中必须的字段信息，单独创建一个类RebateInfo。后续所有的MQ信息都需要提供这些属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RebateInfo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String userId;<br>    <span class="hljs-keyword">private</span> String bizId;<br>    <span class="hljs-keyword">private</span> String bizTime;<br>    <span class="hljs-keyword">private</span> String desc;<br><br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>MQ消息中会有多种多样的类型属性，虽然它们都同样提供给使用方，但是如果都这样接入，那么当 MQ 消息特别多时就会很耗时。所以，在这个案例中定义了通用的 MQ消息体，后续把所有接入进来的消息进行统一的处理。</p><p><strong>MQ消息统一适配类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MQAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RebateInfo <span class="hljs-title">filter</span><span class="hljs-params">(String strJson, Map&lt;String, String&gt; link)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> filter(JSON.parseObject(strJson, Map.class), link);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RebateInfo <span class="hljs-title">filter</span><span class="hljs-params">(Map obj, Map&lt;String, String&gt; link)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        RebateInfo rebateInfo = <span class="hljs-keyword">new</span> RebateInfo();<br>        <span class="hljs-keyword">for</span> (String key : link.keySet()) &#123;<br>            Object val = obj.get(link.get(key));<br>            RebateInfo.class.getMethod(<span class="hljs-string">&quot;set&quot;</span> + key.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + key.substring(<span class="hljs-number">1</span>), String.class).invoke(rebateInfo, val.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> rebateInfo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类里的方法非常重要，主要用于把不同类型的MQ中的各种属性映射成需要的属性并返回。就像一个属性中有用户ID uId，将其映射到需要的userId，做统一处理。而这个处理过程需要把映射管理传递给Map<String , string> link，也就是准确地描述了当前MQ中某个属性名称，映射为指定的某个属性名称。接收到的MQ消息基本是JSON格式，可以转换为MAP结构。最后，使用反射调用的方式对类型赋值。</String></p><p><strong>MQ消息适配测试验证:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_MQAdapter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        SimpleDateFormat s = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        Date parse = s.parse(<span class="hljs-string">&quot;2020-06-01 23:20:16&quot;</span>);<br><br>        create_account create_account = <span class="hljs-keyword">new</span> create_account();<br>        create_account.setNumber(<span class="hljs-string">&quot;100001&quot;</span>);<br>        create_account.setAddress(<span class="hljs-string">&quot;河北省.廊坊市.广阳区.大学里职业技术学院&quot;</span>);<br>        create_account.setAccountDate(parse);<br>        create_account.setDesc(<span class="hljs-string">&quot;在校开户&quot;</span>);<br><br>        HashMap&lt;String, String&gt; link01 = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        link01.put(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-string">&quot;number&quot;</span>);<br>        link01.put(<span class="hljs-string">&quot;bizId&quot;</span>, <span class="hljs-string">&quot;number&quot;</span>);<br>        link01.put(<span class="hljs-string">&quot;bizTime&quot;</span>, <span class="hljs-string">&quot;accountDate&quot;</span>);<br>        link01.put(<span class="hljs-string">&quot;desc&quot;</span>, <span class="hljs-string">&quot;desc&quot;</span>);<br><br>        RebateInfo rebateInfo01 = MQAdapter.filter(create_account.toString(), link01);<br>        System.out.println(<span class="hljs-string">&quot;mq.create_account(适配前)&quot;</span> + create_account.toString());<br>        System.out.println(<span class="hljs-string">&quot;mq.create_account(适配后)&quot;</span> + JSON.toJSONString(rebateInfo01));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里分别模拟传入了两个不同的MQ消息，并设置字段的映射关系。在实际业务开发场景中，可以把这种映射配置关系交给配置文件或数据库后台，以减少编码。</p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mq.create_account(适配前)&#123;<span class="hljs-string">&quot;accountDate&quot;</span>:<span class="hljs-number">1591024816000</span>,<span class="hljs-string">&quot;address&quot;</span>:<span class="hljs-string">&quot;河北省.廊坊市.广阳区.大学里职业技术学院&quot;</span>,<span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;在校开户&quot;</span>,<span class="hljs-string">&quot;number&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>&#125;<br>mq.create_account(适配后)&#123;<span class="hljs-string">&quot;bizId&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;bizTime&quot;</span>:<span class="hljs-string">&quot;1591024816000&quot;</span>,<span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;在校开户&quot;</span>,<span class="hljs-string">&quot;userId&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，同样的字段值在实现适配前后，分别有统一的字段属性，开发时也就非常的简单了。另外，有一个非常重要的地方，除了反射的使用，还可以加入代理类，把映射的配置交给代理类，不需要手动创建类的每一个MQ。</p><p><strong>接口适配需求阐述：</strong></p><p>随着业务的发展，营销活动本身会修改，不再只是接入MQ就发放奖励。因为拉新的数量越来越多，需要做一些限制。因此增加了只有首单用户才发放奖励的规定，也就是每月、每年的首单或新人首次下单才发放奖励，而不是之前每一次下单都发放奖励。这时就需要对这种方式进行限制，而此时MQ中并没有判断首单的属性。只能通过接口进行查询。</p><div class="table-container"><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>cn.bugstack.design.service.OrderService.queryUserOrderCount(String userId)</td><td>出参 long，查询订单数量</td></tr><tr><td>cn.bugstack.design.service.POPOrderService.isFirstOrder(String uId)</td><td>出参 boolean，判断是否首单</td></tr></tbody></table></div><p>两个接口的判断逻辑和使用方式不同，不同的接口提供方也有不同的出参。一个是直接判断是否为首单，另一个需要根据订单数量判断，因此，这里需要通过适配器的模式实现。虽然使用if语句也可以实现，但是这样的写法会导致后期难以维护。</p><p><strong>定义统一适配接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderAdapterService</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirst</span><span class="hljs-params">(String uId)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接口的实现需要完成此接口定义的方法，并把具体的逻辑包装到指定的类中，满足单一职责。</p><p><strong>分别实现两个不同的接口：</strong></p><ol><li><p><strong>内部商品接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内部订单，判断首单逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsideOrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderAdapterService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> OrderService orderService = <span class="hljs-keyword">new</span> OrderService();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirst</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderService.queryUserOrderCount(uId) &lt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>第三方商品接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方订单，判断首单逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderAdapterServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderAdapterService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> POPOrderService popOrderService = <span class="hljs-keyword">new</span> POPOrderService();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirst</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> popOrderService.isFirstOrder(uId);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这两种接口都实现了各自的判断方式，尤其对于提供订单数量的接口，需要自己判断当前接到MQ时订单数量是否小于或等于1，以此判断是否为首单。</p><p><strong>注意：</strong>在实际的业务开发中，由于下单消息的延时，可能这种方式是不准确的。本书主要为了体现不同接口的统一适配。</p><p>最终，两种不同类型的服务接口都可以按照统一的标准判断是否为首单。</p><p><strong>接口适配验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_itfAdapter</span><span class="hljs-params">()</span> </span>&#123;<br>    OrderAdapterService popOrderAdapterService = <span class="hljs-keyword">new</span> POPOrderAdapterServiceImpl();<br>    System.out.println(<span class="hljs-string">&quot;判断首单，接口适配（POP）：&quot;</span> + popOrderAdapterService.isFirst(<span class="hljs-string">&quot;100001&quot;</span>));<br><br>    OrderAdapterService insideOrderService = <span class="hljs-keyword">new</span> InsideOrderServiceImpl();<br>    System.out.println(<span class="hljs-string">&quot;判断首单，接口适配（自营）：&quot;</span> + insideOrderService.isFirst(<span class="hljs-string">&quot;100001&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">12.234</span> [main] INFO  c.b.design.service.POPOrderService - POP商家，查询用户的订单是否为首单：<span class="hljs-number">100001</span><br>判断首单，接口适配（第三方）：<span class="hljs-keyword">true</span><br><span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">12.234</span> [main] INFO  c.b.design.service.POPOrderService - 自营商家，查询用户的订单是否为首单：<span class="hljs-number">100001</span><br>判断首单，接口适配（内部）：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p>从测试结果来看，此时的接口已经统一包装，外部使用者不需要关心内部的具体逻辑。而且在调用时，只需要传入统一的参数即可，这样就能满足适配的作用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从本章可以看出，即使不使用适配器模式，也可以实现这些功能。但是使用了适配器模式可以让代码更干净、整洁，减少大量重复的判断和使用，同时也让代码更易于维护和扩展。尤其对于MQ等多种消息体中有不同属性的同类值（abc=”123”、def=”123”），进行适配再加上代理类，就可以使用简单的配置方式接入对方提供的MQ消息，而不需要重复地开发，非常利于扩展。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="桥接模式介绍"><a href="#桥接模式介绍" class="headerlink" title="桥接模式介绍"></a>桥接模式介绍</h3><p>桥接模式的主要作用是通过将抽象部分与实现部分分离，将多种可匹配的使用进行组合。其核心实现是在A类中含有B类接口，通过构造函数传递B类的实现，这个B类就是设计的桥。手机通过“桥”（蓝牙）可以连接玩具车、电视、冰箱和空调等智能家居。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-5.png" alt></p><p>这样的桥接模式存在于日常开发中的哪些场景里呢？包括 JDBC 多种驱动程序的实现、同品牌类型的台式机和笔记本电脑、业务实现中的多类接口同组过滤服务等。这些场景都比较适合用桥接模式实现，因为在一些组合中，如果每一个类都实现不同的服务，可能会出现笛卡儿积，而使用桥接模式就可以变得非常简单。</p><h3 id="多支付和多模式组合场景"><a href="#多支付和多模式组合场景" class="headerlink" title="多支付和多模式组合场景"></a>多支付和多模式组合场景</h3><p>在支付服务行业中，有微信、支付宝及一些其他支付服务，但是对于商家来说，并不能只接受某一种支付方式。如果商家只支持使用微信或支付宝付款，那么就会让顾客为难，商品销量也会受到影响。</p><p>这时就出现了第三方平台，它们把市面上的多种支付服务都集中到自己平台中，再把这些平台提供给店铺、超市等商家使用，同时支持人脸支付、指纹支付和密码支付等多种方式。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-6.png" alt></p><p>下面的案例模拟一个第三方平台承接各种支付功能，同时使用人脸支付让用户支付起来更加容易。这里就出现了多支付与多模式的组合使用，如果给每一种支付方式都实现一种支付模式，即使是继承类的方式也需要开发多个功能类，并且随着后面接入了更多的支付服务或支付方式，将呈现爆炸式扩展。</p><p>这种场景该如何实现呢？</p><h3 id="违背设计模式实现-1"><a href="#违背设计模式实现-1" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-7.png" alt></p><p>在这个工程结构中只有一个服务类 PayController，里面都是 if…else，它实现了支付类型和支付模式的全部功能。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(PayController.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doPay</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount, <span class="hljs-keyword">int</span> channelType, <span class="hljs-keyword">int</span> modeType)</span> </span>&#123;<br>        <span class="hljs-comment">// 微信支付</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == channelType) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;密码支付，风控校验环境安全&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;人脸支付，风控校验脸部识别&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;指纹支付，风控校验指纹信息&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 支付宝支付</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == channelType) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;密码支付，风控校验环境安全&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;人脸支付，风控校验脸部识别&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;指纹支付，风控校验指纹信息&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 PayController 类中，有一个支付服务功能，提供必要字段：用户 ID、交易 ID、金额、渠道和模式，传递给doPay方法，以及控制支付类型。以上的if…else应该是最差的一种写法，因为即使写if…else，也应该以优化的方式写，尽可能减少使用次数。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_pay</span><span class="hljs-params">()</span> </span>&#123;<br>        PayController pay = <span class="hljs-keyword">new</span> PayController();<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；微信支付、人脸方式。&quot;</span>);<br>        pay.doPay(<span class="hljs-string">&quot;weixin_1092033111&quot;</span>, <span class="hljs-string">&quot;100000109893&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；支付宝支付、指纹方式。&quot;</span>);<br>        pay.doPay(<span class="hljs-string">&quot;jlu19dlxo111&quot;</span>,<span class="hljs-string">&quot;100000109894&quot;</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上分别测试了两种不同的支付类型和支付模式：微信人脸支付和支付宝指纹支付。</p><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">模拟测试场景；微信支付、人脸方式。<br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 模拟微信渠道支付划账开始。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 人脸支付，风控校验脸部识别<br><br>模拟测试场景；支付宝支付、指纹方式。<br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 模拟支付宝渠道支付划账开始。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 指纹支付，风控校验指纹信息<br></code></pre></td></tr></table></figure><p>从测试结果看，已经满足了不同支付类型和支付模式的组合，但是这样的代码在后面的维护以及扩展过程中都会变得非常复杂。</p><h3 id="桥接模式重构代码"><a href="#桥接模式重构代码" class="headerlink" title="桥接模式重构代码"></a>桥接模式重构代码</h3><p>从上面的if…else实现方式来看，这是两种不同类型的相互组合。可以把支付类型和支付模式分离，通过抽象类依赖实现类的方式进行桥接。按照这种方式拆分后，支付方式与支付模式可以单独使用，当需要组合时，只需要把模式传递给各类支付方式。</p><p>桥接模式的关键是选择桥接点拆分，看能否找到这样类似的相互组合，如果没有就不用必须使用桥接模式。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-8.png" alt></p><ul><li>Pay是一个抽象类，下面是它的两种支付类型：微信支付和支付宝支付</li><li>IPayMode是一个接口，下面是它的三种支付模式：密码支付、人脸支付和指纹支付</li><li>支付类型×支付模式=相应的组合</li></ul><p><strong>注意：</strong>针对不同的支付模式，人脸支付和指纹支付校验逻辑也有差异，可以使用适配器模式进行处理，这里并非本节重点所以不做介绍，可以阅读适配器模式章节。</p><p><strong>支付类型桥接抽象类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pay</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(Pay.class);<br><br>    <span class="hljs-keyword">protected</span> IPayMode payMode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pay</span><span class="hljs-params">(IPayMode payMode)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.payMode = payMode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">transfer</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中定义了支付类型需要实现的划账接口transfer和桥接接口IPayMode，并在构造函数中实现用户方自行选择支付方式。如果没有接触过此类支付需求，可以重点关注IPayMode payMode，这部分是桥接模式的核心。</p><p><strong>两种支付类型的实现：</strong></p><ol><li><p><strong>微信支付</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pay</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WxPay</span><span class="hljs-params">(IPayMode payMode)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(payMode);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">transfer</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">boolean</span> security = payMode.security(uId);<br>        logger.info(<span class="hljs-string">&quot;模拟微信渠道支付风控校验。uId：&#123;&#125; tradeId：&#123;&#125; security：&#123;&#125;&quot;</span>, uId, tradeId, security);<br>        <span class="hljs-keyword">if</span> (!security) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账拦截。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0001&quot;</span>;<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账成功。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>支付宝支付</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZfbPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pay</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZfbPay</span><span class="hljs-params">(IPayMode payMode)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(payMode);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">transfer</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">boolean</span> security = payMode.security(uId);<br>        logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付风控校验。uId：&#123;&#125; tradeId：&#123;&#125; security：&#123;&#125;&quot;</span>, uId, tradeId, security);<br>        <span class="hljs-keyword">if</span> (!security) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账拦截。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0001&quot;</span>;<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账成功。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这里分别模拟了调用第三方的两种支付渠道：微信和支付宝。当然，作为支付综合平台，可能不只接入了这两种渠道，还会有其他渠道。另外，可以看到，在支付时分别调用了风控的接口进行校验，也就是不同的模式支付（人脸、指纹），都需要通过指定的风控校验，才能保证支付安全。</p><p><strong>定义支付模式接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPayMode</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>任何一种支付模式，包括人脸、指纹和密码，都会通过风控校验不同程度的安全信息，这里定义一个安全校验接口。</p><p><strong>三种支付模式风控（人脸、指纹和密码）：</strong></p><ol><li><p><strong>人脸</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayFaceMode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPayMode</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(PayCypher.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;人脸支付，风控校验脸部识别&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>指纹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayFingerprintMode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPayMode</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(PayCypher.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;指纹支付，风控校验指纹信息&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>密码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayCypher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPayMode</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(PayCypher.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;密码支付，风控校验环境安全&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这里实现了人脸、指纹和密码三种支付模式的风控校验，在用户选择不同支付模式时，会进行相应的风控拦截，以保障支付安全。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_pay</span><span class="hljs-params">()</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；微信支付、人脸方式。&quot;</span>);<br>        Pay wxPay = <span class="hljs-keyword">new</span> WxPay(<span class="hljs-keyword">new</span> PayFaceMode());<br>        wxPay.transfer(<span class="hljs-string">&quot;weixin_1092033111&quot;</span>, <span class="hljs-string">&quot;100000109893&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；支付宝支付、指纹方式。&quot;</span>);<br>        Pay zfbPay = <span class="hljs-keyword">new</span> ZfbPay(<span class="hljs-keyword">new</span> PayFingerprintMode());<br>        zfbPay.transfer(<span class="hljs-string">&quot;jlu19dlxo111&quot;</span>, <span class="hljs-string">&quot;100000109894&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>与上面的 if…else 实现方式相比，这里的调用方式变得整洁、干净和易用：new WxPay（new PayFaceMode（））、new ZfbPay（new PayFingerprintMode（））。外部使用接口的用户不需要关心具体的实现，只要按需选择使用即可。以上优化主要针对桥接模式的使用进行重构if逻辑部分。对于调用部分，可以使用抽象工厂或策略模式配合MAP结构。在 Map 结构中，Key 作为逻辑名称、Value 作为逻辑实现。通过这种方式把服务配置到Map键值对中，可以更方便地获取和使用，从而避免大量使用if…else。因为这里主要展示桥接模式，所以就不再额外多加代码，避免喧宾夺主。</p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">模拟测试场景；微信支付、人脸方式。<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟微信渠道支付划账开始。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.mode.PayCypher - 人脸支付，风控校验脸部识别<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟微信渠道支付风控校验。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> security：<span class="hljs-keyword">true</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟微信渠道支付划账成功。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> amount：<span class="hljs-number">100</span><br><br>模拟测试场景；支付宝支付、指纹方式。<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟支付宝渠道支付划账开始。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.mode.PayCypher - 指纹支付，风控校验指纹信息<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟支付宝渠道支付风控校验。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> security：<span class="hljs-keyword">true</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟支付宝渠道支付划账成功。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> amount：<span class="hljs-number">100</span><br><br>进程已结束,退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>从测试结果来看，内容也是一样的，但是整体的实现方式有了很大的变化。所以，有时不能只看结果，也要看具体的实现过程。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过模拟微信与支付宝两种支付类型在不同支付模式下的组合使用，体现了桥接模式的精髓。这种设计模式简化了代码的开发，给后续的需求迭代增加了很好的扩展性。</p><p>从桥接模式的实现形式来看，它满足了单一职责和开闭原则，让每一部分内容都很清晰，易于维护和扩展。但如果实现的是高内聚的代码，则会很复杂。所以在选择重构代码时，需要考虑整体的设计。如果运用的设计模式不合理，也会让代码变得难以开发和维护。</p><p>任何一种设计模式的选择和使用都应该以符合场景为主，不能刻意使用。由于业务的复杂性，可能需要用到多种设计模式，才能将代码设计得更加合理。但这种经验需要从实际的项目中总结经验，并且不断地实践运用。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="组合模式介绍"><a href="#组合模式介绍" class="headerlink" title="组合模式介绍"></a>组合模式介绍</h3><p>使用乐高玩具，通过一系列的连接组织出一棵 结构树。而这种通过把相似对象或方法组合成一组可被调用的结构树 对象的设计思路，称为组合模式。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-9.png" alt></p><p>这种设计方式可以让服务组节点进行自由组合并对外提供服务，例如有三个原子校验功能服务（A：身份证；B：银行卡；C：手机号）并对外提供调用。有些调用方需要使用 AB 组合，有些调用方需要使用 CBA 组合，还有一些调用方可能只使用三者中的一个。这时就可以使用组合模式构建服务，对于不同类型的调用方配置不同的组织关系树，而这个树形结构可以配置到数据库中，通过程序图形界面控制树形结构的创建和修改。</p><p>所以，不同的设计模式用得恰到好处，可以让代码逻辑非常清晰且易于扩展，同时也可以降低团队人员学习项目的成本。</p><h3 id="决策树场景模拟"><a href="#决策树场景模拟" class="headerlink" title="决策树场景模拟"></a>决策树场景模拟</h3><p>如图所示为一个简化版的营销规则决策树，根据性别、年龄的不同组合，发放不同类型的优惠券，目的是刺激消费，对精准用户进行促活。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-10.png" alt></p><p>虽然我们可能没有开发过营销项目，但可能时时刻刻都在被营销着。例如，男生喜欢经常浏览机械键盘、笔记本电脑和汽车装饰等，商家会推荐此类商品的信息或优惠通知。女生喜欢浏览衣服、化妆品和箱包等，商家会推荐此类商品的信息或促销消息。虽然用户进入的是同一款软件，但最终展示的内容会略有不同，这些都是营销的案例。对于不常使用电商软件的用户，商家可能还会稍微加大折扣的力度，来增加用户黏性。</p><p>这里模拟一个类似的决策场景，体现组合模式在其中起到的作用。另外，组合模式不仅可以运用于规则决策树，还可以做服务包装，将不同的接口进行组合配置，对外提供服务能力，降低开发成本。</p><h3 id="违背设计模式实现-2"><a href="#违背设计模式实现-2" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>这里举一个关于if…else诞生的例子，介绍运营伙伴与研发人员之间的故事导致的事故。</p><div class="table-container"><table><thead><tr><th>日期</th><th>需求</th><th>紧急程度</th><th>程序员（话外音）</th></tr></thead><tbody><tr><td>星期一，早上</td><td>哥哥，老板说要做一下营销活动，给男生和女生发不同的优惠券</td><td>很紧急，下班就要</td><td>行吧，也不难，加一下判断就上线</td></tr><tr><td>星期二，下午</td><td>哥哥，上线后效果非常好，老板说要让咱们按照年轻、中年和老年加一下判断，准确刺激消费</td><td>超紧急，明天就要</td><td>也不难，加就加吧</td></tr><tr><td>星期三，晚上</td><td>喂，睡了吗？老板说咱们这次活动很成功，是否可以再细分一下，把单身、结婚和有娃的都加上不同的判断，这样更能刺激消费</td><td>贼紧急，最快上线</td><td>已经意思到if…else越来越多了</td></tr><tr><td>星期四，凌晨</td><td>哇！你们太棒了，上戏真快，嘻嘻！有个小请求，需要调整一下年龄段，因为现在学生谈恋爱时更容易买某某东西，要改一下值！辛苦辛苦！</td><td>老板在等着呢</td><td>一大堆值要修改，哎！这么多if…else</td></tr><tr><td>星期五，半夜</td><td>喂，坏了，怎么发的优惠券不对了，有客诉了，很多女生都来投诉，你快看看，老板他……</td><td>一头汗，哎，值的位置粘错了</td><td>流下了悔恨的泪水</td></tr></tbody></table></div><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-11.png" alt></p><p>上面的工程结构非常简单，把判断逻辑使用if…else写到一个类中。使用面向过程的优点是代码实现得快，但缺点也很多：不好维护和扩展，出了问题难以排查，新加功能的风险较高等。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(EngineController.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String userId, <span class="hljs-keyword">final</span> String userSex, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userAge)</span> </span>&#123;<br><br>        logger.info(<span class="hljs-string">&quot;ifelse实现方式判断用户结果。userId：&#123;&#125; userSex：&#123;&#125; userAge：&#123;&#125;&quot;</span>, userId, userSex, userAge);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;man&quot;</span>.equals(userSex)) &#123;<br>            <span class="hljs-keyword">if</span> (userAge &lt; <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实A&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (userAge &gt;= <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实B&quot;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;woman&quot;</span>.equals(userSex)) &#123;<br>            <span class="hljs-keyword">if</span> (userAge &lt; <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实C&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (userAge &gt;= <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实D&quot;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果不考虑可扩展性和可维护性，上面的代码实现起来是最快的，而且从代码结构上看也便于理解。但非常不建议用这种方式实现代码逻辑，因为if语句嵌套太多，随着功能逻辑的扩展，会有越来越多的if语句，最终就是常说的一片烂代码。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_EngineController</span><span class="hljs-params">()</span> </span>&#123;<br>        EngineController engineController = <span class="hljs-keyword">new</span> EngineController();<br>        String process = engineController.process(<span class="hljs-string">&quot;Oli09pLkdjh&quot;</span>, <span class="hljs-string">&quot;man&quot;</span>, <span class="hljs-number">29</span>);<br>        logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, process);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里模拟了一个用户ID，并传输性别为man、年龄为29，预期结果为果实B。</p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">36</span>:<span class="hljs-number">25.650</span> [main] INFO  cn.bugstack.design.EngineController - ifelse实现方式判断用户结果。userId：Oli09pLkdjh userSex：man userAge：<span class="hljs-number">29</span><br><span class="hljs-number">14</span>:<span class="hljs-number">36</span>:<span class="hljs-number">25.654</span> [main] INFO  cn.bugstack.design.test.ApiTest - 测试结果：果实B<br></code></pre></td></tr></table></figure><p>从测试结果来看，程序运行正常并且符合预期，只不过实现方式并不是我们推荐的。接下来会采用组合模式优化这部分代码。</p><h3 id="组合模式重构代码"><a href="#组合模式重构代码" class="headerlink" title="组合模式重构代码"></a>组合模式重构代码</h3><p>重构代码的改动量相对来说会比较大，为了把不同类型的决策节点和最终的果实组装成一棵可被程序运行的决策树，需要做适配设计和工厂方法调用，具体会体现在定义接口和抽象类、初始化配置决策节点（性别、年龄）上。建议多阅读几遍这部分代码，最好动手实践。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-12.png" alt></p><p>树形结构原子模块实现关系从LogicFilter开始定义适配的决策过滤器，BaseLogic是对接口的实现，以提供最基本的通用方法。UserAgeFilter和UserGenerFilter是两个具体的实现类，用于判断年龄和性别。树形结构执行引擎是对这棵可以被组织出来的决策树进行执行的引擎，同样定义了引擎接口和基础的配置，在配置里面设定了需要的模式决策节点。</p><p><strong>决策树对象类：</strong></p><div class="table-container"><table><thead><tr><th>包路径</th><th>类</th><th>介绍</th></tr></thead><tbody><tr><td>model.aggregates</td><td>TreeRich</td><td>聚合对象：包含组织树信息</td></tr><tr><td>model.vo</td><td>EngineResult</td><td>决策结果：返回对象信息</td></tr><tr><td>model.vo</td><td>TreeNode</td><td>树节点：包括叶子节点，果实节点</td></tr><tr><td>model.vo</td><td>TreeNodeLink</td><td>树节点链路关系</td></tr><tr><td>model.vo</td><td>TreeRoot</td><td>树根信息</td></tr></tbody></table></div><p>以上是在model包下的对象，用于描述决策树的各项信息类，包括：聚合对象、决策结果、树节点、树节点链路关系和树根信息。</p><p><strong>树节点逻辑过滤器接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LogicFilter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 逻辑决策器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> matterValue          决策值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeNodeLineInfoList 决策节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 下一个节点Id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Long <span class="hljs-title">filter</span><span class="hljs-params">(String matterValue, List&lt;TreeNodeLink&gt; treeNodeLineInfoList)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取决策值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> decisionMatter 决策物料</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 决策值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这部分定义了适配的通用接口和相应的方法：逻辑决策器方法、获取决策值方法，让每一个提供决策能力的节点都必须实现此接口，保证统一性。</p><p><strong>决策抽象类提供基础服务：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseLogic</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LogicFilter</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">filter</span><span class="hljs-params">(String matterValue, List&lt;TreeNodeLink&gt; treeNodeLinkList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TreeNodeLink nodeLine : treeNodeLinkList) &#123;<br>            <span class="hljs-keyword">if</span> (decisionLogic(matterValue, nodeLine)) <span class="hljs-keyword">return</span> nodeLine.getNodeIdTo();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">decisionLogic</span><span class="hljs-params">(String matterValue, TreeNodeLink nodeLink)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (nodeLink.getRuleLimitType()) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> matterValue.equals(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &gt; Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &lt; Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &lt;= Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &gt;= Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在抽象方法中实现了接口方法，同时定义了基本的决策方法：1、2、3、4、5，等于、小于、大于、小于或等于、大于或等于的判断逻辑。同时定义了抽象方法，让每一个实现接口的类都必须按照规则提供决策值，这个决策值用于进行逻辑比对。</p><p><strong>树节点逻辑实现类：</strong></p><ol><li><p><strong>年龄节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAgeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseLogic</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> decisionMatter.get(<span class="hljs-string">&quot;age&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>性别节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGenderFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseLogic</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> decisionMatter.get(<span class="hljs-string">&quot;gender&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>以上两个决策逻辑的节点获取值的方式都非常简单，只获取用户的入参即可。实际的业务开发可能需要通过数据库、RPC接口和缓存运算等各种方式获取产品需要的信息。</p><p><strong>决策引擎接口定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IEngine</span> </span>&#123;<br><br>    <span class="hljs-function">EngineResult <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Long treeId, <span class="hljs-keyword">final</span> String userId, TreeRich treeRich, <span class="hljs-keyword">final</span> Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对于调用方来说，也同样需要定义统一的接口操作，这样的好处是便于后续扩展出不同类型的决策引擎，也就是建造不同的决策工厂。</p><p><strong>决策节点配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Map&lt;String, LogicFilter&gt; logicFilterMap;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        logicFilterMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>        logicFilterMap.put(<span class="hljs-string">&quot;userAge&quot;</span>, <span class="hljs-keyword">new</span> UserAgeFilter());<br>        logicFilterMap.put(<span class="hljs-string">&quot;userGender&quot;</span>, <span class="hljs-keyword">new</span> UserGenderFilter());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, LogicFilter&gt; <span class="hljs-title">getLogicFilterMap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> logicFilterMap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLogicFilterMap</span><span class="hljs-params">(Map&lt;String, LogicFilter&gt; logicFilterMap)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.logicFilterMap = logicFilterMap;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以将服务的决策节点配置到Map结构中，这样的Map结构可以抽取到XML或数据库中，就可以方便地在 ERP 界面中配置服务了。当需要变更时，不用改动代码，便于管理。</p><p><strong>基础决策引擎功能：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EngineConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IEngine</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(EngineBase.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> EngineResult <span class="hljs-title">process</span><span class="hljs-params">(Long treeId, String userId, TreeRich treeRich, Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> TreeNode <span class="hljs-title">engineDecisionMaker</span><span class="hljs-params">(TreeRich treeRich, Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        TreeRoot treeRoot = treeRich.getTreeRoot();<br>        Map&lt;Long, TreeNode&gt; treeNodeMap = treeRich.getTreeNodeMap();<br>        <span class="hljs-comment">// 规则树根ID</span><br>        Long rootNodeId = treeRoot.getTreeRootNodeId();<br>        TreeNode treeNodeInfo = treeNodeMap.get(rootNodeId);<br>        <span class="hljs-comment">//节点类型[NodeType]；1子叶、2果实</span><br>        <span class="hljs-keyword">while</span> (treeNodeInfo.getNodeType().equals(<span class="hljs-number">1</span>)) &#123;<br>            String ruleKey = treeNodeInfo.getRuleKey();<br>            LogicFilter logicFilter = logicFilterMap.get(ruleKey);<br>            String matterValue = logicFilter.matterValue(treeId, userId, decisionMatter);<br>            Long nextNode = logicFilter.filter(matterValue, treeNodeInfo.getTreeNodeLinkList());<br>            treeNodeInfo = treeNodeMap.get(nextNode);<br>            logger.info(<span class="hljs-string">&quot;决策树引擎=&gt;&#123;&#125; userId：&#123;&#125; treeId：&#123;&#125; treeNode：&#123;&#125; ruleKey：&#123;&#125; matterValue：&#123;&#125;&quot;</span>, treeRoot.getTreeName(), userId, treeId, treeNodeInfo.getTreeNodeId(), ruleKey, matterValue);<br>        &#125;<br>        <span class="hljs-keyword">return</span> treeNodeInfo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要提供决策树流程的处理过程，有点像通过链路的关系（性别、年龄）在二叉树中寻找果实节点的过程。同时提供一个抽象方法，执行决策流程的方法，供外部做具体的实现。</p><p><strong>决策引擎的实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeEngineHandle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EngineBase</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EngineResult <span class="hljs-title">process</span><span class="hljs-params">(Long treeId, String userId, TreeRich treeRich, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        <span class="hljs-comment">// 决策流程</span><br>        TreeNode treeNode = engineDecisionMaker(treeRich, treeId, userId, decisionMatter);<br>        <span class="hljs-comment">// 决策结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EngineResult(userId, treeId, treeNode.getTreeNodeId(), treeNode.getNodeValue());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里对于决策引擎的实现就非常简单了，通过传递进来的必要信息——决策树信息、决策物料值，做具体的树形结构决策。</p><p><strong>初始化决策树数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 节点：1</span><br>    TreeNode treeNode_01 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_01.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_01.setTreeNodeId(<span class="hljs-number">1L</span>);<br>    treeNode_01.setNodeType(<span class="hljs-number">1</span>);<br>    treeNode_01.setNodeValue(<span class="hljs-keyword">null</span>);<br>    treeNode_01.setRuleKey(<span class="hljs-string">&quot;userGender&quot;</span>);<br>    treeNode_01.setRuleDesc(<span class="hljs-string">&quot;用户性别[男/女]&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：1-&gt;11</span><br>    TreeNodeLink treeNodeLink_11 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_11.setNodeIdFrom(<span class="hljs-number">1L</span>);<br>    treeNodeLink_11.setNodeIdTo(<span class="hljs-number">11L</span>);<br>    treeNodeLink_11.setRuleLimitType(<span class="hljs-number">1</span>);<br>    treeNodeLink_11.setRuleLimitValue(<span class="hljs-string">&quot;man&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：1-&gt;12</span><br>    TreeNodeLink treeNodeLink_12 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_12.setNodeIdFrom(<span class="hljs-number">1L</span>);<br>    treeNodeLink_12.setNodeIdTo(<span class="hljs-number">12L</span>);<br>    treeNodeLink_12.setRuleLimitType(<span class="hljs-number">1</span>);<br>    treeNodeLink_12.setRuleLimitValue(<span class="hljs-string">&quot;woman&quot;</span>);<br><br>    List&lt;TreeNodeLink&gt; treeNodeLinkList_1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    treeNodeLinkList_1.add(treeNodeLink_11);<br>    treeNodeLinkList_1.add(treeNodeLink_12);<br><br>    treeNode_01.setTreeNodeLinkList(treeNodeLinkList_1);<br><br>    <span class="hljs-comment">// 节点：11</span><br>    TreeNode treeNode_11 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_11.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_11.setTreeNodeId(<span class="hljs-number">11L</span>);<br>    treeNode_11.setNodeType(<span class="hljs-number">1</span>);<br>    treeNode_11.setNodeValue(<span class="hljs-keyword">null</span>);<br>    treeNode_11.setRuleKey(<span class="hljs-string">&quot;userAge&quot;</span>);<br>    treeNode_11.setRuleDesc(<span class="hljs-string">&quot;用户年龄&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：11-&gt;111</span><br>    TreeNodeLink treeNodeLink_111 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_111.setNodeIdFrom(<span class="hljs-number">11L</span>);<br>    treeNodeLink_111.setNodeIdTo(<span class="hljs-number">111L</span>);<br>    treeNodeLink_111.setRuleLimitType(<span class="hljs-number">3</span>);<br>    treeNodeLink_111.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：11-&gt;112</span><br>    TreeNodeLink treeNodeLink_112 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_112.setNodeIdFrom(<span class="hljs-number">11L</span>);<br>    treeNodeLink_112.setNodeIdTo(<span class="hljs-number">112L</span>);<br>    treeNodeLink_112.setRuleLimitType(<span class="hljs-number">5</span>);<br>    treeNodeLink_112.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    List&lt;TreeNodeLink&gt; treeNodeLinkList_11 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    treeNodeLinkList_11.add(treeNodeLink_111);<br>    treeNodeLinkList_11.add(treeNodeLink_112);<br><br>    treeNode_11.setTreeNodeLinkList(treeNodeLinkList_11);<br><br>    <span class="hljs-comment">// 节点：12</span><br>    TreeNode treeNode_12 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_12.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_12.setTreeNodeId(<span class="hljs-number">12L</span>);<br>    treeNode_12.setNodeType(<span class="hljs-number">1</span>);<br>    treeNode_12.setNodeValue(<span class="hljs-keyword">null</span>);<br>    treeNode_12.setRuleKey(<span class="hljs-string">&quot;userAge&quot;</span>);<br>    treeNode_12.setRuleDesc(<span class="hljs-string">&quot;用户年龄&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：12-&gt;121</span><br>    TreeNodeLink treeNodeLink_121 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_121.setNodeIdFrom(<span class="hljs-number">12L</span>);<br>    treeNodeLink_121.setNodeIdTo(<span class="hljs-number">121L</span>);<br>    treeNodeLink_121.setRuleLimitType(<span class="hljs-number">3</span>);<br>    treeNodeLink_121.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：12-&gt;122</span><br>    TreeNodeLink treeNodeLink_122 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_122.setNodeIdFrom(<span class="hljs-number">12L</span>);<br>    treeNodeLink_122.setNodeIdTo(<span class="hljs-number">122L</span>);<br>    treeNodeLink_122.setRuleLimitType(<span class="hljs-number">5</span>);<br>    treeNodeLink_122.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    List&lt;TreeNodeLink&gt; treeNodeLinkList_12 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    treeNodeLinkList_12.add(treeNodeLink_121);<br>    treeNodeLinkList_12.add(treeNodeLink_122);<br><br>    treeNode_12.setTreeNodeLinkList(treeNodeLinkList_12);<br><br>    <span class="hljs-comment">// 节点：111</span><br>    TreeNode treeNode_111 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_111.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_111.setTreeNodeId(<span class="hljs-number">111L</span>);<br>    treeNode_111.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_111.setNodeValue(<span class="hljs-string">&quot;果实A&quot;</span>);<br><br>    <span class="hljs-comment">// 节点：112</span><br>    TreeNode treeNode_112 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_112.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_112.setTreeNodeId(<span class="hljs-number">112L</span>);<br>    treeNode_112.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_112.setNodeValue(<span class="hljs-string">&quot;果实B&quot;</span>);<br><br>    <span class="hljs-comment">// 节点：121</span><br>    TreeNode treeNode_121 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_121.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_121.setTreeNodeId(<span class="hljs-number">121L</span>);<br>    treeNode_121.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_121.setNodeValue(<span class="hljs-string">&quot;果实C&quot;</span>);<br><br>    <span class="hljs-comment">// 节点：122</span><br>    TreeNode treeNode_122 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_122.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_122.setTreeNodeId(<span class="hljs-number">122L</span>);<br>    treeNode_122.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_122.setNodeValue(<span class="hljs-string">&quot;果实D&quot;</span>);<br><br>    <span class="hljs-comment">// 树根</span><br>    TreeRoot treeRoot = <span class="hljs-keyword">new</span> TreeRoot();<br>    treeRoot.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeRoot.setTreeRootNodeId(<span class="hljs-number">1L</span>);<br>    treeRoot.setTreeName(<span class="hljs-string">&quot;规则决策树&quot;</span>);<br><br>    Map&lt;Long, TreeNode&gt; treeNodeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    treeNodeMap.put(<span class="hljs-number">1L</span>, treeNode_01);<br>    treeNodeMap.put(<span class="hljs-number">11L</span>, treeNode_11);<br>    treeNodeMap.put(<span class="hljs-number">12L</span>, treeNode_12);<br>    treeNodeMap.put(<span class="hljs-number">111L</span>, treeNode_111);<br>    treeNodeMap.put(<span class="hljs-number">112L</span>, treeNode_112);<br>    treeNodeMap.put(<span class="hljs-number">121L</span>, treeNode_121);<br>    treeNodeMap.put(<span class="hljs-number">122L</span>, treeNode_122);<br><br>    treeRich = <span class="hljs-keyword">new</span> TreeRich(treeRoot, treeNodeMap);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>这部分是组合模式非常重要的使用，在已经建造好的决策树关系下，可以创建出树的各个节点，以及对节点间使用链路进行串联。即使后续需要做任何业务的扩展，都可以在里面添加相应的节点，并做动态化的配置。这部分手动组合的方式可以提取到数据库中，也可以扩展到图形界面配置操作。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_tree</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;决策树组合结构信息：\r\n&quot;</span> + JSON.toJSONString(treeRich));<br><br>    IEngine treeEngineHandle = <span class="hljs-keyword">new</span> TreeEngineHandle();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试数据</span><br><span class="hljs-comment">     * 果实A：gender=man、age=22</span><br><span class="hljs-comment">     * 果实B：gender=man、age=29</span><br><span class="hljs-comment">     * 果实C：gender=woman、age=22</span><br><span class="hljs-comment">     * 果实D：gender=woman、age=29</span><br><span class="hljs-comment">     */</span><br>    Map&lt;String, String&gt; decisionMatter = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    decisionMatter.put(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;man&quot;</span>);<br>    decisionMatter.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;29&quot;</span>);<br><br>    EngineResult result = treeEngineHandle.process(<span class="hljs-number">10001L</span>, <span class="hljs-string">&quot;Oli09pLkdjh&quot;</span>, treeRich, decisionMatter);<br>    logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, JSON.toJSONString(result));<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在单元测试中，提供了通过组合模式创建出的流程决策树，调用时传入了决策树的ID。在业务开发中，可以很方便地解耦决策树与业务的绑定关系，按需传入决策树ID即可。这里的入参提供了需要决策的信息男（man）、年龄（29 岁）的参数信息。另外，以下数据也可以模拟测试。</p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.805</span> [main] INFO  cn.bugstack.design.test.ApiTest - 决策树组合结构信息：<br>&#123;<span class="hljs-string">&quot;treeNodeMap&quot;</span>:&#123;<span class="hljs-number">112</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实B&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">112</span>&#125;,<span class="hljs-number">1</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleDesc&quot;</span>:<span class="hljs-string">&quot;用户性别[男/女]&quot;</span>,<span class="hljs-string">&quot;ruleKey&quot;</span>:<span class="hljs-string">&quot;userGender&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;treeNodeLinkList&quot;</span>:[&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;man&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;woman&quot;</span>&#125;]&#125;,<span class="hljs-number">121</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实C&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">121</span>&#125;,<span class="hljs-number">122</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实D&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">122</span>&#125;,<span class="hljs-number">11</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleDesc&quot;</span>:<span class="hljs-string">&quot;用户年龄&quot;</span>,<span class="hljs-string">&quot;ruleKey&quot;</span>:<span class="hljs-string">&quot;userAge&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;treeNodeLinkList&quot;</span>:[&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">111</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">112</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;]&#125;,<span class="hljs-number">12</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleDesc&quot;</span>:<span class="hljs-string">&quot;用户年龄&quot;</span>,<span class="hljs-string">&quot;ruleKey&quot;</span>:<span class="hljs-string">&quot;userAge&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;treeNodeLinkList&quot;</span>:[&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">121</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">122</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;]&#125;,<span class="hljs-number">111</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实A&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">111</span>&#125;&#125;,<span class="hljs-string">&quot;treeRoot&quot;</span>:&#123;<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeName&quot;</span>:<span class="hljs-string">&quot;规则决策树&quot;</span>,<span class="hljs-string">&quot;treeRootNodeId&quot;</span>:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.821</span> [main] INFO  c.b.d.d.service.engine.EngineBase - 决策树引擎=&gt;规则决策树 userId：Oli09pLkdjh treeId：<span class="hljs-number">10001</span> treeNode：<span class="hljs-number">11</span> ruleKey：userGender matterValue：man<br><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.821</span> [main] INFO  c.b.d.d.service.engine.EngineBase - 决策树引擎=&gt;规则决策树 userId：Oli09pLkdjh treeId：<span class="hljs-number">10001</span> treeNode：<span class="hljs-number">112</span> ruleKey：userAge matterValue：<span class="hljs-number">29</span><br><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.821</span> [main] INFO  cn.bugstack.design.test.ApiTest - 测试结果：&#123;<span class="hljs-string">&quot;nodeId&quot;</span>:<span class="hljs-number">112</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实B&quot;</span>,<span class="hljs-string">&quot;success&quot;</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;userId&quot;</span>:<span class="hljs-string">&quot;Oli09pLkdjh&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>从测试结果可以得出程序运行正常，这与使用if…else编码风格实现的结果是一致的。但代码经过组合模式重构后，非常便于业务功能的拓展和代码维护。此外，整体的组织关系框架及调用决策流程已经搭建完成，如果阅读到此还没有完全理解，可以参考源代码工程结构并运行调试。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>从以上的决策树场景来看，组合模式主要解决的是在不同结构的组织下，一系列简单逻辑节点或者扩展的复杂逻辑节点对外部的调用仍然可以非常简单。这种设计模式保证了开闭原则，无须更改模型结构就可以提供新的逻辑节点，并配合组织出新的关系树。当然，如果是一些功能差异化非常大的接口，则包装起来也会变得比较困难，但也并非不能很好地处理，只不过需要做一些适配和特定的开发。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="装饰器模式介绍"><a href="#装饰器模式介绍" class="headerlink" title="装饰器模式介绍"></a>装饰器模式介绍</h3><p>装饰器模式就像俄罗斯套娃，它的核心是在不改变原有类的基础上给类新增功能。对于不改变原有类，可能有的人会想到继承、AOP 切面，虽然这些方式都可以实现，但是使用装饰器模式是另外一种更灵活的思路，能够避免继承导致的子类过多问题，也可以避免AOP带来的复杂性问题。</p><p>很多熟悉的场景都用到了装饰器模式，例如是否熟悉 new BufferedReader（new FileReader（””））；这段代码？大家在学习Java开发的字节流、字符流和文件流的内容时都见到过，一层嵌套一层，字节流转字符流等。这就是使用装饰器模式的一种体现。</p><h3 id="单点登录场景模拟"><a href="#单点登录场景模拟" class="headerlink" title="单点登录场景模拟"></a>单点登录场景模拟</h3><p>本案例模拟一个单点登录权限功能扩充的场景。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-13.png" alt></p><p>在业务开发的初期，往往运营人员使用的是 ERP 系统，只需要登录账户验证即可，验证通过后即可访问 ERP 的所有资源。但随着业务的不断发展，团队里开始出现专门的运营人员、营销人员和数据人员，每类人员对ERP的使用需求不同，有些需要创建活动，有些只是查看数据。同时，为了保证数据的安全，不会让每位运营人员都有最高的权限。</p><p>那么，以往使用的 SSO 是一个组件化通用的服务，不能在里面添加需要的用户访问验证功能。这时就可以使用装饰器模式扩充原有的单点登录服务，同时也保证原有功能不受破坏，可以继续使用。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-14.png" alt></p><p>这里模拟的是Spring类HandlerInterceptor，实现接口功能SsoInterceptor模拟的单点登录拦截服务。为了避免引入太多的 Spring 内容，影响对设计模式的理解，这里使用了同名的类和方法，尽可能减少外部的依赖。</p><p><strong>模拟Spring的HandlerInterceptor：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际的单点登录开发会基于 org.springframework.web.servlet.HandlerInterceptor 实现。这里为了减少对Spring包的引入，自己实现一个这样的功能类。</p><p><strong>模拟单点登录功能：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SsoInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟获取cookie</span><br>        String ticket = request.substring(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>        <span class="hljs-comment">// 模拟校验</span><br>        <span class="hljs-keyword">return</span> ticket.equals(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的模拟实现非常简单，只是截取字符串，在实际使用时，需要从HttpServletRequest request对象中获取cookie信息，解析 ticket 值并校验。在返回的里面也非常简单，只要获取到了 success，就认为是允许登录。实际的业务代码会更加复杂，这里只是简单模拟了整个过程，方便学习。</p><h3 id="违背设计模式实现-3"><a href="#违背设计模式实现-3" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>继承类的实现方式是一种比较通用的方式，通过继承后重写方法，并将逻辑覆盖进去。对于一些简单的且不需要持续维护和扩展的场景，此种方式的实现并不会有什么问题，也不会导致子类过多。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-15.png" alt></p><p>以上的工程结构非常简单，只是通过 LoginSsoDecorator 继承 SsoInterceptor，重写方法功能。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginSsoDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SsoInterceptor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; authMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        authMap.put(<span class="hljs-string">&quot;huahua&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>        authMap.put(<span class="hljs-string">&quot;doudou&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 模拟获取cookie</span><br>        String ticket = request.substring(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>        <span class="hljs-comment">// 模拟校验</span><br>        <span class="hljs-keyword">boolean</span> success = ticket.equals(<span class="hljs-string">&quot;success&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        String userId = request.substring(<span class="hljs-number">8</span>);<br>        String method = authMap.get(userId);<br><br>        <span class="hljs-comment">// 模拟方法校验</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;queryUserInfo&quot;</span>.equals(method);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码的实现方式是通过继承类后重写方法，将个人可访问方法的功能添加到方法中。这段代码比较清晰，如果面对比较复杂的业务流程，代码就会很变得混乱。注意，这里已经设定好两个可以访问的用户ID：huahua、doudou，会在测试中使用。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_LoginSsoDecorator</span><span class="hljs-params">()</span> </span>&#123;<br>        LoginSsoDecorator ssoDecorator = <span class="hljs-keyword">new</span> LoginSsoDecorator();<br>        String request = <span class="hljs-string">&quot;1successhuahua&quot;</span>;<br>        <span class="hljs-keyword">boolean</span> success = ssoDecorator.preHandle(request, <span class="hljs-string">&quot;ewcdqwt40liuiu&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;登录校验：&quot;</span> + request + (success ? <span class="hljs-string">&quot; 放行&quot;</span> : <span class="hljs-string">&quot; 拦截&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里模拟的内容相当于登录过程中的校验操作，判断用户是否可登录以及是否可访问方法。</p><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">登录校验：1successhuahua 放行<br></code></pre></td></tr></table></figure><p>从测试结果来看满足预期，已经对用户 huahua 做了放行。在学习的过程中，可以尝试模拟单点登录并继承扩展功能。</p><h3 id="装饰器模式重构代码"><a href="#装饰器模式重构代码" class="headerlink" title="装饰器模式重构代码"></a>装饰器模式重构代码</h3><p>装饰器主要解决的是直接继承时因功能的不断横向扩展导致子类膨胀的问题，而使用装饰器模式比直接继承更加灵活，同时也不再需要维护子类。</p><p>在装饰器模式中，有四点比较重要：</p><ul><li>抽象构件角色（Component）：定义抽象接口</li><li>具体构件角色（ConcreteComponent）：实现抽象接口，可以是 一组</li><li>装饰角色（Decorator）：定义抽象类并实现接口中的方法，保证一致性</li><li>具体装饰角色（ConcreteDecorator）：扩展装饰具体的实现逻辑</li></ul><p>通过以上四种实现装饰器模式，主要核心内容会体现在抽象类的定义和实现方面。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-16.png" alt></p><p>重点的类是SsoDecorator，它表示一个抽象类主要完成了对接口 HandlerInterceptor 的继承。当装饰角色继承接口后，会提供构造函数 SsoDecorator（HandlerInterceptor handlerInterceptor），入参是继承的接口实现类，可以很方便地扩展出不同的功能组件。</p><p><strong>抽象类装饰角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SsoDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> HandlerInterceptor handlerInterceptor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SsoDecorator</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SsoDecorator</span><span class="hljs-params">(HandlerInterceptor handlerInterceptor)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.handlerInterceptor = handlerInterceptor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> handlerInterceptor.preHandle(request, response, handler);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在装饰类中，有三点需要注意：实现了处理接口，提供了构造函数，覆盖了方法preHandle。以上三点是装饰器模式的核心处理部分，可以替换对子类继承的方式，实现逻辑功能的扩展。</p><p><strong>装饰角色逻辑实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginSsoDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SsoDecorator</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginSsoDecorator.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; authMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        authMap.put(<span class="hljs-string">&quot;huahua&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>        authMap.put(<span class="hljs-string">&quot;doudou&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginSsoDecorator</span><span class="hljs-params">(HandlerInterceptor handlerInterceptor)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(handlerInterceptor);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">super</span>.preHandle(request, response, handler);<br>        <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        String userId = request.substring(<span class="hljs-number">8</span>);<br>        String method = authMap.get(userId);<br>        logger.info(<span class="hljs-string">&quot;模拟单点登录方法访问拦截校验：&#123;&#125; &#123;&#125;&quot;</span>, userId, method);<br>        <span class="hljs-comment">// 模拟方法校验</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;queryUserInfo&quot;</span>.equals(method);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在具体的装饰类实现中，继承了装饰类 SsoDecorator，现在可以扩展方法 preHandle 的功能。在具体的实现代码中可以看到，这里只关心扩展部分的功能，同时不会影响原有类的核心服务，也不会因为使用继承方式而导致出现多余子类，增加了整体的灵活性。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_LoginSsoDecorator</span><span class="hljs-params">()</span> </span>&#123;<br>        LoginSsoDecorator ssoDecorator = <span class="hljs-keyword">new</span> LoginSsoDecorator(<span class="hljs-keyword">new</span> SsoInterceptor());<br>        String request = <span class="hljs-string">&quot;1successhuahua&quot;</span>;<br>        <span class="hljs-keyword">boolean</span> success = ssoDecorator.preHandle(request, <span class="hljs-string">&quot;ewcdqwt40liuiu&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;登录校验：&quot;</span> + request + (success ? <span class="hljs-string">&quot; 放行&quot;</span> : <span class="hljs-string">&quot; 拦截&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里测试了装饰器模式的使用，通过将原有单点登录类new SsoInterceptor（）传递给装饰器，让装饰器可以执行扩充的功能。同时，传递者和装饰器都可以是多组的。在实际的业务开发中，往往由于有 太多类型的子类要实现，导致不易于维护，可以使用装饰器模式替代。</p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">04.942</span> [main] INFO  cn.bugstack.design.LoginSsoDecorator - 模拟单点登录方法访问拦截校验：huahua queryUserInfo<br>登录校验：1successhuahua 放行<br></code></pre></td></tr></table></figure><p>测试结果符合预期，扩展了对方法拦截的校验性。如果在学习的过程中用过单点登录，那么可以适当地在里面采用扩展装饰器模式练习。另外，还有一种场景也可以使用装饰器。例如，之前实现某个接口接收单个消息，但由于外部的升级变为发送list集合消息，但又不希望所有的代码类都修改这部分逻辑，就可以使用装饰器模式进行适配list集合，给使用者的依然是for循环后的单个消息。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>装饰器模式满足单一职责原则，可以在自己的装饰类中完成功能逻辑的扩展而不影响主类，同时可以按需在运行时添加和删除这部分逻辑。另外，装饰器模式和继承父类重写方法在某些时候要按需选择，并非某个方式就是最好的。装饰器模式实现的重点是对抽象类继承接口方式的使用，同时设定被继承的接口可以通过构造函数传递其实现类，由此增加扩展性，并重写方法中可以通过父类实现的功能。装饰器模式就像夏天热时穿短裤，冬天冷时穿棉裤，下雨时穿雨衣一 样，我们本身并没有被改变，而外形却用不同的服饰表现。生活中的场景比比皆是，如果能够将生活中的例子融入代码实现中，往往会创造出更加优雅的实现方式。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="外观模式介绍"><a href="#外观模式介绍" class="headerlink" title="外观模式介绍"></a>外观模式介绍</h3><p>物流公司的货物从上架到分拣出库，对外部的送货人和取货人来说，他们并不需要知道仓库内的工作。这种模式称为外观模式，也叫门面模式。它主要解决的是降低调用方使用接口时的复杂逻辑组合。在调用方与实际的接口提供方之间添加了一个中间层，向包装逻辑提供API接口。有时外观模式也被用在中间件层，用服务中的通用性复杂逻辑包装中间件层，让使用方可以只关心业务开发，简化调用。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-17.png" alt></p><p>这种设计模式在设计产品功能时也经常会遇到，例如以往注册成为一家网站的用户时，往往要添加很多信息，包括姓名、昵称、手机号、QQ、邮箱和住址等，但现在只需要一步即可，无论是手机号还是微信，都提供了这种登录服务。对于服务端应用开发来说，以前是提供了一整套的接口，现在注册时并没有这些信息，那么服务端就需要包装接口，在前端调用注册时，服务端各个渠道获取相应的用户信息。如果获取不到，会让用户后续补全，以此来提高用户的注册量和活跃度。</p><h3 id="中间件场景模拟"><a href="#中间件场景模拟" class="headerlink" title="中间件场景模拟"></a>中间件场景模拟</h3><p>本章模拟一个将所有服务接口添加白名单的场景。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-18.png" alt></p><p>在项目不断壮大发展的过程中，每一次发版上线都需要测试，而这部分测试验证一般会通过白名单开量或切量的方式验证。如果在每一个接口中都添加这种逻辑，就会非常麻烦且不易维护。另外，这是一类具备通用逻辑的共性需求，非常适合开发成组件，以此治理服务，从而让研发人员可以将精力放在业务功能逻辑的开发上。</p><p>一般情况下，外观模式通常用在复杂的场景中，或有多个接口需要包装以统一对外提供服务时。此种使用方式相对简单，在日常的业务开发中也是最常用的。本例把这种设计思路放到中间件层，让服务变得可以统一控制。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-19.png" alt></p><p>这是一个 SpringBoot 的 HelloWorld 工程，在工程中提供了查询用户信息的接口HelloWorldController.queryUserInfo，为后续扩展此接口的白名单过滤做准备。</p><p><strong>定义基础查询接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@DoDoor</span> 自定义注解</span><br><span class="hljs-comment">     * key：需要从入参取值的属性字段，如果是对象则从对象中取值，如果是单个值则直接使用</span><br><span class="hljs-comment">     * returnJson：预设拦截时返回值，是返回对象的Json</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * http://localhost:8080/api/queryUserInfo?userId=1001</span><br><span class="hljs-comment">     * http://localhost:8080/api/queryUserInfo?userId=小团团</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DoDoor(key = &quot;userId&quot;, returnJson = &quot;&#123;\&quot;code\&quot;:\&quot;1111\&quot;,\&quot;info\&quot;:\&quot;非白名单可访问用户拦截！\&quot;&#125;&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/api/queryUserInfo&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">queryUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;虫虫:&quot;</span> + userId, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;天津市南开区旮旯胡同100号&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里提供了一个基本的查询服务，通过入参userId查询用户信息，后续需要扩展白名单功能。白名单是指只有指定用户才可以查询，其他用户不能查询。</p><p><strong>设置Application启动类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(HelloWorldApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里是通用的SpringBoot启动类。需要添加的是一个配置注解@Configuration，便于后续读取白名单配置。</p><h3 id="违背设计模式实现-4"><a href="#违背设计模式实现-4" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>最简单的做法是直接修改代码。累加if块既是实现需求最快也是最慢的方式，快是指修改当前内容快，慢是指如果同类的内容有几百个，都需要使用这种修改方式，会让后续扩展和维护的进度越来越慢。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20.png" alt></p><p>以上的实现方式是模拟一个API接口类，在里面添加白名单功能，但类似这种接口有很多地方需要修改，这也是不推荐使用此种方式的主要原因。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldController</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">queryUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String userId)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 做白名单拦截</span><br>        List&lt;String&gt; userList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        userList.add(<span class="hljs-string">&quot;1001&quot;</span>);<br>        userList.add(<span class="hljs-string">&quot;aaaa&quot;</span>);<br>        userList.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!userList.contains(userId)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;1111&quot;</span>, <span class="hljs-string">&quot;非白名单可访问用户拦截！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;虫虫:&quot;</span> + userId, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;天津市南开区旮旯胡同100号&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>从以上的实现方式可以看出，白名单的逻辑代码占据了一大块，但它不是业务功能流程中的逻辑，只是因为上线过程中需要在开量前测试验证。如果平时对待此类需求是用这种方式解决的，那么可以按照此种设计模式进行优化，让后续的扩展和剔除更容易。</p><h3 id="外观模式重构代码"><a href="#外观模式重构代码" class="headerlink" title="外观模式重构代码"></a>外观模式重构代码</h3><p>这次重构的核心是使用外观模式，结合SpringBoot中自定义starter中间件开发的方式，统一处理所有需要开白名单逻辑的代码。</p><p>在接下来的实现过程中，涉及的知识点包括：</p><ul><li>SpringBoot的starter中间件开发方式</li><li>面向切面编程和自定义注解的使用方法</li><li>外部自定义配置信息的透传。SpringBoot与Spring不同，对于此类方式获取白名单配置存在差异</li></ul><p><strong>工程结构：</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-21.png" alt></p><p><strong>注意：</strong>设计模式讲求的是思想，而不是固定的实现方式。</p><p><strong>配置服务类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String userStr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StarterService</span><span class="hljs-params">(String userStr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userStr = userStr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String[] split(String separatorChar) &#123;<br>        <span class="hljs-keyword">return</span> StringUtils.split(<span class="hljs-keyword">this</span>.userStr, separatorChar);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>配置服务类的内容比较简单，只是为了获取 SpringBoot 中配置文件的信息内容。</p><p><strong>配置类注解定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;itstack.door&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterServiceProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String userStr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserStr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userStr;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserStr</span><span class="hljs-params">(String userStr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userStr = userStr;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>配置类注解用于定义后续在 application.yml 中添加 itstack.door 的配置信息。</p><p><strong>获取自定义配置类信息：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(StarterService.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(StarterServiceProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterAutoConfigure</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StarterServiceProperties properties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;itstack.door&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span><br>    <span class="hljs-function">StarterService <span class="hljs-title">starterService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StarterService(properties.getUserStr());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码是获取配置的过程，主要是对注解@Configuration、@ConditionalOnClass、@EnableConfigurationProperties的定义，这一部分主要是与SpringBoot的结合使用方法。</p><p><strong>切面注解定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DoDoor &#123;<br><br>    <span class="hljs-function">String <span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">returnJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>切面注解定义了外观模式切面注解，后续将此注解添加到需要扩展白名单的方法上。这里提供了两个入参：key获取某个字段，例如用户ID；returnJson确定白名单拦截后返回的具体内容。</p><p><strong>白名单切面逻辑：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoJoinPoint</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(DoJoinPoint.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StarterService starterService;<br><br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(cn.bugstack.design.door.annotation.DoDoor)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aopPoint</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;aopPoint()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doRouter</span><span class="hljs-params">(ProceedingJoinPoint jp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Method method = getMethod(jp);<br>        DoDoor door = method.getAnnotation(DoDoor.class);<br><br>        String keyValue = getFiledValue(door.key(), jp.getArgs());<br>        logger.info(<span class="hljs-string">&quot;itstack door handler method：&#123;&#125; value：&#123;&#125;&quot;</span>, method.getName(), keyValue);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == keyValue || <span class="hljs-string">&quot;&quot;</span>.equals(keyValue)) <span class="hljs-keyword">return</span> jp.proceed();<br><br>        String[] split = starterService.split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-comment">// 白名单过滤</span><br>        <span class="hljs-keyword">for</span> (String str : split) &#123;<br>            <span class="hljs-keyword">if</span> (keyValue.equals(str)) &#123;<br>                <span class="hljs-keyword">return</span> jp.proceed();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 拦截</span><br>        <span class="hljs-keyword">return</span> returnObject(door, method);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">getMethod</span><span class="hljs-params">(JoinPoint jp)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>        Signature sig = jp.getSignature();<br>        MethodSignature methodSignature = (MethodSignature) sig;<br>        <span class="hljs-keyword">return</span> getClass(jp).getMethod(methodSignature.getName(), methodSignature.getParameterTypes());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Class&lt;? extends Object&gt; getClass(JoinPoint jp) <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>        <span class="hljs-keyword">return</span> jp.getTarget().getClass();<br>    &#125;<br><br>    <span class="hljs-comment">//返回对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">returnObject</span><span class="hljs-params">(DoDoor doGate, Method method)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;<br>        Class&lt;?&gt; returnType = method.getReturnType();<br>        String returnJson = doGate.returnJson();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(returnJson)) &#123;<br>            <span class="hljs-keyword">return</span> returnType.newInstance();<br>        &#125;<br>        <span class="hljs-keyword">return</span> JSON.parseObject(returnJson, returnType);<br>    &#125;<br><br>    <span class="hljs-comment">//获取属性值</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFiledValue</span><span class="hljs-params">(String filed, Object[] args)</span> </span>&#123;<br>        String filedValue = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == filedValue || <span class="hljs-string">&quot;&quot;</span>.equals(filedValue)) &#123;<br>                    filedValue = BeanUtils.getProperty(arg, filed);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>].toString();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> filedValue;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里包括的内容较多，核心逻辑主要是 Object doRouter（ProceedingJoinPoint jp），接下来分别介绍：</p><ul><li><p>@Pointcut(“@annotation(cn.bugstack.design.door.annot ation.DoDoor)”)</p><p>定义切面，这里采用的是注解路径，也就是所有加入这个注解的方法都会被切面管理</p></li><li><p>getFiledValue</p><p>获取指定key，也就是获取入参中的某个属性，这里主要是获取用户ID，通过ID拦截校验</p></li><li><p>returnObject</p><p>返回拦截后的转换对象，当非白名单用户访问时，会返回一些提示信息</p></li><li><p>doRouter</p><p>切面核心逻辑，这部分主要是判断当前访问的用户ID是否为白名单用户。如果是，则放行jp.proceed（）；，否则返回自定义的拦截提示信息</p></li></ul><p><strong>重构后工程验证：</strong></p><p>这里的测试会在工程cn-bugstack-design-13.0-0中进行，通过引入jar包、配置注解的方式验证。</p><p><strong>引入中间件POM配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.bugstack.design<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tutorials-13.0-2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包白名单控制中间件工程cn-bugstack-design-13.0-2，给外部提供jar包服务。在实际的开发中，将这种jar包上传到Maven仓库，供调用方引入。</p><p><strong>配置application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 自定义中间件配置</span><br><span class="hljs-attr">itstack:</span><br>  <span class="hljs-attr">door:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">userStr:</span> <span class="hljs-number">1001</span><span class="hljs-string">,aaaa,ccc</span> <span class="hljs-comment">#白名单用户ID，多个逗号隔开</span><br></code></pre></td></tr></table></figure><p>这里主要加入了白名单的开关和用户ID，用逗号隔开。即用户ID为1001、aaaa和ccc的三位用户可以正常访问接口。</p><p><strong>在Controller中添加自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * http://localhost:8080/api/queryUserInfo?userId=1001</span><br><span class="hljs-comment"> * http://localhost:8080/api/queryUserInfo?userId=小团团</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@DoDoor(key = &quot;userId&quot;, returnJson = &quot;&#123;\&quot;code\&quot;:\&quot;1111\&quot;,\&quot;info\&quot;:\&quot;非白名单可访问用户拦截！\&quot;&#125;&quot;)</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/api/queryUserInfo&quot;, method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">queryUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String userId)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;虫虫:&quot;</span> + userId, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;天津市南开区旮旯胡同100号&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>核心的内容主要是对自定义的注解添加@DoDoor，即外观模式的中间件化实现。</p><ul><li>key：是需要从入参中取值的属性字段，如果是对象，则从对象中取值；如果是单个值，则直接使用</li><li>returnJson：是预设拦截时的返回值，是返回对象的JSON文件</li></ul><p><strong>启动SpringBoot</strong></p><p>启动正常，SpringBoot 已经可以对外提供服务。启动的过程非常简单，直接在类HelloWorldApplication中运行即可</p><p><strong>访问接口测试</strong></p><ol><li><p><strong>白名单用户访问</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-22.png" alt></p><p>此时的测试结果显示正常，可以收到接口数据。</p></li><li><p><strong>非白名单用户访问</strong></p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-23.png" alt></p><p>这次把userId换成小团团，此时返回的信息已经是被拦截的信息。而这个拦截信息正是自定义注解中的信息@DoDoor（key=”userId”，returnJson=”{\”code\”：\”1111\”，\”info\”：\”非白名单可访问用户拦截！\”}”）。</p></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>本章通过中间件的方式实现外观模式，这种设计可以很好地增强代码的隔离性及复用性，不仅使用起来非常灵活，也降低了对每一个系统开发白名单拦截服务带来的风险及测试成本。可能有读者认为这只是非常简单的白名单控制，会有是否需要这样处理的疑问。但往往一个小小的开始会影响后续迭代的扩展，实际的业务开发往往也会复杂得多。很多时候不是设计模式没有用，而是研发人员的编程开发经验不足，导致即使学了设计模式也很难驾驭。毕竟这些知识都是经过一些实际操作提炼出来的，只要按照本书中案例的方式学习实操，是可以提升代码架构和设计能力的。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="享元模式介绍"><a href="#享元模式介绍" class="headerlink" title="享元模式介绍"></a>享元模式介绍</h3><p>享元模式主要用于共享通用对象，减少内存的使用，提升系统的访问效率。较大的对象通常比较耗费内存，需要查询大量的接口或使用数据库资源，因此有必要统一抽离出来作为共享对象使用。</p><p>另外，享元模式可以分为在服务端和在客户端，一般在互联网H5和Web场景下，大部分数据都需要在服务端处理，如数据库连接池的使用、多线程线程池的使用。除了这些功能，有些需要经过服务端包装处理再下发给客户端，因为服务端需要做享元处理。但在一些游戏场 景中，很多客户端需要渲染地图效果，如树木、花草、鱼虫，通过设置不同的元素描述，使用享元共用对象，可以减少内存的占用，让客户端的游戏更加流畅。在享元模式的实现过程中，需要用到享元工厂管理独立的对象和共享的对象，避免出现线程安全的问题。</p><h3 id="缓存优化查询场景"><a href="#缓存优化查询场景" class="headerlink" title="缓存优化查询场景"></a>缓存优化查询场景</h3><p>本案例模拟商品秒杀场景中使用享元模式优化查询。</p><p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-24.png" alt></p><p>你是否经历过一个商品下单功能的项目，从最初的日均十几单到一个月后每个时段流量破万。如果没有相关经验，最初可能会使用数据库行级锁的方式保证商品库存的扣减操作。随着业务的快速发展，参与秒杀的用户越来越多，这时数据库已经无法支撑，所以一般会使用Redis的分布式锁控制商品库存。另外，针对不同商品信息的查询，不需要每次都从数据库中获取，因为除了商品库存，其他商品信息都是固定不变的，所以一般会缓存到Redis中。这里模拟使用享元模式搭建工厂结构，提供活动商品的查询服务。商品信息相当于不变的信息，商品库存相当于变化的信息。</p><h3 id="违背设计模式实现-5"><a href="#违背设计模式实现-5" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>对于这部分逻辑的查询，一般情况下都是先查询固定不变的商品信息，再使用过滤的信息或通过添加if判断的方式补充变化的信息，也就是商品库存。虽然采用这种编写方式在最开始并不会发现什么问题，但随着方法逻辑的增加，就会有越来越多的重复代码。</p><p><strong>工程结构：</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式笔记（二）创建型模式</title>
    <link href="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="工厂模式介绍"><a href="#工厂模式介绍" class="headerlink" title="工厂模式介绍"></a>工厂模式介绍</h3><p>工厂模式也称简单工厂模式，是创建型设计模式的一种，这种设计模式提供了按需创建对象的最佳方式。同时，这种创建方式不会对外暴露创建细节，并且会通过一个统一的接口创建所需对象。</p><p>这种设计模式也是Java开发中常见的一种模式，它的主要意图是定义一个创建对象的接口，让其子类自己决定将哪一个工厂类实例化，工厂模式使创建过程延迟到子类中进行。</p><p>简单地说，就是为了给代码结构提供扩展性，屏蔽每一个功能类中的具体实现逻辑。这种方式便于外部更加简单地调用，同时也是去掉众多if…else的最佳手段。当然，这种设计模式也有一些缺点，需要治理。例如需要实现的类比较多、难以维护、开发成本高等，但这些问题都可以通过结合不同的设计模式逐步优化。</p><h3 id="模拟发放多种奖品"><a href="#模拟发放多种奖品" class="headerlink" title="模拟发放多种奖品"></a>模拟发放多种奖品</h3><p>为了更贴近真实场景的实际开发，这里模拟互联网运营活动中营销场景的业务需求，由于营销场景存在复杂性、多变性、临时性，因此在研发设计时需要更加深入地了解业务需求；否则会经常面临各种紧急穿插的需求，让原本简单的增删改查（CRUD）实现变得臃肿不堪、代码结构极其混乱，最终难以维护，也无法防控风 险。</p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-1.png" alt></p><p>在营销场景中，经常会约定在用户完成打卡、分享、留言、邀请注册等一系列行为操作后进行返利积分操作。用户再通过这些返利积分兑换商品，从而让整个系统构成一个生态闭环，达到促活和拉新的目的。假设现在有如表所示的三种类型的商品接口。</p><div class="table-container"><table><thead><tr><th>序号</th><th>类型</th><th>接口</th></tr></thead><tbody><tr><td>1</td><td>优惠券</td><td>CouponResult sendCoupon(String uId, String couponNumber, String uuid)</td></tr><tr><td>2</td><td>实物商品</td><td>Boolean deliverGoods(DeliverReq req)</td></tr><tr><td>3</td><td>第三方兑换卡（爱奇艺）</td><td>void grantToken(String bindMobileNumber, String cardId)</td></tr></tbody></table></div><p>从以上接口来看，有如下信息：</p><ul><li>三种接口返回类型不同，有对象类型、布尔类型和空类型。</li><li>入参不同，发放优惠券需要防重、实物商品需要发货位置（对象中含有）、兑换卡需要卡ID。</li><li>可能会随着后续业务的发展，新增其他的商品类型。因为所有的开发需求都是由业务对市场的拓展带来的。</li></ul><h3 id="违背设计模式实现"><a href="#违背设计模式实现" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>如果不考虑程序的任何扩展性，只为了尽快满足需求，那么对这三种奖励的发放只需使用if…else语句判断，调用不同的接口即可。我们先按照这样的方式实现业务需求，最后再使用设计模式重构这段代码，方便对照理解。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2.png" alt></p><p>整个工程结构非常简单，包括一个入参对象AwardReq、一个出参对象AwardRes，以及奖品发放的服务类PrizeController。接下来，给出核心抽奖类的实现代码。</p><p><strong>if…else实现需求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrizeController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(PrizeController.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AwardRes <span class="hljs-title">awardToUser</span><span class="hljs-params">(AwardReq req)</span> </span>&#123;<br>        String reqJson = JSON.toJSONString(req);<br>        AwardRes awardRes = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;奖品发放开始&#123;&#125;。req:&#123;&#125;&quot;</span>, req.getuId(), reqJson);<br>            <span class="hljs-comment">// 按照不同类型方法商品[1优惠券、2实物商品、3第三方兑换卡(爱奇艺)]</span><br>            <span class="hljs-keyword">if</span> (req.getAwardType() == <span class="hljs-number">1</span>) &#123;<br>                CouponService couponService = <span class="hljs-keyword">new</span> CouponService();<br>                CouponResult couponResult = couponService.sendCoupon(req.getuId(), req.getAwardNumber(), req.getBizId());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;0000&quot;</span>.equals(couponResult.getCode())) &#123;<br>                    awardRes = <span class="hljs-keyword">new</span> AwardRes(<span class="hljs-string">&quot;0000&quot;</span>, <span class="hljs-string">&quot;发放成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    awardRes = <span class="hljs-keyword">new</span> AwardRes(<span class="hljs-string">&quot;0001&quot;</span>, couponResult.getInfo());<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.getAwardType() == <span class="hljs-number">2</span>) &#123;<br>                GoodsService goodsService = <span class="hljs-keyword">new</span> GoodsService();<br>                DeliverReq deliverReq = <span class="hljs-keyword">new</span> DeliverReq();<br>                deliverReq.setUserName(queryUserName(req.getuId()));<br>                deliverReq.setUserPhone(queryUserPhoneNumber(req.getuId()));<br>                deliverReq.setSku(req.getAwardNumber());<br>                deliverReq.setOrderId(req.getBizId());<br>                deliverReq.setConsigneeUserName(req.getExtMap().get(<span class="hljs-string">&quot;consigneeUserName&quot;</span>));<br>                deliverReq.setConsigneeUserPhone(req.getExtMap().get(<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>));<br>                deliverReq.setConsigneeUserAddress(req.getExtMap().get(<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>));<br>                Boolean isSuccess = goodsService.deliverGoods(deliverReq);<br>                <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                    awardRes = <span class="hljs-keyword">new</span> AwardRes(<span class="hljs-string">&quot;0000&quot;</span>, <span class="hljs-string">&quot;发放成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    awardRes = <span class="hljs-keyword">new</span> AwardRes(<span class="hljs-string">&quot;0001&quot;</span>, <span class="hljs-string">&quot;发放失败&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.getAwardType() == <span class="hljs-number">3</span>) &#123;<br>                String bindMobileNumber = queryUserPhoneNumber(req.getuId());<br>                IQiYiCardService iQiYiCardService = <span class="hljs-keyword">new</span> IQiYiCardService();<br>                iQiYiCardService.grantToken(bindMobileNumber, req.getAwardNumber());<br>                awardRes = <span class="hljs-keyword">new</span> AwardRes(<span class="hljs-string">&quot;0000&quot;</span>, <span class="hljs-string">&quot;发放成功&quot;</span>);<br>            &#125;<br>            logger.info(<span class="hljs-string">&quot;奖品发放完成&#123;&#125;。&quot;</span>, req.getuId());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;奖品发放失败&#123;&#125;。req:&#123;&#125;&quot;</span>, req.getuId(), reqJson, e);<br>            awardRes = <span class="hljs-keyword">new</span> AwardRes(<span class="hljs-string">&quot;0001&quot;</span>, e.getMessage());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> awardRes;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">queryUserName</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;花花&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">queryUserPhoneNumber</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;15200101232&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码使用了if…else语句，用非常直接的方式实现了业务需求。如果仅从产品需求角度来说，确实实现了相应的功能逻辑。甚至靠这样简单粗暴的开发方式，也许能让需求提前上线。既然这样的代码可以实现快速交付，又存在什么问题呢？在互联网业务快速迭代的情况下，这段代码会在源源不断的需求中迭代和拓展。如果这些逻辑都用 if…else填充到一个类里，则非常难以维护。这样的代码使用的时间越久，其重构成本就越高。重构前需要清理所有的使用方，测试回归验证时间加长，带来的风险也会非常高。所以，很多研发人员并不愿意接手这样的代码，如果接手后需求开发又非常紧急，可能根本来不及重构，导致这样的if…else语句还会继续增加。</p><p><strong>测试验证</strong></p><p>下面通过一个单元测试验证上面编写的接口。养成单元测试的好习惯，可以增强代码的质量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_awardToUser</span><span class="hljs-params">()</span> </span>&#123;<br><br>        PrizeController prizeController = <span class="hljs-keyword">new</span> PrizeController();<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟发放优惠券测试\r\n&quot;</span>);<br>        <span class="hljs-comment">// 模拟发放优惠券测试</span><br>        AwardReq req01 = <span class="hljs-keyword">new</span> AwardReq();<br>        req01.setuId(<span class="hljs-string">&quot;10001&quot;</span>);<br>        req01.setAwardType(<span class="hljs-number">1</span>);<br>        req01.setAwardNumber(<span class="hljs-string">&quot;EGM1023938910232121323432&quot;</span>);<br>        req01.setBizId(<span class="hljs-string">&quot;791098764902132&quot;</span>);<br>        AwardRes awardRes01 = prizeController.awardToUser(req01);<br><br>        logger.info(<span class="hljs-string">&quot;请求参数：&#123;&#125;&quot;</span>, JSON.toJSON(req01));<br>        logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, JSON.toJSON(awardRes01));<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟方法实物商品\r\n&quot;</span>);<br>        <span class="hljs-comment">// 模拟方法实物商品</span><br>        AwardReq req02 = <span class="hljs-keyword">new</span> AwardReq();<br>        req02.setuId(<span class="hljs-string">&quot;10001&quot;</span>);<br>        req02.setAwardType(<span class="hljs-number">2</span>);<br>        req02.setAwardNumber(<span class="hljs-string">&quot;9820198721311&quot;</span>);<br>        req02.setBizId(<span class="hljs-string">&quot;1023000020112221113&quot;</span>);<br>        req02.setExtMap(<span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;consigneeUserName&quot;</span>, <span class="hljs-string">&quot;谢飞机&quot;</span>);<br>            put(<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>, <span class="hljs-string">&quot;15200292123&quot;</span>);<br>            put(<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>, <span class="hljs-string">&quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;</span>);<br>        &#125;&#125;);<br><br>        AwardRes awardRes02 = prizeController.awardToUser(req02);<br>        logger.info(<span class="hljs-string">&quot;请求参数：&#123;&#125;&quot;</span>, JSON.toJSON(req02));<br>        logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, JSON.toJSON(awardRes02));<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n第三方兑换卡(爱奇艺)\r\n&quot;</span>);<br>        AwardReq req03 = <span class="hljs-keyword">new</span> AwardReq();<br>        req03.setuId(<span class="hljs-string">&quot;10001&quot;</span>);<br>        req03.setAwardType(<span class="hljs-number">3</span>);<br>        req03.setAwardNumber(<span class="hljs-string">&quot;AQY1xjkUodl8LO975GdfrYUio&quot;</span>);<br><br>        AwardRes awardRes03 = prizeController.awardToUser(req03);<br>        logger.info(<span class="hljs-string">&quot;请求参数：&#123;&#125;&quot;</span>, JSON.toJSON(req03));<br>        logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, JSON.toJSON(awardRes03));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">模拟发放优惠券测试<br><br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.248</span> [main] INFO  cn.bugstack.design.PrizeController - 奖品发放开始<span class="hljs-number">10001</span>。req:&#123;<span class="hljs-string">&quot;awardNumber&quot;</span>:<span class="hljs-string">&quot;EGM1023938910232121323432&quot;</span>,<span class="hljs-string">&quot;awardType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;bizId&quot;</span>:<span class="hljs-string">&quot;791098764902132&quot;</span>,<span class="hljs-string">&quot;uId&quot;</span>:<span class="hljs-string">&quot;10001&quot;</span>&#125;<br>模拟发放优惠券一张：<span class="hljs-number">10001</span>,EGM1023938910232121323432,<span class="hljs-number">791098764902132</span><br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.252</span> [main] INFO  cn.bugstack.design.PrizeController - 奖品发放完成<span class="hljs-number">10001</span>。<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.254</span> [main] INFO  cn.bugstack.design.test.ApiTest - 请求参数：&#123;<span class="hljs-string">&quot;uId&quot;</span>:<span class="hljs-string">&quot;10001&quot;</span>,<span class="hljs-string">&quot;bizId&quot;</span>:<span class="hljs-string">&quot;791098764902132&quot;</span>,<span class="hljs-string">&quot;awardNumber&quot;</span>:<span class="hljs-string">&quot;EGM1023938910232121323432&quot;</span>,<span class="hljs-string">&quot;awardType&quot;</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.256</span> [main] INFO  cn.bugstack.design.test.ApiTest - 测试结果：&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;0000&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-string">&quot;发放成功&quot;</span>&#125;<br><br>模拟方法实物商品<br><br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.257</span> [main] INFO  cn.bugstack.design.PrizeController - 奖品发放开始<span class="hljs-number">10001</span>。req:&#123;<span class="hljs-string">&quot;awardNumber&quot;</span>:<span class="hljs-string">&quot;9820198721311&quot;</span>,<span class="hljs-string">&quot;awardType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;bizId&quot;</span>:<span class="hljs-string">&quot;1023000020112221113&quot;</span>,<span class="hljs-string">&quot;extMap&quot;</span>:&#123;<span class="hljs-string">&quot;consigneeUserName&quot;</span>:<span class="hljs-string">&quot;谢飞机&quot;</span>,<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>:<span class="hljs-string">&quot;15200292123&quot;</span>,<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>:<span class="hljs-string">&quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;</span>&#125;,<span class="hljs-string">&quot;uId&quot;</span>:<span class="hljs-string">&quot;10001&quot;</span>&#125;<br>模拟发货实物商品一个：&#123;<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>:<span class="hljs-string">&quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;</span>,<span class="hljs-string">&quot;consigneeUserName&quot;</span>:<span class="hljs-string">&quot;谢飞机&quot;</span>,<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>:<span class="hljs-string">&quot;15200292123&quot;</span>,<span class="hljs-string">&quot;orderId&quot;</span>:<span class="hljs-string">&quot;1023000020112221113&quot;</span>,<span class="hljs-string">&quot;sku&quot;</span>:<span class="hljs-string">&quot;9820198721311&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;花花&quot;</span>,<span class="hljs-string">&quot;userPhone&quot;</span>:<span class="hljs-string">&quot;15200101232&quot;</span>&#125;<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.260</span> [main] INFO  cn.bugstack.design.PrizeController - 奖品发放完成<span class="hljs-number">10001</span>。<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.261</span> [main] INFO  cn.bugstack.design.test.ApiTest - 请求参数：&#123;<span class="hljs-string">&quot;extMap&quot;</span>:&#123;<span class="hljs-string">&quot;consigneeUserName&quot;</span>:<span class="hljs-string">&quot;谢飞机&quot;</span>,<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>:<span class="hljs-string">&quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;</span>,<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>:<span class="hljs-string">&quot;15200292123&quot;</span>&#125;,<span class="hljs-string">&quot;uId&quot;</span>:<span class="hljs-string">&quot;10001&quot;</span>,<span class="hljs-string">&quot;bizId&quot;</span>:<span class="hljs-string">&quot;1023000020112221113&quot;</span>,<span class="hljs-string">&quot;awardNumber&quot;</span>:<span class="hljs-string">&quot;9820198721311&quot;</span>,<span class="hljs-string">&quot;awardType&quot;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.261</span> [main] INFO  cn.bugstack.design.test.ApiTest - 测试结果：&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;0000&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-string">&quot;发放成功&quot;</span>&#125;<br><br>第三方兑换卡(爱奇艺)<br><br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.261</span> [main] INFO  cn.bugstack.design.PrizeController - 奖品发放开始<span class="hljs-number">10001</span>。req:&#123;<span class="hljs-string">&quot;awardNumber&quot;</span>:<span class="hljs-string">&quot;AQY1xjkUodl8LO975GdfrYUio&quot;</span>,<span class="hljs-string">&quot;awardType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;uId&quot;</span>:<span class="hljs-string">&quot;10001&quot;</span>&#125;<br>模拟发放爱奇艺会员卡一张：<span class="hljs-number">15200101232</span>，AQY1xjkUodl8LO975GdfrYUio<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.262</span> [main] INFO  cn.bugstack.design.PrizeController - 奖品发放完成<span class="hljs-number">10001</span>。<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.262</span> [main] INFO  cn.bugstack.design.test.ApiTest - 请求参数：&#123;<span class="hljs-string">&quot;uId&quot;</span>:<span class="hljs-string">&quot;10001&quot;</span>,<span class="hljs-string">&quot;awardNumber&quot;</span>:<span class="hljs-string">&quot;AQY1xjkUodl8LO975GdfrYUio&quot;</span>,<span class="hljs-string">&quot;awardType&quot;</span>:<span class="hljs-number">3</span>&#125;<br><span class="hljs-number">11</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52.262</span> [main] INFO  cn.bugstack.design.test.ApiTest - 测试结果：&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;0000&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-string">&quot;发放成功&quot;</span>&#125;<br><br>进程已结束,退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>虽然运行结果正常，满足当前所有的业务产品需求，但这样的实现方式不易于扩展，也非常难以维护，风险很高。</p><h3 id="工厂模式重构代码"><a href="#工厂模式重构代码" class="headerlink" title="工厂模式重构代码"></a>工厂模式重构代码</h3><p>接下来使用工厂模式优化代码，也算是一次代码重构。当整理代码流程并重构后，会发现代码结构更清晰了，也具备了应对下次新增业务需求的扩展性。</p><blockquote><p>注意：以下这段代码重构只是抽离出最核心的部分，方便理解和学习。在实际的业务开发中，还需要额外添加一些其他逻辑，在使用上进行完善，例如调用方式、参数校验和Spring注入等。</p></blockquote><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-3.png" alt></p><p>从上面的工程结构来看，是否有一种感觉：这样的工程看上去更清晰，类的职责更明确，分层可以更好地扩展，可以通过类名就能大概知道每个类的功能。如果暂时还无法理解为什么要这样修改也没有关系，通过源码进行实战操作几次，就可以慢慢掌握工厂模式的技巧了。</p><p><strong>定义发奖接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICommodity</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendCommodity</span><span class="hljs-params">(String uId, String commodityId, String bizId, Map&lt;String, String&gt; extMap)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于所有的奖品，无论是实物商品、优惠券还是第三方兑换卡（爱奇艺），都需要通过程序实现此接口并处理。这样的方式可以保证入参和出参的统一性。</li><li>接口的入参包括：用户 ID（uId）、奖品 ID（commodityId）、业务 ID（bizId）及扩展字段（extMap），用于处理发放实物商品时的收货地址。</li></ul><p><strong>实现三种发奖接口：</strong></p><ol><li><p><strong>优惠券：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponCommodityService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICommodity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(CouponCommodityService.class);<br><br>    <span class="hljs-keyword">private</span> CouponService couponService = <span class="hljs-keyword">new</span> CouponService();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendCommodity</span><span class="hljs-params">(String uId, String commodityId, String bizId, Map&lt;String, String&gt; extMap)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CouponResult couponResult = couponService.sendCoupon(uId, commodityId, bizId);<br>        logger.info(<span class="hljs-string">&quot;请求参数[优惠券] =&gt; uId：&#123;&#125; commodityId：&#123;&#125; bizId：&#123;&#125; extMap：&#123;&#125;&quot;</span>, uId, commodityId, bizId, JSON.toJSON(extMap));<br>        logger.info(<span class="hljs-string">&quot;测试结果[优惠券]：&#123;&#125;&quot;</span>, JSON.toJSON(couponResult));<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;0000&quot;</span>.equals(couponResult.getCode())) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(couponResult.getInfo());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实物商品：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsCommodityService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICommodity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(GoodsCommodityService.class);<br><br>    <span class="hljs-keyword">private</span> GoodsService goodsService = <span class="hljs-keyword">new</span> GoodsService();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendCommodity</span><span class="hljs-params">(String uId, String commodityId, String bizId, Map&lt;String, String&gt; extMap)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        DeliverReq deliverReq = <span class="hljs-keyword">new</span> DeliverReq();<br>        deliverReq.setUserName(queryUserName(uId));<br>        deliverReq.setUserPhone(queryUserPhoneNumber(uId));<br>        deliverReq.setSku(commodityId);<br>        deliverReq.setOrderId(bizId);<br>        deliverReq.setConsigneeUserName(extMap.get(<span class="hljs-string">&quot;consigneeUserName&quot;</span>));<br>        deliverReq.setConsigneeUserPhone(extMap.get(<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>));<br>        deliverReq.setConsigneeUserAddress(extMap.get(<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>));<br><br>        Boolean isSuccess = goodsService.deliverGoods(deliverReq);<br><br>        logger.info(<span class="hljs-string">&quot;请求参数[实物商品] =&gt; uId：&#123;&#125; commodityId：&#123;&#125; bizId：&#123;&#125; extMap：&#123;&#125;&quot;</span>, uId, commodityId, bizId, JSON.toJSON(extMap));<br>        logger.info(<span class="hljs-string">&quot;测试结果[实物商品]：&#123;&#125;&quot;</span>, isSuccess);<br><br>        <span class="hljs-keyword">if</span> (!isSuccess) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;实物商品发放失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">queryUserName</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;花花&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">queryUserPhoneNumber</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;15200101232&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>第三方兑换卡（爱奇艺）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardCommodityService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICommodity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(CardCommodityService.class);<br><br>    <span class="hljs-comment">// 模拟注入</span><br>    <span class="hljs-keyword">private</span> IQiYiCardService iQiYiCardService = <span class="hljs-keyword">new</span> IQiYiCardService();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendCommodity</span><span class="hljs-params">(String uId, String commodityId, String bizId, Map&lt;String, String&gt; extMap)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String mobile = queryUserMobile(uId);<br>        iQiYiCardService.grantToken(mobile, bizId);<br>        logger.info(<span class="hljs-string">&quot;请求参数[爱奇艺兑换卡] =&gt; uId：&#123;&#125; commodityId：&#123;&#125; bizId：&#123;&#125; extMap：&#123;&#125;&quot;</span>, uId, commodityId, bizId, JSON.toJSON(extMap));<br>        logger.info(<span class="hljs-string">&quot;测试结果[爱奇艺兑换卡]：success&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">queryUserMobile</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;15200101232&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>从上面代码实现中可以看到，每一种奖品的实现都包装到自己的类中，当新增、修改或删除逻辑时，都不会影响其他奖品功能的测试，可以降低回归测试和相应的连带风险。</li><li>如果有新增的奖品，只需要按照此结构进行填充对应的实现类即可。这样的实现方式非常易于维护和扩展。</li><li>在统一了入参及出参后，调用方不再需要关心奖品发放的内部逻辑，按照统一的方式即可处理。</li></ul><p><strong>创建商店工厂：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoreFactory</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 奖品类型方式实例化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> commodityType 奖品类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>              实例化对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ICommodity <span class="hljs-title">getCommodityService</span><span class="hljs-params">(Integer commodityType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == commodityType) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == commodityType) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CouponCommodityService();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == commodityType) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GoodsCommodityService();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == commodityType) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CardCommodityService();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;不存在的奖品服务类型&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 奖品类信息方式实例化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 奖品类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>      实例化对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ICommodity <span class="hljs-title">getCommodityService</span><span class="hljs-params">(Class&lt;? extends ICommodity&gt; clazz)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == clazz) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> clazz.newInstance();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个商店的工厂实现类，里面提供了两种获取工厂实现类的方法：一种是依赖奖品类型，另一种是根据奖品类信息进行实例化。这两种方式都有自己的使用场景，按需选择即可。</p><p>在第一种实现方式中用到了 if判断，这里既可以选择使用 switch语句，也可以使用map结构进行配置（key是类型值，value是具体的逻辑实现）。通过商店工厂类获取各种奖品服务，可以非常干净、整洁地处理业务逻辑代码。后续新增的奖品按照这样的结构扩展即可。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_StoreFactory_01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        StoreFactory storeFactory = <span class="hljs-keyword">new</span> StoreFactory();<br><br>        <span class="hljs-comment">// 1. 优惠券</span><br>        ICommodity commodityService_1 = storeFactory.getCommodityService(<span class="hljs-number">1</span>);<br>        commodityService_1.sendCommodity(<span class="hljs-string">&quot;10001&quot;</span>, <span class="hljs-string">&quot;EGM1023938910232121323432&quot;</span>, <span class="hljs-string">&quot;791098764902132&quot;</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 2. 实物商品</span><br>        ICommodity commodityService_2 = storeFactory.getCommodityService(<span class="hljs-number">2</span>);<br>        commodityService_2.sendCommodity(<span class="hljs-string">&quot;10001&quot;</span>, <span class="hljs-string">&quot;9820198721311&quot;</span>, <span class="hljs-string">&quot;1023000020112221113&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;consigneeUserName&quot;</span>, <span class="hljs-string">&quot;谢飞机&quot;</span>);<br>            put(<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>, <span class="hljs-string">&quot;15200292123&quot;</span>);<br>            put(<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>, <span class="hljs-string">&quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;</span>);<br>        &#125;&#125;);<br><br>        <span class="hljs-comment">// 3. 第三方兑换卡(模拟爱奇艺)</span><br>        ICommodity commodityService_3 = storeFactory.getCommodityService(<span class="hljs-number">3</span>);<br>        commodityService_3.sendCommodity(<span class="hljs-string">&quot;10001&quot;</span>, <span class="hljs-string">&quot;AQY1xjkUodl8LO975GdfrYUio&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_StoreFactory_02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        StoreFactory storeFactory = <span class="hljs-keyword">new</span> StoreFactory();<br>        <span class="hljs-comment">// 1. 优惠券</span><br>        ICommodity commodityService = storeFactory.getCommodityService(CouponCommodityService.class);<br>        commodityService.sendCommodity(<span class="hljs-string">&quot;10001&quot;</span>, <span class="hljs-string">&quot;EGM1023938910232121323432&quot;</span>, <span class="hljs-string">&quot;791098764902132&quot;</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在以上的单元测试类中，商店工厂类中的两个方法都写好了各自的测试代码。接下来验证并查看运行结果。</p><p>testStoreFactory01（），测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">模拟发放优惠券一张：<span class="hljs-number">10001</span>,EGM1023938910232121323432,<span class="hljs-number">791098764902132</span><br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">46.698</span> [main] INFO  c.b.d.s.impl.CouponCommodityService - 请求参数[优惠券] =&gt; uId：<span class="hljs-number">10001</span> commodityId：EGM1023938910232121323432 bizId：<span class="hljs-number">791098764902132</span> extMap：<span class="hljs-keyword">null</span><br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">46.728</span> [main] INFO  c.b.d.s.impl.CouponCommodityService - 测试结果[优惠券]：&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;0000&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-string">&quot;发放成功&quot;</span>&#125;<br>模拟发货实物商品一个：&#123;<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>:<span class="hljs-string">&quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;</span>,<span class="hljs-string">&quot;consigneeUserName&quot;</span>:<span class="hljs-string">&quot;谢飞机&quot;</span>,<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>:<span class="hljs-string">&quot;15200292123&quot;</span>,<span class="hljs-string">&quot;orderId&quot;</span>:<span class="hljs-string">&quot;1023000020112221113&quot;</span>,<span class="hljs-string">&quot;sku&quot;</span>:<span class="hljs-string">&quot;9820198721311&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;花花&quot;</span>,<span class="hljs-string">&quot;userPhone&quot;</span>:<span class="hljs-string">&quot;15200101232&quot;</span>&#125;<br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">46.732</span> [main] INFO  c.b.d.s.impl.GoodsCommodityService - 请求参数[实物商品] =&gt; uId：<span class="hljs-number">10001</span> commodityId：<span class="hljs-number">9820198721311</span> bizId：<span class="hljs-number">1023000020112221113</span> extMap：&#123;<span class="hljs-string">&quot;consigneeUserName&quot;</span>:<span class="hljs-string">&quot;谢飞机&quot;</span>,<span class="hljs-string">&quot;consigneeUserAddress&quot;</span>:<span class="hljs-string">&quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;</span>,<span class="hljs-string">&quot;consigneeUserPhone&quot;</span>:<span class="hljs-string">&quot;15200292123&quot;</span>&#125;<br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">46.732</span> [main] INFO  c.b.d.s.impl.GoodsCommodityService - 测试结果[实物商品]：<span class="hljs-keyword">true</span><br>模拟发放爱奇艺会员卡一张：<span class="hljs-number">15200101232</span>，<span class="hljs-keyword">null</span><br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">46.733</span> [main] INFO  c.b.d.s.impl.CardCommodityService - 请求参数[爱奇艺兑换卡] =&gt; uId：<span class="hljs-number">10001</span> commodityId：AQY1xjkUodl8LO975GdfrYUio bizId：<span class="hljs-keyword">null</span> extMap：<span class="hljs-keyword">null</span><br><span class="hljs-number">12</span>:<span class="hljs-number">04</span>:<span class="hljs-number">46.733</span> [main] INFO  c.b.d.s.impl.CardCommodityService - 测试结果[爱奇艺兑换卡]：success<br></code></pre></td></tr></table></figure><p>testStoreFactory02（），测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">模拟发放优惠券一张：<span class="hljs-number">10001</span>,EGM1023938910232121323432,<span class="hljs-number">791098764902132</span><br><span class="hljs-number">12</span>:<span class="hljs-number">05</span>:<span class="hljs-number">08.151</span> [main] INFO  c.b.d.s.impl.CouponCommodityService - 请求参数[优惠券] =&gt; uId：<span class="hljs-number">10001</span> commodityId：EGM1023938910232121323432 bizId：<span class="hljs-number">791098764902132</span> extMap：<span class="hljs-keyword">null</span><br><span class="hljs-number">12</span>:<span class="hljs-number">05</span>:<span class="hljs-number">08.185</span> [main] INFO  c.b.d.s.impl.CouponCommodityService - 测试结果[优惠券]：&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;0000&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-string">&quot;发放成功&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>从运行结果可以看到，这两种获取工厂实现的接口都可以满足业务需求。在实际使用中按需选择即可。这段重构后的代码既满足了业务方和产品经理的需求，也满足了研发人员对代码质量的追求。另外，从运行的测试结果也可以看出来，在进行封装后，这样一整套发放奖品服务有统一的入参、统一的结果。既提高了代码的结构性，也让工程易于维护和扩展。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从优化过程来看，工厂模式并不复杂。一旦理解和掌握，会发现它更加简单，同时也可以借助它提升开发效率。同时，不难总结出它的优点：避免创建者与具体的产品逻辑耦合；满足单一职责，每一个业务逻辑实现都在自己所属的类中完成；满足开闭原则，无须更改使用调用方就可以在程序中引入新的产品类型。当然，这也会带来一些问题，例如有非常多的奖品类型，实现的子类会极速扩张，因此需要使用其他的模式进行优化，这些在后续的设计模式中会逐步介绍。从案例入手学习设计模式往往要比只看理论知识更容易掌握，因为案例学习是缩短理论到实践的有效方式。如果已经有所收获，一定要尝试实操，找一段业务代码练习，以验证自己的想法。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="抽象工厂模式介绍"><a href="#抽象工厂模式介绍" class="headerlink" title="抽象工厂模式介绍"></a>抽象工厂模式介绍</h3><p>抽象工厂也可以称作其他工厂的工厂，它可以在抽象工厂中创建出其他工厂，与工厂模式一样，都是用来解决接口选择的问题，同样都属于创建型模式。</p><p>研发人员可能在业务开发中很少关注这样的设计模式或类似的代码结构，但是这样的场景却一直在我们身边，如下所示：</p><ul><li>不同系统内的回车换行：<ul><li>在UNIX系统里，每行结尾只有&lt;换行&gt;，即\n</li><li>在Windows系统里，每行结尾是&lt;换行&gt;&lt;回车&gt;，即\n\r</li><li>在Mac系统里，每行结尾是&lt;回车&gt;</li></ul></li></ul><h3 id="缓存集群升级场景"><a href="#缓存集群升级场景" class="headerlink" title="缓存集群升级场景"></a>缓存集群升级场景</h3><p>很多初创团队的蛮荒期，并没有完整的底层服务。</p><p>团队在初建时业务体量不大，在预估的系统服务 QPS 较低、系统压力较小、并发访问量少、近一年没有大动作等条件下，结合快速起步、时间紧迫、成本投入的因素，并不会投入特别多的研发资源构建出非常完善的系统架构。</p><p>就像对Redis的使用，可能最开始只需要一个单机就可以满足现状。但随着业务超预期的快速发 展，系统的负载能力也要随之跟上，原有的单机Redis已经无法满足系统的需要。这时就需要建设或者更换更为健壮的Redis集群服务，在这个升级的过程中是不能停系统的，并且需要平滑过渡。</p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-4.png" alt></p><p>随着系统的升级，可以预见的问题有如下几种：</p><ul><li>很多服务用到了Redis，需要一起升级到集群</li><li>需要兼容集群A和集群B，便于后续的灾备，并及时切换集群</li><li>两套集群提供的接口和方法各有差异，需要进行适配</li><li>不能影响目前正常运行的系统</li></ul><p>虽然升级是必须要做的，但怎样执行却显得非常重要。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-5.png" alt></p><p>在以上的场景模拟工程中，包括了如下信息：</p><ul><li>在业务初期，单机 Redis 服务工具类 RedisUtils 主要负责的是提供早期 Redis的使用</li><li>在业务初期，单机 Redis 服务功能类 CacheService 接口以及它对应的实现类CacheServiceImpl</li><li>随着后续业务的发展，新增加两套Redis集群EGM、IIR，作为互备使用</li></ul><p>接下来分别介绍三个Redis服务提供的缓存功能，以及初期的使用方法。同时需要注意这三套Redis服务在使用上会有一些不同，包括：接口的名称、入参的信息，这些也是在使用设计模式时需要优化处理的要点。</p><p><strong>Redis单机服务RedisUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟最开始使用的Redis服务，单机的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtils</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(RedisUtils.class);<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; dataMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;Redis获取数据 key：&#123;&#125;&quot;</span>, key);<br>        <span class="hljs-keyword">return</span> dataMap.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;Redis写入数据 key：&#123;&#125; val：&#123;&#125;&quot;</span>, key, value);<br>        dataMap.put(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;Redis写入数据 key：&#123;&#125; val：&#123;&#125; timeout：&#123;&#125; timeUnit：&#123;&#125;&quot;</span>, key, value, timeout, timeUnit.toString());<br>        dataMap.put(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;Redis删除数据 key：&#123;&#125;&quot;</span>, key);<br>        dataMap.remove(key);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要注意一点，我们是使用Map模拟Redis的相关功能，这样比较方便测试。这里把关注点放在架构设计上。</p><p><strong>Redis集群服务EGM</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟Redis缓存服务，EGM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EGM</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(EGM.class);<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; dataMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">gain</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;EGM获取数据 key：&#123;&#125;&quot;</span>, key);<br>        <span class="hljs-keyword">return</span> dataMap.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;EGM写入数据 key：&#123;&#125; val：&#123;&#125;&quot;</span>, key, value);<br>        dataMap.put(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEx</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;EGM写入数据 key：&#123;&#125; val：&#123;&#125; timeout：&#123;&#125; timeUnit：&#123;&#125;&quot;</span>, key, value, timeout, timeUnit.toString());<br>        dataMap.put(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;EGM删除数据 key：&#123;&#125;&quot;</span>, key);<br>        dataMap.remove(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里模拟第一个Redis集群服务，需要注意观察这里的方法名称及入参信息，与使用单体Redis服务时是不同的。有点像A用mac系统，B用Windows系统，虽然可以做一样的事，但操作方法不同。</p><p><strong>Redis集群服务IIR</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟Redis缓存服务，IIR</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IIR</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(IIR.class);<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; dataMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;IIR获取数据 key：&#123;&#125;&quot;</span>, key);<br>        <span class="hljs-keyword">return</span> dataMap.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;IIR写入数据 key：&#123;&#125; val：&#123;&#125;&quot;</span>, key, value);<br>        dataMap.put(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExpire</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;IIR写入数据 key：&#123;&#125; val：&#123;&#125; timeout：&#123;&#125; timeUnit：&#123;&#125;&quot;</span>, key, value, timeout, timeUnit.toString());<br>        dataMap.put(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;IIR删除数据 key：&#123;&#125;&quot;</span>, key);<br>        dataMap.remove(key);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这是另一套Redis集群服务，有时在企业开发中可能有两套服务做互相备份。这里也是为了模拟，所以添加两套实现同样功能的不同服务，主要体现抽象工厂模式在这里发挥的作用。</p><p>综上可以看到，目前的系统中已经在大量地使用Redis服务，但是因为系统不能满足业务的快速发展，因此需要迁移到集群服务中。而这时有两套集群服务需要兼容使用，又要满足所有的业务系统改造且不能影响线上使用。</p><p><strong>模拟早期单体Redis使用</strong></p><p>接下来介绍在模拟的案例中，对单体Redis服务的使用方式。后续会通过两种方式将这部分代码扩展为使用Redis集群服务。</p><ol><li><p><strong>定义Redis使用接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CacheService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实现Redis使用接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CacheService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RedisUtils redisUtils = <span class="hljs-keyword">new</span> RedisUtils();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisUtils.get(key);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        redisUtils.set(key, value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        redisUtils.set(key, value, timeout, timeUnit);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        redisUtils.del(key);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>目前，Redis使用的代码比较简单，在一些体量不大的业务场景中不会有什么问题。但如果体量增加，改造升级的过程就会比较麻烦。因为此时所有的业务系统都有同样的使用方式，所以如果每一个系统都需要通过硬编码的方式进行改造就不那么容易了。此时，可以先思考怎样从单体Redis的使用升级到 Redis 集群的使用。</p></li></ol><h3 id="违背设计模式实现-1"><a href="#违背设计模式实现-1" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>如果不从全局的升级改造考虑，仅仅是升级自己的系统，那么最快的方式是添加if…else，把Redis集群的使用添加进去。再通过在接口中添加一个使用的Redis集群类型，判断当下调用Redis时应该使用哪个集群。</p><p>可以说这样的改造非常不好，因为这样会需要所有的研发人员改动代码升级。不仅工作量非常大，而且可能存在非常高的风险。这里为了对比代码结构，会先用这种方式升级Redis集群服务。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-6.png" alt></p><p>在这个工程结构中只有两个类，一个是定义缓存使用的接口CacheService，另一个是它的实现类CacheServiceImpl。因为这里选择的是在接口中添加集群类型，判断使用哪个集群，所以需要重新定义接口，并实现新的集群服务类。</p><p><strong>if…else实现需求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 升级后，使用多套Redis集群服务，同时兼容以前单体Redis服务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheClusterServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CacheService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RedisUtils redisUtils = <span class="hljs-keyword">new</span> RedisUtils();<br><br>    <span class="hljs-keyword">private</span> EGM egm = <span class="hljs-keyword">new</span> EGM();<br><br>    <span class="hljs-keyword">private</span> IIR iir = <span class="hljs-keyword">new</span> IIR();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> redisType)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == redisType) &#123;<br>            <span class="hljs-keyword">return</span> egm.gain(key);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == redisType) &#123;<br>            <span class="hljs-keyword">return</span> iir.get(key);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> redisUtils.get(key);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">int</span> redisType)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == redisType) &#123;<br>            egm.set(key, value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == redisType) &#123;<br>            iir.set(key, value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        redisUtils.set(key, value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit, <span class="hljs-keyword">int</span> redisType)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == redisType) &#123;<br>            egm.setEx(key, value, timeout, timeUnit);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == redisType) &#123;<br>            iir.setExpire(key, value, timeout, timeUnit);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        redisUtils.set(key, value, timeout, timeUnit);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> redisType)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == redisType) &#123;<br>            egm.delete(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == redisType) &#123;<br>            iir.del(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        redisUtils.del(key);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的代码升级并不复杂，看上去也比较简单。主要包括如下内容：</p><ul><li>给接口添加Redis集群使用类型，以控制使用哪套集群服务</li><li>如果类型是1，则使用EGM集群；如果类型是2，则使用IIR集群。这在各方法中都有所体现</li><li>因为要体现出Redis集群升级的过程，所以这里保留了单体Redis的使用方式。如果用户传递的redisType是不存在的，则会使用RedisUtils的方式调用Redis服务。这也是一种兼容逻辑，兼容升级过程</li></ul><p><strong>测试验证</strong></p><p>接下来通过JUnit单元测试的方式验证升级集群后的接口服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_CacheServiceAfterImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        CacheService cacheService = <span class="hljs-keyword">new</span> CacheClusterServiceImpl();<br><br>        cacheService.set(<span class="hljs-string">&quot;user_name_01&quot;</span>, <span class="hljs-string">&quot;小傅哥&quot;</span>, <span class="hljs-number">1</span>);<br>        String val01 = cacheService.get(<span class="hljs-string">&quot;user_name_01&quot;</span>, <span class="hljs-number">1</span>);<br>        logger.info(<span class="hljs-string">&quot;缓存集群升级，测试结果：&#123;&#125;&quot;</span>, val01);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">15</span>:<span class="hljs-number">51</span>:<span class="hljs-number">44.173</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.EGM</span> - EGM写入数据 key：user_name_01 val：小傅哥<br><span class="hljs-number">15</span>:<span class="hljs-number">51</span>:<span class="hljs-number">44.177</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.EGM</span> - EGM获取数据 key：user_name_01<br><span class="hljs-number">15</span>:<span class="hljs-number">51</span>:<span class="hljs-number">44.177</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 缓存集群升级，测试结果：小傅哥<br></code></pre></td></tr></table></figure><p>从以上的测试结果来看，此次升级已完成，验证通过。但这样的方式需要整个研发组一起硬编码，不易于维护，也增加了测试难度和未知风险。</p><h3 id="抽象工厂模式重构代码"><a href="#抽象工厂模式重构代码" class="headerlink" title="抽象工厂模式重构代码"></a>抽象工厂模式重构代码</h3><p>接下来使用抽象工厂模式优化代码，也是一次代码重构。在前文介绍过，抽象工厂的实质就是用于创建工厂的工厂。可以理解为有三个物料加工车间，其中任意两个都可以组合出一个新的生产工厂，用于装备汽车或缝纫机。另外，这里会使用代理类的方式实现抽象工厂的创建过程。而两个 Redis 集群服务相当于两个车间，两个车间可以构成两个工厂。通过代理类的实现方式，可以非常方便地实现Redis服务的升级，并且可以在真实的业务场景中做成一个引入的中间件，给各个需要升级的系统使用。这里还有非常重要的一点，集群EGM和集群IIR在部分方法提供上略有不同，如方法名和参数，因此需要增加一个适配接口。最终使用这个适配接口承接两套集群服务，做到统一的服务输出。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-7.png" alt></p><p>简要介绍这部分代码包括的核心内容。整个工程包结构分为三块：工厂包（factory）、工具包（util）和车间包（workshop）</p><ul><li>工厂包：JDKProxyFactory、JDKInvocationHandler两个类是代理类的定义和实现，这部分代码主要通过代理类和反射调用的方式获取工厂及方法调用</li><li>工具包：ClassLoaderUtils类主要用于支撑反射方法调用中参数的处理</li><li>车间包：EGMCacheAdapter、IIRCacheAdapter两个类主要是通过适配器的方式使用两个集群服务。把两个集群服务作为不同的车间，再通过抽象的代理工厂服务把每个车间转换为对应的工厂。这里需要强调一点，抽象工厂并不一定必须使用目前的方式实现。这种使用代理和反射的方式是为了实现一个中间件服务，给所有需要升级 Redis 集群的系统使用。在不同的场景下，会有很多不同的变种方式实现抽象工厂</li></ul><p><strong>定义集群适配器接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICacheAdapter</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>适配器接口的作用是包装两个集群服务，在前面已经提到这两个集群服务在一些接口名称和入参方面各不相同，所以需要进行适配。同时在引入适配器后，也可以非常方便地扩展。</p><p><strong>实现集群适配器接口：</strong></p><ol><li><p><strong>EGM集群：EGMCacheAdapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EGMCacheAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICacheAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> EGM egm = <span class="hljs-keyword">new</span> EGM();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> egm.gain(key);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        egm.set(key, value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        egm.setEx(key, value, timeout, timeUnit);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        egm.delete(key);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IIR集群：IIRCacheAdapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IIRCacheAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICacheAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IIR iir = <span class="hljs-keyword">new</span> IIR();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> iir.get(key);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        iir.set(key, value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        iir.setExpire(key, value, timeout, timeUnit);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        iir.del(key);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>如果是两个集群服务的统一包装，可以看到这些方法名称或入参都已经统一。例如，IIR集群的iir.setExpire和EGM集群的egm.setEx 都被适配成一个方法名称——set方法。</p><p><strong>代理方式的抽象工厂类：</strong></p><ol><li><p><strong>代理抽象工厂JDKProxyFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDKProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;T&gt; cacheClazz, Class&lt;? extends ICacheAdapter&gt; cacheAdapter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        InvocationHandler handler = <span class="hljs-keyword">new</span> JDKInvocationHandler(cacheAdapter.newInstance());<br>        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(classLoader, <span class="hljs-keyword">new</span> Class[]&#123;cacheClazz&#125;, handler);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一点非常重要，就是为什么选择代理方式实现抽象工厂。</p><p>因为要把原单体Redis服务升级为两套 Redis 集群服务，在不破坏原有单体Redis服务和实现类的情况下，也就是cn-bugstack-design-5.0-0 的 CacheServiceImpl，通过一个代理类的方式实现一个集群服务处理类，就可以非常方便地在Spring、SpringBoot等框架中通过注入的方式替换原有的CacheServiceImpl实现。这样中间件设计思路的实现方式具备了良好的插拔性，并可以达到多组集群同时使用和平滑切换的目的。</p><p>getProxy方法的两个入参的作用如下：</p><ul><li><strong>Class &lt; T &gt; cacheClazz</strong>：在模拟的场景中，不同的系统使用的 Redis 服务类名可能有所不同，通过这样的方式便于实例化后的注入操作</li><li><strong>Class&lt;？extends ICacheAdapter&gt; cacheAdapter</strong>：这个参数用于决定实例化哪套集群服务使用Redis功能</li></ul></li><li><p><strong>反射调用方法JDKInvocationHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDKInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ICacheAdapter cacheAdapter;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JDKInvocationHandler</span><span class="hljs-params">(ICacheAdapter cacheAdapter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cacheAdapter = cacheAdapter;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">return</span> ICacheAdapter.class.getMethod(method.getName(), ClassLoaderUtils.getClazzByArgs(args)).invoke(cacheAdapter, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这部分是工厂被代理实现后的核心处理类，主要包括如下功能:</p><ul><li>相同适配器接口 ICacheAdapter 的不同 Redis 集群服务实现，其具体调用会在这里体现</li><li>在反射调用过程中，通过入参获取需要调用的方法名称和参数，可以调用对应Redis集群中的方法</li></ul><p>抽象工厂搭建完成了，这部分抽象工厂属于从中间件设计中抽取出来的最核心的内容，如果需要在实际的业务中使用，则需要扩充相应的代码，如注入的设计、配置的读取、相关监控和缓存使用开关等。</p></li></ol><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_CacheService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CacheService proxy_EGM = JDKProxyFactory.getProxy(CacheService.class, EGMCacheAdapter.class);<br>        proxy_EGM.set(<span class="hljs-string">&quot;user_name_01&quot;</span>, <span class="hljs-string">&quot;小傅哥&quot;</span>);<br>        String val01 = proxy_EGM.get(<span class="hljs-string">&quot;user_name_01&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;缓存服务 EGM 测试，proxy_EGM.get 测试结果：&#123;&#125;&quot;</span>, val01);<br><br>        CacheService proxy_IIR = JDKProxyFactory.getProxy(CacheService.class, IIRCacheAdapter.class);<br>        proxy_IIR.set(<span class="hljs-string">&quot;user_name_01&quot;</span>, <span class="hljs-string">&quot;小傅哥&quot;</span>);<br>        String val02 = proxy_IIR.get(<span class="hljs-string">&quot;user_name_01&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;缓存服务 IIR 测试，proxy_IIR.get 测试结果：&#123;&#125;&quot;</span>, val02);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">16</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58.471</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.EGM</span> - EGM写入数据 key：user_name_01 val：小傅哥<br><span class="hljs-number">16</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58.473</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.EGM</span> - EGM获取数据 key：user_name_01<br><span class="hljs-number">16</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58.473</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 缓存服务 EGM 测试，proxy_EGM<span class="hljs-selector-class">.get</span> 测试结果：小傅哥<br><span class="hljs-number">16</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58.474</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.IIR</span> - IIR写入数据 key：user_name_01 val：小傅哥<br><span class="hljs-number">16</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58.474</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.IIR</span> - IIR获取数据 key：user_name_01<br><span class="hljs-number">16</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58.474</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 缓存服务 IIR 测试，proxy_IIR<span class="hljs-selector-class">.get</span> 测试结果：小傅哥<br></code></pre></td></tr></table></figure><p>从测试结果来看运行正常，升级完成。这种代码的扩展方式远比硬编码 if…else好得多，既可扩展又易维护。研发人员的技术栈、技术经验会决定最终的执行结果，有时候如果具备丰富的技能，即使在非常紧急的情况下，也可以做出非常完善的技术方案和落地结果。</p><p>在测试方法中提供了两套集群的工厂获取及相应方法的使用。通过代理的方式JDKProxyFactory.getProxy（CacheService.class，IIRCacheAdapter.class）；获取相应的工厂。这里获取的过程相当于从车间中组合出新的工厂。最终在实际的使用中交给Spring进行Bean注入，通过这样的方式升级服务集群，就不需要所有的研发人员硬编码了。即使有任何问题，也可以回退到原有的实现方式里。这种可插拔服务的优点是易于维护和可扩展。</p><blockquote><p>1， “一开始也很好奇为什么CacheService也行，按理说JDK 代理应该是代理实现具体接口的类”：原代码里被代理的接口是CacheService，不是ICacheAdapter。这个案例目的是把单机使用的CacheService接口，用代理的方式，无感地替换成ICacheAdapter的集群方式，所以被代理的接口是CacheService（被替换者），ICacheAdapter的实现类是真正干活的人（顶替者）；<br>2，“单元测试中test_CacheService里面可以把CacheService类替换成ICacheAdapter，照样可以运行”：替换后被代理的接口变成了ICacheAdapter，也就是ICacheAdapter的每个接口方法，都被ICacheAdapter的实现类（getProxy()方法的第二个入参）顶替干活了，实现类去干接口的活当然可以跑通啦。</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>抽象工厂模式要解决的是在一个产品族存在多个不同类型的产品（Redis集群、操作系统）的情况下选择接口的问题。而这种场景在业 务开发中也非常多见，只不过可能有时候没有将它们抽象出来。如果知道在什么场景下可以通过抽象工程优化代码，那么在代码层级结构以及满足业务需求方面，可以得到很好的完成功能实现并提升扩展性和优雅度。设计模式的使用满足了单一职责、开闭原则和解耦等要求。如果说有什么缺点，那就是随着业务的场景功能不断拓展，可能会加大类实现上的复杂度。但随着其他设计方式的引入，以及代理类和自动生成加载的方式，这种设计上的欠缺也可以解决。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="建造者模式介绍"><a href="#建造者模式介绍" class="headerlink" title="建造者模式介绍"></a>建造者模式介绍</h3><p>建造者模式的核心目的是通过使用多个简单对象一步步地构建出一个复杂对象。</p><p>那么，哪里有这样的场景呢？</p><p>例如，《王者荣耀》游戏的初始化界面有道路、树木、野怪和守卫塔等。换一个场景选择其他模式时，同样会建设道路、树木、野怪和守卫塔等，但是它们的摆放位置和大小各有不同。这种初始化游戏元素的场景就可以使用建造者模式。</p><p>这种根据相同的物料、不同的组装方式产生出具体内容，就是建造者模式的最终意图，即将一个复杂的构建与其表示分离，用同样的构建过程可以创建不同的表示。</p><h3 id="装修套餐选配场景"><a href="#装修套餐选配场景" class="headerlink" title="装修套餐选配场景"></a>装修套餐选配场景</h3><p>这里模拟房屋装修公司设计出一些不同风格样式的装修套餐场景，来体现建造者模式的使用方法。</p><p>很多装修公司都会提供一些套餐服务，一般会有：豪华欧式、轻奢田园和现代简约装修服务套餐等。而这些套餐的背后是不同装修材料和设计风格的组合，例如一级顶、二级顶、多乐士涂料、立邦涂料、圣象地板、德尔地板、马可波罗地砖、东鹏地砖等。按照不同的套餐价格，选取不同的品牌进行组合，最终再结合装修面积给出整体报价。</p><p>下面模拟装修公司推出的一些装修服务套餐，按照不同的价格组合品牌，并介绍使用建造者模式实现这一需求。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-8.png" alt></p><p>在模拟的装修材料工程中，提供了如下类：</p><ul><li>ceilling（吊顶材料）包：LevelOneCeiling、LevelTwoCeiling</li><li>coat（涂料材料）包：DuluxCoat、LiBangCoat</li><li>floor（地板材料）包：DerFloor、ShengXiangFloor</li><li>tile（地砖材料）包：DongPengTile、MarcoPoloTile</li></ul><p><strong>装修材料接口：</strong></p><p>装修材料接口提供了基本的方法获取信息，以保证所有不同规格和种类的装修材料都可以按照统一标准被获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 场景；地板、地砖、涂料、吊顶</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">scene</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 品牌</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">brand</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 型号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">model</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单价</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 描述</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">desc</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>吊顶材料（ceiling）</strong></p><ol><li><p><strong>一级顶</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 吊顶</span><br><span class="hljs-comment"> * 品牌；装修公司自带</span><br><span class="hljs-comment"> * 型号：一级顶</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LevelOneCeiling</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;吊顶&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;装修公司自带&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;一级顶&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">260</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;造型只做低一级，只有一个层次的吊顶，一般离顶120-150mm&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>二级顶</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 吊顶</span><br><span class="hljs-comment"> * 品牌；装修公司自带</span><br><span class="hljs-comment"> * 型号：二级顶</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LevelTwoCeiling</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;吊顶&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;装修公司自带&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;二级顶&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">850</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;两个层次的吊顶，二级吊顶高度一般就往下吊20cm，要是层高很高，也可增加每级的厚度&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>涂料材料（coat）</strong></p><ol><li><p><strong>多乐士</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 涂料</span><br><span class="hljs-comment"> * 品牌；多乐士(Dulux)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DuluxCoat</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;涂料&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;多乐士(Dulux)&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二代&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">719</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;多乐士是阿克苏诺贝尔旗下的著名建筑装饰油漆品牌，产品畅销于全球100个国家，每年全球有5000万户家庭使用多乐士油漆。&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>立邦</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 涂料</span><br><span class="hljs-comment"> * 品牌；立邦</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiBangCoat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;涂料&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;立邦&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;默认级别&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">650</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;立邦始终以开发绿色产品、注重高科技、高品质为目标，以技术力量不断推进科研和开发，满足消费者需求。&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>地板材料（floor）</strong></p><ol><li><p><strong>德尔</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 地板</span><br><span class="hljs-comment"> * 品牌；德尔(Der)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerFloor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;地板&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;德尔(Der)&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A+&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">119</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DER德尔集团是全球领先的专业木地板制造商，北京2008年奥运会家装和公装地板供应商&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>圣象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 地板</span><br><span class="hljs-comment"> * 品牌：圣象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShengXiangFloor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;地板&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;圣象&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;一级&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">318</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;圣象地板是中国地板行业著名品牌。圣象地板拥有中国驰名商标、中国名牌、国家免检、中国环境标志认证等多项荣誉。&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>地砖材料（tile）</strong></p><ol><li><p><strong>东鹏</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 地砖</span><br><span class="hljs-comment"> * 品牌：东鹏瓷砖</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DongPengTile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;地砖&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;东鹏瓷砖&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;10001&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">102</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;东鹏瓷砖以品质铸就品牌，科技推动品牌，口碑传播品牌为宗旨，2014年品牌价值132.35亿元，位列建陶行业榜首。&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>马可波罗</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 地砖</span><br><span class="hljs-comment"> * 品牌；马可波罗(MARCO POLO)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MarcoPoloTile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Matter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">scene</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;地砖&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">brand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;马可波罗(MARCO POLO)&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">model</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;缺省&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">140</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;“马可波罗”品牌诞生于1996年，作为国内最早品牌化的建陶品牌，以“文化陶瓷”占领市场，享有“仿古砖至尊”的美誉。&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>以上是本次装修公司所提供的装修配置单，接下来会通过不同的物料组合出不同的服务套餐。</p><h3 id="违背设计模式实现-2"><a href="#违背设计模式实现-2" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>没有if…else解决不了的逻辑，不行就再加一行！</p><p>这里先使用不加设计的方式实现功能，之后再通过设计模式优化完善。一般使用这种实现方式的代码都会集中在一个类中，里面包含大量的if…else逻辑。既不具有复杂的代码结构，也不具有良好的扩展性。如果应对非常简单的业务，还是可以使用的。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-9.png" alt></p><p>对于装修包的类DecorationPackageController，按照一个类里有多个if…else代码的方式实现。</p><p><strong>if…else实现需求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecorationPackageController</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMatterList</span><span class="hljs-params">(BigDecimal area, Integer level)</span> </span>&#123;<br><br>        List&lt;Matter&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Matter&gt;(); <span class="hljs-comment">// 装修清单</span><br>        BigDecimal price = BigDecimal.ZERO;          <span class="hljs-comment">// 装修价格</span><br><br>        <span class="hljs-comment">// 豪华欧式</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == level) &#123;<br><br>            LevelTwoCeiling levelTwoCeiling = <span class="hljs-keyword">new</span> LevelTwoCeiling(); <span class="hljs-comment">// 吊顶，二级顶</span><br>            DuluxCoat duluxCoat = <span class="hljs-keyword">new</span> DuluxCoat();                   <span class="hljs-comment">// 涂料，多乐士</span><br>            ShengXiangFloor shengXiangFloor = <span class="hljs-keyword">new</span> ShengXiangFloor(); <span class="hljs-comment">// 地板，圣象</span><br><br>            list.add(levelTwoCeiling);<br>            list.add(duluxCoat);<br>            list.add(shengXiangFloor);<br><br>            price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.2&quot;</span>)).multiply(levelTwoCeiling.price()));<br>            price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1.4&quot;</span>)).multiply(duluxCoat.price()));<br>            price = price.add(area.multiply(shengXiangFloor.price()));<br><br>        &#125;<br><br>        <span class="hljs-comment">// 轻奢田园</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == level) &#123;<br><br>            LevelTwoCeiling levelTwoCeiling = <span class="hljs-keyword">new</span> LevelTwoCeiling(); <span class="hljs-comment">// 吊顶，二级顶</span><br>            LiBangCoat liBangCoat = <span class="hljs-keyword">new</span> LiBangCoat();                <span class="hljs-comment">// 涂料，立邦</span><br>            MarcoPoloTile marcoPoloTile = <span class="hljs-keyword">new</span> MarcoPoloTile();       <span class="hljs-comment">// 地砖，马可波罗</span><br><br>            list.add(levelTwoCeiling);<br>            list.add(liBangCoat);<br>            list.add(marcoPoloTile);<br><br>            price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.2&quot;</span>)).multiply(levelTwoCeiling.price()));<br>            price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1.4&quot;</span>)).multiply(liBangCoat.price()));<br>            price = price.add(area.multiply(marcoPoloTile.price()));<br><br>        &#125;<br><br>        <span class="hljs-comment">// 现代简约</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == level) &#123;<br><br>            LevelOneCeiling levelOneCeiling = <span class="hljs-keyword">new</span> LevelOneCeiling();  <span class="hljs-comment">// 吊顶，一级顶</span><br>            LiBangCoat liBangCoat = <span class="hljs-keyword">new</span> LiBangCoat();                 <span class="hljs-comment">// 涂料，立邦</span><br>            DongPengTile dongPengTile = <span class="hljs-keyword">new</span> DongPengTile();           <span class="hljs-comment">// 地砖，东鹏</span><br><br>            list.add(levelOneCeiling);<br>            list.add(liBangCoat);<br>            list.add(dongPengTile);<br><br>            price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.2&quot;</span>)).multiply(levelOneCeiling.price()));<br>            price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1.4&quot;</span>)).multiply(liBangCoat.price()));<br>            price = price.add(area.multiply(dongPengTile.price()));<br>        &#125;<br><br>        StringBuilder detail = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;\r\n-------------------------------------------------------\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;装修清单&quot;</span> + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;套餐等级：&quot;</span> + level + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;套餐价格：&quot;</span> + price.setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP) + <span class="hljs-string">&quot; 元\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;房屋面积：&quot;</span> + area.doubleValue() + <span class="hljs-string">&quot; 平米\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;材料清单：\r\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (Matter matter: list) &#123;<br>            detail.append(matter.scene()).append(<span class="hljs-string">&quot;：&quot;</span>).append(matter.brand()).append(<span class="hljs-string">&quot;、&quot;</span>).append(matter.model()).append(<span class="hljs-string">&quot;、平米价格：&quot;</span>).append(matter.price()).append(<span class="hljs-string">&quot; 元。\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> detail.toString();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先，这段代码要解决的问题是接收入参：房屋面积（area）、装修等级（level），根据不同类型的装修等级选择不同的材料。其次，在实现过程中可以看到每一段if代码块中包含着不同的材料（吊顶为二级顶；涂料为立邦；地砖为马可波罗），最终生成装修清单和装修价格。最后，提供获取装修详细信息的方法，返回给调用方，便于客户了解装修清单。</p><p><strong>测试验证</strong></p><p>接下来，通过JUnit单元测试的方式验证接口服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_DecorationPackageController</span><span class="hljs-params">()</span></span>&#123;<br>        DecorationPackageController decoration = <span class="hljs-keyword">new</span> DecorationPackageController();<br><br>        <span class="hljs-comment">// 豪华欧式</span><br>        System.out.println(decoration.getMatterList(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;132.52&quot;</span>),<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">// 轻奢田园</span><br>        System.out.println(decoration.getMatterList(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;98.25&quot;</span>),<span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 现代简约</span><br>        System.out.println(decoration.getMatterList(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;85.43&quot;</span>),<span class="hljs-number">3</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">-------------------------------------------------------</span><br><span class="hljs-code">装修清单</span><br><span class="hljs-code">套餐等级：1</span><br><span class="hljs-code">套餐价格：198064.39 元</span><br><span class="hljs-code">房屋面积：132.52 平米</span><br><span class="hljs-code">材料清单：</span><br><span class="hljs-code">吊顶：装修公司自带、二级顶、平米价格：850 元。</span><br><span class="hljs-code">涂料：多乐士(Dulux)、第二代、平米价格：719 元。</span><br><span class="hljs-code">地板：圣象、一级、平米价格：318 元。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">-------------------------------------------------------</span><br>装修清单<br>套餐等级：2<br>套餐价格：119865.00 元<br>房屋面积：98.25 平米<br>材料清单：<br>吊顶：装修公司自带、二级顶、平米价格：850 元。<br>涂料：立邦、默认级别、平米价格：650 元。<br>地砖：马可波罗(MARCO POLO)、缺省、平米价格：140 元。<br><br><br><span class="hljs-code">-------------------------------------------------------</span><br><span class="hljs-code">装修清单</span><br><span class="hljs-code">套餐等级：3</span><br><span class="hljs-code">套餐价格：90897.52 元</span><br><span class="hljs-code">房屋面积：85.43 平米</span><br><span class="hljs-code">材料清单：</span><br><span class="hljs-code">吊顶：装修公司自带、一级顶、平米价格：260 元。</span><br><span class="hljs-code">涂料：立邦、默认级别、平米价格：650 元。</span><br><span class="hljs-code">地砖：东鹏瓷砖、10001、平米价格：102 元。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">进程已结束,退出代码0</span><br></code></pre></td></tr></table></figure><p>看到输出的结果，已经有装修公司提供的报价单的感觉了。虽然以上这段使用if…else方式实现的代码可以满足些许功能，但随着公司业务的快速发展，会针对不同的户型提供更多的套餐。这段实现代码将迅速扩增到几千行，甚至不断地修改，最终难以维护。</p><h3 id="建造者模式重构代码"><a href="#建造者模式重构代码" class="headerlink" title="建造者模式重构代码"></a>建造者模式重构代码</h3><p>在软件系统开发中，有时会面临一个复杂对象的创建工作，其通常由各个部分的子对象用一定过程构建出来，随着需求的迭代，这个复杂对象的各个部分经常面临重大的变化，但是将它们组合在一起的过程却相对稳定，这种场景就适合用建造者模式。</p><p>这里会把构建的过程交给创建者类，而创建者通过使用构建工具包构建出不同的装修套餐。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-10.png" alt></p><p>建造者模式代码工程有三个核心类，这三个核心类是建造者模式的具体实现。与使用if…else判断方式实现逻辑相比，它额外新增了两个类，具体功能如下：</p><ul><li>Builder：建造者类具体的各种组装，都由此类实现</li><li>DecorationPackageMenu：是IMenu接口的实现类，主要承载建造过程中的填充器，相当于一套承载物料和创建者中间衔接的内容</li></ul><p>也可以从装修材料参考图的视角看待这类工程，更便于理解。</p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-11.png" alt></p><p>接下来分别介绍几个类的功能的具体实现方式。</p><p><strong>定义装修包接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMenu</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 吊顶</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">IMenu <span class="hljs-title">appendCeiling</span><span class="hljs-params">(Matter matter)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 涂料</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">IMenu <span class="hljs-title">appendCoat</span><span class="hljs-params">(Matter matter)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 地板</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">IMenu <span class="hljs-title">appendFloor</span><span class="hljs-params">(Matter matter)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 地砖</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">IMenu <span class="hljs-title">appendTile</span><span class="hljs-params">(Matter matter)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 明细</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getDetail</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接口类定义了填充吊顶、涂料、地板、地砖各种材料的方法，以及最终提供获取全部明细的方法。</p><p><strong>实现装修包接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecorationPackageMenu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMenu</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Matter&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Matter&gt;();  <span class="hljs-comment">// 装修清单</span><br>    <span class="hljs-keyword">private</span> BigDecimal price = BigDecimal.ZERO;      <span class="hljs-comment">// 装修价格</span><br><br>    <span class="hljs-keyword">private</span> BigDecimal area;  <span class="hljs-comment">// 面积</span><br>    <span class="hljs-keyword">private</span> String grade;     <span class="hljs-comment">// 装修等级；豪华欧式、轻奢田园、现代简约</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DecorationPackageMenu</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecorationPackageMenu</span><span class="hljs-params">(Double area, String grade)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.area = <span class="hljs-keyword">new</span> BigDecimal(area);<br>        <span class="hljs-keyword">this</span>.grade = grade;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMenu <span class="hljs-title">appendCeiling</span><span class="hljs-params">(Matter matter)</span> </span>&#123;<br>        list.add(matter);<br>        price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.2&quot;</span>)).multiply(matter.price()));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMenu <span class="hljs-title">appendCoat</span><span class="hljs-params">(Matter matter)</span> </span>&#123;<br>        list.add(matter);<br>        price = price.add(area.multiply(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1.4&quot;</span>)).multiply(matter.price()));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMenu <span class="hljs-title">appendFloor</span><span class="hljs-params">(Matter matter)</span> </span>&#123;<br>        list.add(matter);<br>        price = price.add(area.multiply(matter.price()));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMenu <span class="hljs-title">appendTile</span><span class="hljs-params">(Matter matter)</span> </span>&#123;<br>        list.add(matter);<br>        price = price.add(area.multiply(matter.price()));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetail</span><span class="hljs-params">()</span> </span>&#123;<br><br>        StringBuilder detail = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;\r\n-------------------------------------------------------\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;装修清单&quot;</span> + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;套餐等级：&quot;</span> + grade + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;套餐价格：&quot;</span> + price.setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP) + <span class="hljs-string">&quot; 元\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;房屋面积：&quot;</span> + area.doubleValue() + <span class="hljs-string">&quot; 平米\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;材料清单：\r\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (Matter matter: list) &#123;<br>            detail.append(matter.scene()).append(<span class="hljs-string">&quot;：&quot;</span>).append(matter.brand()).append(<span class="hljs-string">&quot;、&quot;</span>).append(matter.model()).append(<span class="hljs-string">&quot;、平米价格：&quot;</span>).append(matter.price()).append(<span class="hljs-string">&quot; 元。\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> detail.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在装修包的实现中，每一种方法都返回了this对象本身，可以非常方便地用于连续填充各种物料。同时，在填充时也会根据物料计算相应面积的报价，吊顶和涂料按照面积乘以单价计算。最后，同样提供了统一的获取装修清单的明细方法。</p><p><strong>建造者类创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMenu <span class="hljs-title">levelOne</span><span class="hljs-params">(Double area)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorationPackageMenu(area, <span class="hljs-string">&quot;豪华欧式&quot;</span>)<br>                .appendCeiling(<span class="hljs-keyword">new</span> LevelTwoCeiling())    <span class="hljs-comment">// 吊顶，二级顶</span><br>                .appendCoat(<span class="hljs-keyword">new</span> DuluxCoat())             <span class="hljs-comment">// 涂料，多乐士</span><br>                .appendFloor(<span class="hljs-keyword">new</span> ShengXiangFloor());     <span class="hljs-comment">// 地板，圣象</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMenu <span class="hljs-title">levelTwo</span><span class="hljs-params">(Double area)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorationPackageMenu(area, <span class="hljs-string">&quot;轻奢田园&quot;</span>)<br>                .appendCeiling(<span class="hljs-keyword">new</span> LevelTwoCeiling())   <span class="hljs-comment">// 吊顶，二级顶</span><br>                .appendCoat(<span class="hljs-keyword">new</span> LiBangCoat())           <span class="hljs-comment">// 涂料，立邦</span><br>                .appendTile(<span class="hljs-keyword">new</span> MarcoPoloTile());       <span class="hljs-comment">// 地砖，马可波罗</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMenu <span class="hljs-title">levelThree</span><span class="hljs-params">(Double area)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorationPackageMenu(area, <span class="hljs-string">&quot;现代简约&quot;</span>)<br>                .appendCeiling(<span class="hljs-keyword">new</span> LevelOneCeiling())   <span class="hljs-comment">// 吊顶，一级顶</span><br>                .appendCoat(<span class="hljs-keyword">new</span> LiBangCoat())           <span class="hljs-comment">// 涂料，立邦</span><br>                .appendTile(<span class="hljs-keyword">new</span> DongPengTile());        <span class="hljs-comment">// 地砖，东鹏</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在建造者的使用中就已经非常容易了。统一的建造方式通过不同物料填充出不同的装修风格：豪华欧式、轻奢田园和现代简约。如果公司扩展业务，也可以将这部分内容配置到数据库中自动生成，但整体过程仍然可以使用建造者模式的思想进行搭建。</p><p><strong>测试验证</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_Builder</span><span class="hljs-params">()</span></span>&#123;<br><br>        Builder builder = <span class="hljs-keyword">new</span> Builder();<br><br>        <span class="hljs-comment">// 豪华欧式</span><br>        System.out.println(builder.levelOne(<span class="hljs-number">132.52D</span>).getDetail());<br><br>        <span class="hljs-comment">// 轻奢田园</span><br>        System.out.println(builder.levelTwo(<span class="hljs-number">98.25D</span>).getDetail());<br><br>        <span class="hljs-comment">// 现代简约</span><br>        System.out.println(builder.levelThree(<span class="hljs-number">85.43D</span>).getDetail());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在单元测试中，使用建造者模式分别创建出三种装修套餐的价格，获取详情信息并进行输出：</p><ul><li>levelOne、levelTwo、levelThree 对应三种装修风格：豪华欧式、轻奢田园和现代简约</li><li>入参的信息是房屋面积，最终获取装修报价单。实际的业务场景会更复杂，这里的案例主要展示最核心的逻辑</li></ul><p>运行结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">-------------------------------------------------------</span><br><span class="hljs-code">装修清单</span><br><span class="hljs-code">套餐等级：豪华欧式</span><br><span class="hljs-code">套餐价格：198064.39 元</span><br><span class="hljs-code">房屋面积：132.52 平米</span><br><span class="hljs-code">材料清单：</span><br><span class="hljs-code">吊顶：装修公司自带、二级顶、平米价格：850 元。</span><br><span class="hljs-code">涂料：多乐士(Dulux)、第二代、平米价格：719 元。</span><br><span class="hljs-code">地板：圣象、一级、平米价格：318 元。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">-------------------------------------------------------</span><br>装修清单<br>套餐等级：轻奢田园<br>套餐价格：119865.00 元<br>房屋面积：98.25 平米<br>材料清单：<br>吊顶：装修公司自带、二级顶、平米价格：850 元。<br>涂料：立邦、默认级别、平米价格：650 元。<br>地砖：马可波罗(MARCO POLO)、缺省、平米价格：140 元。<br><br><br><span class="hljs-code">-------------------------------------------------------</span><br><span class="hljs-code">装修清单</span><br><span class="hljs-code">套餐等级：现代简约</span><br><span class="hljs-code">套餐价格：90897.52 元</span><br><span class="hljs-code">房屋面积：85.43 平米</span><br><span class="hljs-code">材料清单：</span><br><span class="hljs-code">吊顶：装修公司自带、一级顶、平米价格：260 元。</span><br><span class="hljs-code">涂料：立邦、默认级别、平米价格：650 元。</span><br><span class="hljs-code">地砖：东鹏瓷砖、10001、平米价格：102 元。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">进程已结束,退出代码0</span><br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通过上面对建造者模式的使用，可以总结出选择该设计模式的条件：当一些基本材料不变，而其组合经常变化时。此设计模式满足了单一职责原则及可复用的技术，建造者独立、易扩展、便于控制细节风险。出现特别多的物料及组合时，类的不断扩展也会造成难以维护的问题。但这种设计模式可以把重复的内容抽象到数据库中，按照需要配置，减少大量的重复代码。虽然设计模式能带给我们一些设计思想，但在平时的开发中如何清晰地提炼出符合此思路的建造模块是比较困难的。需要经过一些练习，不断承接更多的项目来获得经验。有时代码写得好，往往是通过复杂的业务、频繁的变化和不断的挑战，逐步积累而来的。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="原型模式介绍"><a href="#原型模式介绍" class="headerlink" title="原型模式介绍"></a>原型模式介绍</h3><p>原型模式主要解决的是创建重复对象的问题，而这部分对象内容 本身比较复杂，从数据库或者RPC接口中获取相关对象数据的耗时较 长，因此需要采用复制的方式节省时间。</p><p>这种场景也经常出现在我们身边，只不过很少有人提炼出这种设计思想，并运用到自己的系统开发中，就像：</p><ul><li>经常使用Ctrl+C、Ctrl+V组合键复制和粘贴代码</li><li>Java多数类中提供的API方法Object clone()</li><li>细胞的有丝分裂</li></ul><p>类似的场景并不少，但在平时的代码开发中并不容易找到这样的设计模式，甚至有时即使遇到了也会忽略。在没有阅读下文之前，可以思考有哪些场景可以用到这种设计模式。</p><h3 id="试卷题目乱序场景"><a href="#试卷题目乱序场景" class="headerlink" title="试卷题目乱序场景"></a>试卷题目乱序场景</h3><p>每个人都经历过考试，大部分情况都是在纸质的试卷上答题，随着互联网的兴起，也有一些考试改为上机考试。</p><p>从时间效率和成本上看，上机考试可以大大降低判卷的人工成本，提高判分效率。上机考试还可以提高考试的公平性，将同样的题目混排，可以更好地降低抄袭的可能性，在这种情况下对应的答案也是混排的。同样的试卷题目，如果是人工判卷，很难实现题目混排，但放在计算机上，无论是生成试卷还是判卷都能轻而易举地实现。下面就来实现这样的功能：同样一张试卷、同样的题目、同样的答案， 把题目和答案全部混排。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-12.png" alt></p><p>在模拟工程中，提供了试卷中两类题目：选择题类（ChoiceQuestion）和问答题类（AnswerQuestion）。如果是实际的业务开发，还会有更多的考试题目类型，读者在练习时可以自行添加。</p><p><strong>选择题类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChoiceQuestion</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;                 <span class="hljs-comment">// 题目</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; option;  <span class="hljs-comment">// 选项；A、B、C、D</span><br>    <span class="hljs-keyword">private</span> String key;                  <span class="hljs-comment">// 答案；B</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChoiceQuestion</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChoiceQuestion</span><span class="hljs-params">(String name, Map&lt;String, String&gt; option, String key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.option = option;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>    <br><span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在选择题类（ChoiceQuestion）中，提供了题目名称、题目选项和题目答案三种属性。</p><p><strong>问答题类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnswerQuestion</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// 问题</span><br>    <span class="hljs-keyword">private</span> String key;   <span class="hljs-comment">// 答案</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnswerQuestion</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnswerQuestion</span><span class="hljs-params">(String name, String key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>    <br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在问答题类（AnswerQuestion）中，提供了问题和答案两种属性。</p><h3 id="违背设计模式实现-3"><a href="#违背设计模式实现-3" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>按照通常的需求迭代过程，往往最开始都是非常简单的，也是非常容易实现的。需求最初的模样，只是给每位考生创建出一张试卷即可，对于这样简单的需求，如果不仔细思考，可能会把所有代码写到 一个类里。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-13.png" alt></p><p>这个工程的结构只有一个用于生成试卷的控制类QuestionBankController，接下来看这样的类是如何实现的。</p><p><strong>所有需求都写到一个类里：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuestionBankController</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createPaper</span><span class="hljs-params">(String candidate, String number)</span> </span>&#123;<br><br>        List&lt;ChoiceQuestion&gt; choiceQuestionList = <span class="hljs-keyword">new</span> ArrayList&lt;ChoiceQuestion&gt;();<br><br>        choiceQuestionList.add(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;JAVA所定义的版本中不包括&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;JAVA2 EE&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;JAVA2 Card&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;JAVA2 ME&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;JAVA2 HE&quot;</span>);<br>            put(<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;JAVA2 SE&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;D&quot;</span>));<br><br>        choiceQuestionList.add(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;下列说法正确的是&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;JAVA程序的main方法必须写在类里面&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;JAVA程序中可以有多个main方法&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;JAVA程序中类名必须与文件名一样&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;JAVA程序的main方法中如果只有一条语句，可以不用&#123;&#125;(大括号)括起来&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;A&quot;</span>));<br>        choiceQuestionList.add(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;变量命名规范说法正确的是&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;变量由字母、下划线、数字、$符号随意组成；&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;变量不能以数字作为开头；&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A和a在java中是同一个变量；&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;不同类型的变量，可以起相同的名字；&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;B&quot;</span>));<br>        choiceQuestionList.add(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;以下()不是合法的标识符&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;STRING&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;x3x;&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;void&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;de$f&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;C&quot;</span>));<br>        choiceQuestionList.add(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;表达式(11+3*8)/4%3的值是&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;31&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;D&quot;</span>));<br><br>        List&lt;AnswerQuestion&gt; answerQuestionList = <span class="hljs-keyword">new</span> ArrayList&lt;AnswerQuestion&gt;();<br>        answerQuestionList.add(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;小红马和小黑马生的小马几条腿&quot;</span>, <span class="hljs-string">&quot;4条腿&quot;</span>));<br>        answerQuestionList.add(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;铁棒打头疼还是木棒打头疼&quot;</span>, <span class="hljs-string">&quot;头最疼&quot;</span>));<br>        answerQuestionList.add(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;什么床不能睡觉&quot;</span>, <span class="hljs-string">&quot;牙床&quot;</span>));<br>        answerQuestionList.add(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;为什么好马不吃回头草&quot;</span>, <span class="hljs-string">&quot;后面的草没了&quot;</span>));<br><br>        <span class="hljs-comment">// 输出结果</span><br>        StringBuilder detail = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;考生：&quot;</span> + candidate + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;考号：&quot;</span> + number + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;--------------------------------------------\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;一、选择题&quot;</span> + <span class="hljs-string">&quot;\r\n\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; choiceQuestionList.size(); idx++) &#123;<br>            detail.append(<span class="hljs-string">&quot;第&quot;</span>).append(idx + <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;题：&quot;</span>).append(choiceQuestionList.get(idx).getName()).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            Map&lt;String, String&gt; option = choiceQuestionList.get(idx).getOption();<br>            <span class="hljs-keyword">for</span> (String key : option.keySet()) &#123;<br>                detail.append(key).append(<span class="hljs-string">&quot;：&quot;</span>).append(option.get(key)).append(<span class="hljs-string">&quot;\r\n&quot;</span>);;<br>            &#125;<br>            detail.append(<span class="hljs-string">&quot;答案：&quot;</span>).append(choiceQuestionList.get(idx).getKey()).append(<span class="hljs-string">&quot;\r\n\n&quot;</span>);<br>        &#125;<br><br>        detail.append(<span class="hljs-string">&quot;二、问答题&quot;</span> + <span class="hljs-string">&quot;\r\n\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; answerQuestionList.size(); idx++) &#123;<br>            detail.append(<span class="hljs-string">&quot;第&quot;</span>).append(idx + <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;题：&quot;</span>).append(answerQuestionList.get(idx).getName()).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            detail.append(<span class="hljs-string">&quot;答案：&quot;</span>).append(answerQuestionList.get(idx).getKey()).append(<span class="hljs-string">&quot;\r\n\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> detail.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上的代码主要包括三部分内容：将选择题和问答题创建到集合中，定义详情字符串包装结果，返回结果内容。单从代码阅读角度来看，这样的代码并不复杂，且更易于理解。因为它的编程方式不面向对象，只面向程序过程，业务逻辑需要什么就直接写什么。不考虑扩展性，能运行即可。但这段代码没有实现题目和答案乱序的功能，最终所有人的试卷题目的顺序都是一样的。如果需要增加混排题目功能，则代码实现就会非常混乱。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_QuestionBankController</span><span class="hljs-params">()</span> </span>&#123;<br>        QuestionBankController questionBankController = <span class="hljs-keyword">new</span> QuestionBankController();<br>        System.out.println(questionBankController.createPaper(<span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;1000001921032&quot;</span>));<br>        System.out.println(questionBankController.createPaper(<span class="hljs-string">&quot;豆豆&quot;</span>, <span class="hljs-string">&quot;1000001921051&quot;</span>));<br>        System.out.println(questionBankController.createPaper(<span class="hljs-string">&quot;大宝&quot;</span>, <span class="hljs-string">&quot;1000001921987&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在单元测试中，调用了三次创建试卷的方法questionBankController.createPaper，给三位考生创建了三张试卷。</p><p>运行结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">考生：花花<br>考号：<span class="hljs-number">1000001921032</span><br><span class="hljs-operator">--------------------------------------------</span><br>一、选择题<br><br>第<span class="hljs-number">1</span>题：<span class="hljs-variable">JAVA</span>所定义的版本中不包括<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">EE</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">Card</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">ME</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">HE</span><br><span class="hljs-built_in">E</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">SE</span><br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">2</span>题：下列说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法必须写在类里面<br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA</span>程序中可以有多个<span class="hljs-variable">main</span>方法<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA</span>程序中类名必须与文件名一样<br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法中如果只有一条语句，可以不用<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>大括号<span class="hljs-punctuation">)</span>括起来<br>答案：<span class="hljs-variable">A</span><br><br>第<span class="hljs-number">3</span>题：变量命名规范说法正确的是<br><span class="hljs-variable">A</span>：变量由字母、下划线、数字、<span class="hljs-variable">$</span>符号随意组成；<br><span class="hljs-variable">B</span>：变量不能以数字作为开头；<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">A</span>和<span class="hljs-variable">a</span>在<span class="hljs-variable">java</span>中是同一个变量；<br><span class="hljs-built_in">D</span>：不同类型的变量，可以起相同的名字；<br>答案：<span class="hljs-variable">B</span><br><br>第<span class="hljs-number">4</span>题：以下<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>不是合法的标识符<br><span class="hljs-variable">A</span>：<span class="hljs-variable">STRING</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">x3x</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">void</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">de$f</span><br>答案：<span class="hljs-built_in">C</span><br><br>第<span class="hljs-number">5</span>题：表达式<span class="hljs-punctuation">(</span><span class="hljs-number">11</span><span class="hljs-operator">+</span><span class="hljs-number">3</span><span class="hljs-operator">*</span><span class="hljs-number">8</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">4</span><span class="hljs-operator">%</span><span class="hljs-number">3</span>的值是<br><span class="hljs-variable">A</span>：<span class="hljs-number">31</span><br><span class="hljs-variable">B</span>：<span class="hljs-number">0</span><br><span class="hljs-built_in">C</span>：<span class="hljs-number">1</span><br><span class="hljs-built_in">D</span>：<span class="hljs-number">2</span><br>答案：<span class="hljs-built_in">D</span><br><br>二、问答题<br><br>第<span class="hljs-number">1</span>题：小红马和小黑马生的小马几条腿<br>答案：<span class="hljs-number">4</span>条腿<br><br>第<span class="hljs-number">2</span>题：铁棒打头疼还是木棒打头疼<br>答案：头最疼<br><br>第<span class="hljs-number">3</span>题：什么床不能睡觉<br>答案：牙床<br><br>第<span class="hljs-number">4</span>题：为什么好马不吃回头草<br>答案：后面的草没了<br><br><br>考生：豆豆<br>考号：<span class="hljs-number">1000001921051</span><br><span class="hljs-operator">--------------------------------------------</span><br>一、选择题<br><br>第<span class="hljs-number">1</span>题：<span class="hljs-variable">JAVA</span>所定义的版本中不包括<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">EE</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">Card</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">ME</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">HE</span><br><span class="hljs-built_in">E</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">SE</span><br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">2</span>题：下列说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法必须写在类里面<br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA</span>程序中可以有多个<span class="hljs-variable">main</span>方法<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA</span>程序中类名必须与文件名一样<br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法中如果只有一条语句，可以不用<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>大括号<span class="hljs-punctuation">)</span>括起来<br>答案：<span class="hljs-variable">A</span><br><br>第<span class="hljs-number">3</span>题：变量命名规范说法正确的是<br><span class="hljs-variable">A</span>：变量由字母、下划线、数字、<span class="hljs-variable">$</span>符号随意组成；<br><span class="hljs-variable">B</span>：变量不能以数字作为开头；<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">A</span>和<span class="hljs-variable">a</span>在<span class="hljs-variable">java</span>中是同一个变量；<br><span class="hljs-built_in">D</span>：不同类型的变量，可以起相同的名字；<br>答案：<span class="hljs-variable">B</span><br><br>第<span class="hljs-number">4</span>题：以下<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>不是合法的标识符<br><span class="hljs-variable">A</span>：<span class="hljs-variable">STRING</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">x3x</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">void</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">de$f</span><br>答案：<span class="hljs-built_in">C</span><br><br>第<span class="hljs-number">5</span>题：表达式<span class="hljs-punctuation">(</span><span class="hljs-number">11</span><span class="hljs-operator">+</span><span class="hljs-number">3</span><span class="hljs-operator">*</span><span class="hljs-number">8</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">4</span><span class="hljs-operator">%</span><span class="hljs-number">3</span>的值是<br><span class="hljs-variable">A</span>：<span class="hljs-number">31</span><br><span class="hljs-variable">B</span>：<span class="hljs-number">0</span><br><span class="hljs-built_in">C</span>：<span class="hljs-number">1</span><br><span class="hljs-built_in">D</span>：<span class="hljs-number">2</span><br>答案：<span class="hljs-built_in">D</span><br><br>二、问答题<br><br>第<span class="hljs-number">1</span>题：小红马和小黑马生的小马几条腿<br>答案：<span class="hljs-number">4</span>条腿<br><br>第<span class="hljs-number">2</span>题：铁棒打头疼还是木棒打头疼<br>答案：头最疼<br><br>第<span class="hljs-number">3</span>题：什么床不能睡觉<br>答案：牙床<br><br>第<span class="hljs-number">4</span>题：为什么好马不吃回头草<br>答案：后面的草没了<br><br><br>考生：大宝<br>考号：<span class="hljs-number">1000001921987</span><br><span class="hljs-operator">--------------------------------------------</span><br>一、选择题<br><br>第<span class="hljs-number">1</span>题：<span class="hljs-variable">JAVA</span>所定义的版本中不包括<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">EE</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">Card</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">ME</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">HE</span><br><span class="hljs-built_in">E</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">SE</span><br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">2</span>题：下列说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法必须写在类里面<br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA</span>程序中可以有多个<span class="hljs-variable">main</span>方法<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA</span>程序中类名必须与文件名一样<br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法中如果只有一条语句，可以不用<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>大括号<span class="hljs-punctuation">)</span>括起来<br>答案：<span class="hljs-variable">A</span><br><br>第<span class="hljs-number">3</span>题：变量命名规范说法正确的是<br><span class="hljs-variable">A</span>：变量由字母、下划线、数字、<span class="hljs-variable">$</span>符号随意组成；<br><span class="hljs-variable">B</span>：变量不能以数字作为开头；<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">A</span>和<span class="hljs-variable">a</span>在<span class="hljs-variable">java</span>中是同一个变量；<br><span class="hljs-built_in">D</span>：不同类型的变量，可以起相同的名字；<br>答案：<span class="hljs-variable">B</span><br><br>第<span class="hljs-number">4</span>题：以下<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>不是合法的标识符<br><span class="hljs-variable">A</span>：<span class="hljs-variable">STRING</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">x3x</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">void</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">de$f</span><br>答案：<span class="hljs-built_in">C</span><br><br>第<span class="hljs-number">5</span>题：表达式<span class="hljs-punctuation">(</span><span class="hljs-number">11</span><span class="hljs-operator">+</span><span class="hljs-number">3</span><span class="hljs-operator">*</span><span class="hljs-number">8</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">4</span><span class="hljs-operator">%</span><span class="hljs-number">3</span>的值是<br><span class="hljs-variable">A</span>：<span class="hljs-number">31</span><br><span class="hljs-variable">B</span>：<span class="hljs-number">0</span><br><span class="hljs-built_in">C</span>：<span class="hljs-number">1</span><br><span class="hljs-built_in">D</span>：<span class="hljs-number">2</span><br>答案：<span class="hljs-built_in">D</span><br><br>二、问答题<br><br>第<span class="hljs-number">1</span>题：小红马和小黑马生的小马几条腿<br>答案：<span class="hljs-number">4</span>条腿<br><br>第<span class="hljs-number">2</span>题：铁棒打头疼还是木棒打头疼<br>答案：头最疼<br><br>第<span class="hljs-number">3</span>题：什么床不能睡觉<br>答案：牙床<br><br>第<span class="hljs-number">4</span>题：为什么好马不吃回头草<br>答案：后面的草没了<br><br><br><br>进程已结束<span class="hljs-operator">,</span>退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>以上是花花、豆豆和大宝三位考生的试卷：每个人的试卷内容是一样的，三个人的题目及答案顺序也一样，没有达到混排的要求。而且以上这样的代码很难扩展，随着题目的不断增加及乱序功能的补充，都会让这段代码变得越来越混乱。另外，这三张试卷本身题目一致，但在程序的实现方面，每次都需要创建题目信息，这相当于反复从数据库或者远程RPC接口中获取数据，会浪费服务资源。</p><h3 id="原型模式重构代码"><a href="#原型模式重构代码" class="headerlink" title="原型模式重构代码"></a>原型模式重构代码</h3><p>原型模式主要解决的问题是创建大量的重复对象，而这里模拟的场景同样是需要给不同的考生创建相同的试卷，但在创建过程中，这些试卷的题目不应该每次都从数据库或者远程 RPC 接口中获取。这些操作都是非常耗时的，而且随着创建对象的增多，将严重降低创建效率。</p><p>另外，在解决获取相同试卷题目的问题后，还需要将试卷的题目与答案混排。而这种混排的过程就可以使用原型模式。在原型模式中，需要的重要技术手段是复制，而在需要用到复制的类中需要实现implements Cloneable接口。</p><p><strong>工程结构：</strong></p><p><img src="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-14.png" alt></p><p>重构后的整个工程结构并不复杂，主要包括如下内容：</p><ul><li>题目类ChoiceQuestion、AnswerQuestion被用在题库创建中</li><li>针对每一张试卷，都会复制。复制完成后，将试卷的题目及相应的答案混排。这里提供了工具包TopicRandomUtil</li><li>核心的题库类QuestionBank主要负责将各个题目进行组装，最终输出试卷</li></ul><p><strong>题目混排工具包：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopicRandomUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 乱序Map元素，记录对应答案key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> option 题目</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    答案</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Topic 乱序后 &#123;A=c., B=d., C=a., D=b.&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> Topic <span class="hljs-title">random</span><span class="hljs-params">(Map&lt;String, String&gt; option, String key)</span> </span>&#123;<br>        Set&lt;String&gt; keySet = option.keySet();<br>        ArrayList&lt;String&gt; keyList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(keySet);<br>        Collections.shuffle(keyList);<br>        HashMap&lt;String, String&gt; optionNew = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        String keyNew = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (String next : keySet) &#123;<br>            String randomKey = keyList.get(idx++);<br>            <span class="hljs-keyword">if</span> (key.equals(next)) &#123;<br>                keyNew = randomKey;<br>            &#125;<br>            optionNew.put(randomKey, option.get(next));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Topic(optionNew, keyNew);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>考题答案混排的工具包提供了实现混排的random方法。其核心逻辑如下：</p><ul><li>在混排操作方法中，首先把题目选项使用 Java 中 Collections 工具包里的shuffle方法进行混排操作</li><li>记录混排后正确答案的位置key.equals(next)，最终返回新的题目选项单Topic</li><li>混排的过程也就是把A的选项内容给B、把B的选项内容给 C，同时把正确答案位置标记出来</li></ul><p><strong>题库复制对象类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 题库</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuestionBank</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> String candidate; <span class="hljs-comment">// 考生</span><br>    <span class="hljs-keyword">private</span> String number;    <span class="hljs-comment">// 考号</span><br><br>    <span class="hljs-keyword">private</span> ArrayList&lt;ChoiceQuestion&gt; choiceQuestionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> ArrayList&lt;AnswerQuestion&gt; answerQuestionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> QuestionBank <span class="hljs-title">append</span><span class="hljs-params">(ChoiceQuestion choiceQuestion)</span> </span>&#123;<br>        choiceQuestionList.add(choiceQuestion);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> QuestionBank <span class="hljs-title">append</span><span class="hljs-params">(AnswerQuestion answerQuestion)</span> </span>&#123;<br>        answerQuestionList.add(answerQuestion);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        QuestionBank questionBank = (QuestionBank) <span class="hljs-keyword">super</span>.clone();<br>        questionBank.choiceQuestionList = (ArrayList&lt;ChoiceQuestion&gt;) choiceQuestionList.clone();<br>        questionBank.answerQuestionList = (ArrayList&lt;AnswerQuestion&gt;) answerQuestionList.clone();<br><br>        <span class="hljs-comment">// 题目乱序</span><br>        Collections.shuffle(questionBank.choiceQuestionList);<br>        Collections.shuffle(questionBank.answerQuestionList);<br><br>        <span class="hljs-comment">// 答案乱序</span><br>        ArrayList&lt;ChoiceQuestion&gt; choiceQuestionList = questionBank.choiceQuestionList;<br>        <span class="hljs-keyword">for</span> (ChoiceQuestion question : choiceQuestionList) &#123;<br>            Topic random = TopicRandomUtil.random(question.getOption(), question.getKey());<br>            question.setOption(random.getOption());<br>            question.setKey(random.getKey());<br>        &#125;<br>        <span class="hljs-keyword">return</span> questionBank;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCandidate</span><span class="hljs-params">(String candidate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.candidate = candidate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span><span class="hljs-params">(String number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><br>        StringBuilder detail = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;考生：&quot;</span> + candidate + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;考号：&quot;</span> + number + <span class="hljs-string">&quot;\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;--------------------------------------------\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;一、选择题&quot;</span> + <span class="hljs-string">&quot;\r\n\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; choiceQuestionList.size(); idx++) &#123;<br>            detail.append(<span class="hljs-string">&quot;第&quot;</span>).append(idx + <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;题：&quot;</span>).append(choiceQuestionList.get(idx).getName()).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            Map&lt;String, String&gt; option = choiceQuestionList.get(idx).getOption();<br>            <span class="hljs-keyword">for</span> (String key : option.keySet()) &#123;<br>                detail.append(key).append(<span class="hljs-string">&quot;：&quot;</span>).append(option.get(key)).append(<span class="hljs-string">&quot;\r\n&quot;</span>);;<br>            &#125;<br>            detail.append(<span class="hljs-string">&quot;答案：&quot;</span>).append(choiceQuestionList.get(idx).getKey()).append(<span class="hljs-string">&quot;\r\n\n&quot;</span>);<br>        &#125;<br><br>        detail.append(<span class="hljs-string">&quot;二、问答题&quot;</span> + <span class="hljs-string">&quot;\r\n\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; answerQuestionList.size(); idx++) &#123;<br>            detail.append(<span class="hljs-string">&quot;第&quot;</span>).append(idx + <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;题：&quot;</span>).append(answerQuestionList.get(idx).getName()).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            detail.append(<span class="hljs-string">&quot;答案：&quot;</span>).append(answerQuestionList.get(idx).getKey()).append(<span class="hljs-string">&quot;\r\n\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> detail.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类中的操作内容主要包括以下三个方面：</p><ul><li>两个 append（）对各项题目的添加有点像在建造者模式中使用的方式——添加装修材料</li><li>clone（）的核心操作是复制对象，这里的复制不仅包括对象本身，也包括两个集合。只有这样的复制才能确保在操作复制对象时不影响原对象</li><li>混排操作在list集合中有一个方法——Collections.shuffle，可以将原有集合的顺序打乱，输出一个新的顺序。这里使用此方法对题目进行混排操作</li></ul><p><strong>初始化试卷数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 题库管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuestionBankController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> QuestionBank questionBank = <span class="hljs-keyword">new</span> QuestionBank();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QuestionBankController</span><span class="hljs-params">()</span> </span>&#123;<br>        questionBank.append(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;JAVA所定义的版本中不包括&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;JAVA2 EE&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;JAVA2 Card&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;JAVA2 ME&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;JAVA2 HE&quot;</span>);<br>            put(<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;JAVA2 SE&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;D&quot;</span>)).append(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;下列说法正确的是&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;JAVA程序的main方法必须写在类里面&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;JAVA程序中可以有多个main方法&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;JAVA程序中类名必须与文件名一样&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;JAVA程序的main方法中如果只有一条语句，可以不用&#123;&#125;(大括号)括起来&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;A&quot;</span>)).append(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;变量命名规范说法正确的是&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;变量由字母、下划线、数字、$符号随意组成；&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;变量不能以数字作为开头；&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A和a在java中是同一个变量；&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;不同类型的变量，可以起相同的名字；&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;B&quot;</span>)).append(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;以下()不是合法的标识符&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;STRING&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;x3x;&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;void&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;de$f&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;C&quot;</span>)).append(<span class="hljs-keyword">new</span> ChoiceQuestion(<span class="hljs-string">&quot;表达式(11+3*8)/4%3的值是&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;31&quot;</span>);<br>            put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>            put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>        &#125;&#125;, <span class="hljs-string">&quot;D&quot;</span>))<br>                .append(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;小红马和小黑马生的小马几条腿&quot;</span>, <span class="hljs-string">&quot;4条腿&quot;</span>))<br>                .append(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;铁棒打头疼还是木棒打头疼&quot;</span>, <span class="hljs-string">&quot;头最疼&quot;</span>))<br>                .append(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;什么床不能睡觉&quot;</span>, <span class="hljs-string">&quot;牙床&quot;</span>))<br>                .append(<span class="hljs-keyword">new</span> AnswerQuestion(<span class="hljs-string">&quot;为什么好马不吃回头草&quot;</span>, <span class="hljs-string">&quot;后面的草没了&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createPaper</span><span class="hljs-params">(String candidate, String number)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        QuestionBank questionBankClone = (QuestionBank) questionBank.clone();<br>        questionBankClone.setCandidate(candidate);<br>        questionBankClone.setNumber(number);<br>        <span class="hljs-keyword">return</span> questionBankClone.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类的内容就比较简单了，主要提供对试卷内容的模式初始化操作（所有考生的试卷一样，但题目顺序不一致）。</p><p>对外部提供创建试卷的方法，在创建的过程中使用的是复制的方式（QuestionBank） questionBank.clone（）；并最终返回试卷信 息。</p><p><strong>测试验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_QuestionBank</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        QuestionBankController questionBankController = <span class="hljs-keyword">new</span> QuestionBankController();<br>        System.out.println(questionBankController.createPaper(<span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;1000001921032&quot;</span>));<br>        System.out.println(questionBankController.createPaper(<span class="hljs-string">&quot;豆豆&quot;</span>, <span class="hljs-string">&quot;1000001921051&quot;</span>));<br>        System.out.println(questionBankController.createPaper(<span class="hljs-string">&quot;大宝&quot;</span>, <span class="hljs-string">&quot;1000001921987&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">考生：花花<br>考号：<span class="hljs-number">1000001921032</span><br><span class="hljs-operator">--------------------------------------------</span><br>一、选择题<br><br>第<span class="hljs-number">1</span>题：表达式<span class="hljs-punctuation">(</span><span class="hljs-number">11</span><span class="hljs-operator">+</span><span class="hljs-number">3</span><span class="hljs-operator">*</span><span class="hljs-number">8</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">4</span><span class="hljs-operator">%</span><span class="hljs-number">3</span>的值是<br><span class="hljs-variable">A</span>：<span class="hljs-number">2</span><br><span class="hljs-variable">B</span>：<span class="hljs-number">1</span><br><span class="hljs-built_in">C</span>：<span class="hljs-number">0</span><br><span class="hljs-built_in">D</span>：<span class="hljs-number">31</span><br>答案：<span class="hljs-variable">A</span><br><br>第<span class="hljs-number">2</span>题：<span class="hljs-variable">JAVA</span>所定义的版本中不包括<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">ME</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">HE</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">EE</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">Card</span><br><span class="hljs-built_in">E</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">SE</span><br>答案：<span class="hljs-variable">B</span><br><br>第<span class="hljs-number">3</span>题：以下<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>不是合法的标识符<br><span class="hljs-variable">A</span>：<span class="hljs-variable">de$f</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">x3x</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">void</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">STRING</span><br>答案：<span class="hljs-built_in">C</span><br><br>第<span class="hljs-number">4</span>题：下列说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA</span>程序中类名必须与文件名一样<br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA</span>程序中可以有多个<span class="hljs-variable">main</span>方法<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法中如果只有一条语句，可以不用<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>大括号<span class="hljs-punctuation">)</span>括起来<br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法必须写在类里面<br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">5</span>题：变量命名规范说法正确的是<br><span class="hljs-variable">A</span>：变量由字母、下划线、数字、<span class="hljs-variable">$</span>符号随意组成；<br><span class="hljs-variable">B</span>：<span class="hljs-variable">A</span>和<span class="hljs-variable">a</span>在<span class="hljs-variable">java</span>中是同一个变量；<br><span class="hljs-built_in">C</span>：不同类型的变量，可以起相同的名字；<br><span class="hljs-built_in">D</span>：变量不能以数字作为开头；<br>答案：<span class="hljs-built_in">D</span><br><br>二、问答题<br><br>第<span class="hljs-number">1</span>题：小红马和小黑马生的小马几条腿<br>答案：<span class="hljs-number">4</span>条腿<br><br>第<span class="hljs-number">2</span>题：铁棒打头疼还是木棒打头疼<br>答案：头最疼<br><br>第<span class="hljs-number">3</span>题：为什么好马不吃回头草<br>答案：后面的草没了<br><br>第<span class="hljs-number">4</span>题：什么床不能睡觉<br>答案：牙床<br><br><br>考生：豆豆<br>考号：<span class="hljs-number">1000001921051</span><br><span class="hljs-operator">--------------------------------------------</span><br>一、选择题<br><br>第<span class="hljs-number">1</span>题：下列说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA</span>程序中类名必须与文件名一样<br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法中如果只有一条语句，可以不用<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>大括号<span class="hljs-punctuation">)</span>括起来<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA</span>程序中可以有多个<span class="hljs-variable">main</span>方法<br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法必须写在类里面<br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">2</span>题：表达式<span class="hljs-punctuation">(</span><span class="hljs-number">11</span><span class="hljs-operator">+</span><span class="hljs-number">3</span><span class="hljs-operator">*</span><span class="hljs-number">8</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">4</span><span class="hljs-operator">%</span><span class="hljs-number">3</span>的值是<br><span class="hljs-variable">A</span>：<span class="hljs-number">0</span><br><span class="hljs-variable">B</span>：<span class="hljs-number">1</span><br><span class="hljs-built_in">C</span>：<span class="hljs-number">31</span><br><span class="hljs-built_in">D</span>：<span class="hljs-number">2</span><br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">3</span>题：变量命名规范说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">A</span>和<span class="hljs-variable">a</span>在<span class="hljs-variable">java</span>中是同一个变量；<br><span class="hljs-variable">B</span>：不同类型的变量，可以起相同的名字；<br><span class="hljs-built_in">C</span>：变量由字母、下划线、数字、<span class="hljs-variable">$</span>符号随意组成；<br><span class="hljs-built_in">D</span>：变量不能以数字作为开头；<br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">4</span>题：<span class="hljs-variable">JAVA</span>所定义的版本中不包括<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">Card</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">ME</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">HE</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">SE</span><br><span class="hljs-built_in">E</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">EE</span><br>答案：<span class="hljs-built_in">C</span><br><br>第<span class="hljs-number">5</span>题：以下<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>不是合法的标识符<br><span class="hljs-variable">A</span>：<span class="hljs-variable">STRING</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">x3x</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">void</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">de$f</span><br>答案：<span class="hljs-built_in">C</span><br><br>二、问答题<br><br>第<span class="hljs-number">1</span>题：小红马和小黑马生的小马几条腿<br>答案：<span class="hljs-number">4</span>条腿<br><br>第<span class="hljs-number">2</span>题：为什么好马不吃回头草<br>答案：后面的草没了<br><br>第<span class="hljs-number">3</span>题：什么床不能睡觉<br>答案：牙床<br><br>第<span class="hljs-number">4</span>题：铁棒打头疼还是木棒打头疼<br>答案：头最疼<br><br><br>考生：大宝<br>考号：<span class="hljs-number">1000001921987</span><br><span class="hljs-operator">--------------------------------------------</span><br>一、选择题<br><br>第<span class="hljs-number">1</span>题：表达式<span class="hljs-punctuation">(</span><span class="hljs-number">11</span><span class="hljs-operator">+</span><span class="hljs-number">3</span><span class="hljs-operator">*</span><span class="hljs-number">8</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">4</span><span class="hljs-operator">%</span><span class="hljs-number">3</span>的值是<br><span class="hljs-variable">A</span>：<span class="hljs-number">0</span><br><span class="hljs-variable">B</span>：<span class="hljs-number">31</span><br><span class="hljs-built_in">C</span>：<span class="hljs-number">1</span><br><span class="hljs-built_in">D</span>：<span class="hljs-number">2</span><br>答案：<span class="hljs-built_in">D</span><br><br>第<span class="hljs-number">2</span>题：<span class="hljs-variable">JAVA</span>所定义的版本中不包括<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">SE</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">EE</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">HE</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">Card</span><br><span class="hljs-built_in">E</span>：<span class="hljs-variable">JAVA2</span> <span class="hljs-variable">ME</span><br>答案：<span class="hljs-built_in">C</span><br><br>第<span class="hljs-number">3</span>题：以下<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>不是合法的标识符<br><span class="hljs-variable">A</span>：<span class="hljs-variable">void</span><br><span class="hljs-variable">B</span>：<span class="hljs-variable">x3x</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">C</span>：<span class="hljs-variable">STRING</span><br><span class="hljs-built_in">D</span>：<span class="hljs-variable">de$f</span><br>答案：<span class="hljs-variable">A</span><br><br>第<span class="hljs-number">4</span>题：变量命名规范说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">A</span>和<span class="hljs-variable">a</span>在<span class="hljs-variable">java</span>中是同一个变量；<br><span class="hljs-variable">B</span>：变量不能以数字作为开头；<br><span class="hljs-built_in">C</span>：变量由字母、下划线、数字、<span class="hljs-variable">$</span>符号随意组成；<br><span class="hljs-built_in">D</span>：不同类型的变量，可以起相同的名字；<br>答案：<span class="hljs-variable">B</span><br><br>第<span class="hljs-number">5</span>题：下列说法正确的是<br><span class="hljs-variable">A</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法必须写在类里面<br><span class="hljs-variable">B</span>：<span class="hljs-variable">JAVA</span>程序的<span class="hljs-variable">main</span>方法中如果只有一条语句，可以不用<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>大括号<span class="hljs-punctuation">)</span>括起来<br><span class="hljs-built_in">C</span>：<span class="hljs-variable">JAVA</span>程序中类名必须与文件名一样<br><span class="hljs-built_in">D</span>：<span class="hljs-variable">JAVA</span>程序中可以有多个<span class="hljs-variable">main</span>方法<br>答案：<span class="hljs-variable">A</span><br><br>二、问答题<br><br>第<span class="hljs-number">1</span>题：小红马和小黑马生的小马几条腿<br>答案：<span class="hljs-number">4</span>条腿<br><br>第<span class="hljs-number">2</span>题：为什么好马不吃回头草<br>答案：后面的草没了<br><br>第<span class="hljs-number">3</span>题：什么床不能睡觉<br>答案：牙床<br><br>第<span class="hljs-number">4</span>题：铁棒打头疼还是木棒打头疼<br>答案：头最疼<br><br>进程已结束<span class="hljs-operator">,</span>退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>以上的实际业务场景模拟了原型模式在开发中的作用。因为原型模式的使用频率不是很高，所以如果有一些特殊场景需要使用，可以按照此设计模式优化。另外，原型设计模式的优点包括：便于通过克隆方式创建复杂对象，也可以避免重复初始化，不需要与类中所属的其他类耦合等。但也有一些缺点，如果对象中包括了循环引用的复制，以及类中深度使用对象的复制，都会使此模式变得非常麻烦。设计模式终究是一种设计思想，只有在不同的场景中合理地运用才能提升整体架构的质量。永远不要想着生硬地套用设计模式，否则将会导致过渡设计，并在满足业务反复变化的需求时造成开发浪费，增加维护成本。另外，初期是代码的优化，中期是设计模式的使用，后期是把控全局服务的搭建。只有不断地加强自己对全局能力的把控，才能加深自己对细节处理的理解。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="单例模式介绍"><a href="#单例模式介绍" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h3><p>单例模式是整个设计中比较简单的模式，即使没有看过设计模式的相关资料，也会经常用在实际业务的编码开发中。因为在编程开发中经常会遇到这种场景——需要保证一个类只有一个实例，哪怕多线程同时访问，而且需要提供一个全局访问此实例的点。可以总结出一条经验，单例模式主要解决的是一个全局使用的类，被频繁地创建与销毁，从而提升代码的整体性能，</p><h3 id="案例场景介绍"><a href="#案例场景介绍" class="headerlink" title="案例场景介绍"></a>案例场景介绍</h3><p>单例模式适用的场景非常简单，是在日常开发中能遇到的，如数据库的连接池不会反复创建，Spring中一个单例模式Bean的生成和使用，代码中需要设置全局的一些属性并保存。</p><h3 id="七种单例模式实现方式"><a href="#七种单例模式实现方式" class="headerlink" title="七种单例模式实现方式"></a>七种单例模式实现方式</h3><p>单例模式的实现方式比较多，主要分为在实现上是否支持懒汉模式，是否支持在线程安全中运用各项技巧。当然，也有一些场景不需要考虑懒汉模式的情况，会直接使用static静态类或属性和方法的方式，供外部调用。</p><p>接下来通过不同方式的实现，讲解单例模式。</p><ol><li><p><strong>静态类使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton_00</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; cache = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这种静态类方式在日常的业务开发中很常见，它可以在第一次运行时直接初始化Map类，同时也不需要直到延迟加载再使用。在不需要维持任何状态的情况下，仅仅用于全局访问，使用静态类方式更加方便。在需要被继承及维持一些特定状态的情况下，适合使用单例模式。</p></li><li><p><strong>懒汉模式（线程不安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton_01</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton_01 instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton_01</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton_01 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != instance) <span class="hljs-keyword">return</span> instance;<br>        instance = <span class="hljs-keyword">new</span> Singleton_01();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例模式有一个特点是不允许外部直接创建，也就是 new Singleton_01() ，因此这里在默认的构造函数上添加了私有属性private。虽然采用此种方式的单例满足了懒汉模式，但是如果有多个访问者同时获取对象实例，就会造成多个同样的实例并存，没有达到单例的要求。</p></li><li><p><strong>懒汉模式（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton_02</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton_02 instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton_02</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton_02 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != instance) <span class="hljs-keyword">return</span> instance;<br>        instance = <span class="hljs-keyword">new</span> Singleton_01();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此种模式虽然是安全的，但由于把锁加到方法中后，所有的访问因为需要锁占用，导致资源浪费。除非在特殊情况下，否则不建议用此种方式实现单例模式。</p></li><li><p><strong>饿汉模式（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton_03</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton_03 instance = <span class="hljs-keyword">new</span> Singleton_03();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton_03</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton_03 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式与开头的第一个实例化 Map 基本一致，在程序启动时直接运行加载，后续有外部需要使用时获取即可。这种方式并不是懒加载，也就是说无论程序中是否用到这样的类，都会在程序启动之初进行创建。这种方式造成的问题就像一款游戏软件，可能游戏地图还没 有打开，但是程序已经将这些地图全部实例化。在手机上最明显的体验就是打开游戏提示内存满了，造成手机卡顿。</p></li><li><p><strong>使用类的内部类（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton_04</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton_04 instance = <span class="hljs-keyword">new</span> Singleton_04();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton_04</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton_04 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用类的静态内部类实现的单例模式，既保证了线程安全，又保证了懒汉模式，同时不会因为加锁而降低性能。这主要是因为JVM虚拟机可以保证多线程并发访问的正确性，也就是一个类的构造方法在多线程环境下可以被正确地加载。这也是推荐使用的一种单例模式。</p></li><li><p><strong>双重锁校验（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton_05</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton_05 instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton_05</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton_05 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != instance) <span class="hljs-keyword">return</span> instance;<br>       <span class="hljs-keyword">synchronized</span> (Singleton_05.class)&#123;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance)&#123;<br>               instance = <span class="hljs-keyword">new</span> Singleton_05();<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>双重锁的方式是方法级锁的优化，减少了获取实例的耗时。同时，这种方式也满足了懒汉模式。</p></li><li><p><strong>CAS“AtomicReference”（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton_06</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicReference&lt;Singleton_06&gt; INSTANCE = <span class="hljs-keyword">new</span> AtomicReference&lt;Singleton_06&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton_06 instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton_06</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton_06 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            Singleton_06 instance = INSTANCE.get();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != instance) <span class="hljs-keyword">return</span> instance;<br>            INSTANCE.compareAndSet(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Singleton_06());<br>            <span class="hljs-keyword">return</span> INSTANCE.get();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Java 并发库提供了很多原子类支持并发访问的数据安全性，如：AtomicInteger、AtomicBoolean、AtomicLong 和 AtomicReference。</p><p>AtomicReference 可以封装引用一个V实例，上面支持并发访问的单例模式就是利用了这种特性。使用CAS的好处是不需要使用传统的加锁方式，而是依赖CAS的忙等算法、底层硬件的实现保证线程安全。相对于其他锁的实现，没有线程的切换和阻塞也就没有了额外的开销，并且可以支持较大的并发。当然，CAS也有一个缺点就是忙等，如果一直没有获取到，会陷于死循环。</p></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>虽然单例模式只是一个很平常的模式，但在各种的实现上却需要用到 Java 的基本功，包括懒汉模式、饿汉模式、线程是否安全、静态类、内部类、加锁和串行化等。在日常开发中，如果可以确保此类是全局可用的，则不需要懒汉模式，那么直接创建并给外部调用即可。但如果有很多的类，有些需要在用户触发一定的条件后才显示，那么一定要用懒汉模式。对于线程的安全，可以按需选择。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式笔记（一）六大设计原则</title>
    <link href="/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="单一职责原理定义"><a href="#单一职责原理定义" class="headerlink" title="单一职责原理定义"></a>单一职责原理定义</h3><p>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，是面向对象的五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因。</p><p>如果需要开发的一个功能需求不是一次性的，且随着业务发展的不断变化而变化，那么当一个Class类负责超过两个及以上的职责时， 那么在需求的不断迭代、实现类持续扩张的情况下，就会出现难以维 护、不好扩展、测试难度大和上线风险高等问题。 </p><p>所谓的职责就是指类变化的原因，也就是业务需求。如果一个类 有多于一个的原因被改变，那么这个类就有超过两个及以上的职责。 而单一职责约定一个类应该有且仅有一个改变类的原因。</p><h3 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h3><p>这里通过一个视频网站用户分类的例子，来帮助大家理解单一职责原则的构建方法。当在各类视频网站看电影、电视剧时，网站针对不同的用户类型，会在用户观看时给出不同的服务反馈，如以下三种：</p><ul><li>访客用户，一般只可以观看480P视频，并时刻提醒用户注册会员能观看高清视频。这表示视频业务发展需要拉客，以获取更多的新注册用户</li><li>普通用户，可以观看720P超清视频，但不能屏蔽视频中出现的广告。这表示视频业务发展需要盈利</li><li>VIP用户（属于付费用户），既可以观看 1080P 蓝光视频，又可以关闭或跳过广告</li></ul><h3 id="违背原则方案"><a href="#违背原则方案" class="headerlink" title="违背原则方案"></a>违背原则方案</h3><p>下面根据需求场景直接编码，实现一个最简单的基本功能，即根 据不同的用户类型，判断用户可以观看视频的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoUserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serveGrade</span><span class="hljs-params">(String userType)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;VIP用户&quot;</span>.equals(userType))&#123;<br>            System.out.println(<span class="hljs-string">&quot;VIP用户，视频1080P蓝光&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;普通用户&quot;</span>.equals(userType))&#123;<br>            System.out.println(<span class="hljs-string">&quot;普通用户，视频720P超清&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;访客用户&quot;</span>.equals(userType))&#123;<br>            System.out.println(<span class="hljs-string">&quot;访客用户，视频480P高清&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，实现业务功能逻辑的方式非常简单，暂时也不会出什么问题。但是这一个类里包含着多个不同的行为，也就是多种用户职责。如果在这样的类上继续扩展功能或添加逻辑，就会显得非常臃肿。</p><p>接下来通过单元测试，再看这个类功能的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_serveGrade</span><span class="hljs-params">()</span> </span>&#123;<br>    VideoUserService service = <span class="hljs-keyword">new</span> VideoUserService();<br>    service.serveGrade(<span class="hljs-string">&quot;VIP用户&quot;</span>);<br>    service.serveGrade(<span class="hljs-string">&quot;普通用户&quot;</span>);<br>    service.serveGrade(<span class="hljs-string">&quot;访客用户&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp">VIP用户，视频<span class="hljs-number">1080</span><span class="hljs-keyword">P</span>蓝光<br>普通用户，视频<span class="hljs-number">720</span><span class="hljs-keyword">P</span>超清<br>访客用户，视频<span class="hljs-number">480</span><span class="hljs-keyword">P</span>高清<br></code></pre></td></tr></table></figure><p>因为上面的实现方式是在一个类中用if…else判断逻辑，所以在调用方法时是所有的职责用户都使用一个方法实现，作为程序调用入口。对于简单的或者几乎不需要迭代的功能，这种实现也未偿不可。但如果面对频繁迭代的业务需求，这样的代码结构就很难支撑系统迭代，每一次需求的实现都可能会影响其他逻辑，给整个接口服务带来不可控的风险。</p><h3 id="单一职责原则改善代码"><a href="#单一职责原则改善代码" class="headerlink" title="单一职责原则改善代码"></a>单一职责原则改善代码</h3><p>视频播放是视频网站的核心功能，当核心功能开发完成后，就需要不断地完善用户权限。这样才能更好地运营一家视频网站。 </p><p>在模拟用户场景中，其实就是在不断地建设用户权益。针对不同的用户类型提供差异化服务，既满足获客需求，又可以让部分用户选择付费。 </p><p>为了满足这样不断迭代的需求，就不能使用一个类把所有职责行为混为一谈，而是需要提供一个上层的接口类，对不同的差异化用户给出单独的实现类，拆分各自的职责边界。</p><p><img src="/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-1.png" alt></p><p><strong>定义出上层接口 IVideoUserService</strong>，统一定义需要实现的功能，包括：视频清晰级别接口definition（）、广告播放方式接口advertisement（）。三种不同类型的用户就可以分别实现自己的服务类，做到职责统一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IVideoUserService</span> </span>&#123;<br>    <span class="hljs-comment">//视频清晰级别：480P、720P、1080P</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">definition</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//广告播放方式：无广告、有广告</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advertisement</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现类，访客用户</strong>。这个类实现的是访客用户在视频网站中的形态，比如这类用户只能观看480P高清视频，同时需要观看广告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuestVideoUserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IVideoUserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">definition</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访客用户，视频480P高清&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">advertisement</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访客用户，视频有广告&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现类，普通用户</strong>。这个类实现的是普通用户在视频网站中的形态，也就是注册用户可以观看720P超清视频，另外也需要观看广告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdinaryVideoUserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IVideoUserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">definition</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通用户，视频720P超清&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">advertisement</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通用户，视频有广告&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现类，VIP用户</strong>。这个类实现的是VIP用户在视频网站中的形态。因为这类用户已经是付费用户，所以可以观看更高清的视频，同时不需要观看广告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VipVideoUserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IVideoUserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">definition</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;VIP用户，视频1080P蓝光&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">advertisement</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;VIP用户，视频无广告&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上，每种用户对应的服务职责都有对应的类实现，不会互相干扰。当某一类用户需要添加新的运营规则时，操作起来也可以非常方便。比如，所有的注册用户（即普通用户和VIP用户）可以发弹幕、付费用户可以点播等</p><p><strong>单元测试</strong>。接下来再看现在的类服务的使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_VideoUserService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//访问用户</span><br>    GuestVideoUserService guest = <span class="hljs-keyword">new</span> GuestVideoUserService();<br>    guest.definition();<br>    guest.advertisement();<br>    <span class="hljs-comment">//普通会员</span><br>    OrdinaryVideoUserService ordinary = <span class="hljs-keyword">new</span> OrdinaryVideoUserService();<br>    ordinary.definition();<br>    ordinary.advertisement();<br>    <span class="hljs-comment">//VIP用户</span><br>    VipVideoUserService vip = <span class="hljs-keyword">new</span> VipVideoUserService();<br>    vip.definition();<br>    vip.advertisement();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tp">访客用户，视频<span class="hljs-number">480</span><span class="hljs-keyword">P</span>高清<br>访客用户，视频有广告<br>普通用户，视频<span class="hljs-number">720</span><span class="hljs-keyword">P</span>超清<br>普通用户，视频有广告<br>VIP用户，视频<span class="hljs-number">1080</span><span class="hljs-keyword">P</span>蓝光<br>VIP用户，视频无广告<br></code></pre></td></tr></table></figure><p>通过利用单一职责原则的代码优化后，现在每个类都只负责自己的用户行为。后续无论扩展新的功能还是需要在某个时刻修改某个用户行为类，都可以非常方便地开发和维护。 </p><p>在项目开发的过程中，尽可能保证接口的定义、类的实现以及方法开发保持单一职责，对项目后期的迭代和维护会有很大的帮助。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><h3 id="开闭原则定义"><a href="#开闭原则定义" class="headerlink" title="开闭原则定义"></a>开闭原则定义</h3><p> 在面向对象编程领域中，开闭原则规定软件中的对象、类、模块和函数对扩展应该是开放的，但对于修改是封闭的。这意味着应该用抽象定义结构，用具体实现扩展细节，以此确保软件系统开发和维护过程的可靠性。 </p><p>开闭原则的核心思想也可以理解为面向抽象编程。</p><h3 id="模拟场景-1"><a href="#模拟场景-1" class="headerlink" title="模拟场景"></a>模拟场景</h3><p>对于外部的调用方来说，只要能体现出面向抽象编程，定义出接口并实现其方法，即不修改原有方法体，只通过继承方式进行扩展，都可以体现出开闭原则。</p><p>这里计算三种形状的面积，如长方形、三角形、圆形，它们在类中已经按照固定的公式实现，其中圆形面积公式中π=3.14。但后续由于π值取的精度对于某些场景是不足的，需要扩展，接下来就通过模拟这个场景体现开闭原则。</p><p><strong>定义接口</strong>。分别定义了三种求面积的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculationArea</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算面积，长方形</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x 长</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y 宽</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 面积</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span></span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算面积，三角形</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x 边长x</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y 边长y</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> z 边长z</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  面积</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 海伦公式：S=√[p(p-a)(p-b)(p-c)] 其中：p=(a+b+c)/2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">triangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">double</span> z)</span></span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算面积，圆形</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r 半径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 面积</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 圆面积公式：S=πr²</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">circular</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现类</strong>。在实现类中，分别实现三种类型的面积计算，长方形（rectangle）、三角形（triangle）、圆形（circular）。其中，圆形面积的 π 值取的是 3.14D，这也是要扩展精度的方法和体现开闭原则的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculationArea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculationArea</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> π = <span class="hljs-number">3.14D</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x * y;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">triangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">double</span> z)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> p = (x + y + z) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> Math.sqrt(p * (p - x) * (p - y) * (p - z));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">circular</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> π * r * r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="违背原则方案-1"><a href="#违背原则方案-1" class="headerlink" title="违背原则方案"></a>违背原则方案</h3><p>如果不考虑开闭原则，也不思考这种方法在整个工程服务中的使用情况，那么直接修改π值就可以了；但这样做就会破坏整个工程服务的稳定性，也会造成一些风险。</p><p>例如，用原来精度的π值计算出的圆形面积本可以满足需求，但是因为精度加长破坏了原有精度下的稳定性，就像齿轮间的啮合程度、方向盘的间隙等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> π = <span class="hljs-number">3.141592653D</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">circular</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> π * r * r;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开闭原则改善代码"><a href="#开闭原则改善代码" class="headerlink" title="开闭原则改善代码"></a>开闭原则改善代码</h3><p>按照开闭原则方式实现起来并不复杂，它的主要目的是不能因为个例需求的变化而改变预定的实现类，除非预定的实现类有错误。</p><p>实现过程是继承父类扩展需要的方法，同时可以保留原有的方法，新增自己需要的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculationAreaExt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CalculationArea</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> π = <span class="hljs-number">3.141592653D</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">circular</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> π * r * r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展后的方法已经把求圆形面积的精度增长，需要使用此方法的用户可以直接调用。而其他的方法，如长方形面积、三角形面积，则可以继续使用。</p><p>单元测试，直接调用更新Π值后扩展的类来计算圆形面积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_CalculationAreaExt</span><span class="hljs-params">()</span></span>&#123;<br>    ICalculationArea area = <span class="hljs-keyword">new</span> CalculationAreaExt();<br>    System.out.println(<span class="hljs-string">&quot;需要用更新后的Π值来计算圆形面积&quot;</span>);<br>    <span class="hljs-keyword">double</span> circular = area.circular(<span class="hljs-number">10</span>);<br>    System.out.println(circular);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">直接调用更新Π值后扩展的类来计算圆形面积<br><span class="hljs-number">314</span>.<span class="hljs-number">1592653</span><br></code></pre></td></tr></table></figure><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="里氏替换原则定义"><a href="#里氏替换原则定义" class="headerlink" title="里氏替换原则定义"></a>里氏替换原则定义</h3><p>继承必须确保超类所拥有的性质在子类中仍然成立。</p><ol><li><p>里氏替换原则</p><p>如果S是T的子类型，那么所有T类型的对象都可以在不破坏程序的情况下被S类型的对象替换。</p><p>简单来说，子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：当子类继承父类时，除了添加新的方法且完成新增功能外，尽量不要重写父类的方法。这句话包括了四点含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。</li><li>当子类的方法实现父类的方法（重写、重载或实现抽象方法） 时，方法的后置条件（即方法的输出或返回值）要比父类的方法更严格或与父类的方法相等。</li></ul></li><li><p>里氏替换原则的作用</p><ul><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>解决了继承中重写父类造成的可复用性变差的问题。</li><li>是动作正确性的保证，即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时在变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ul></li></ol><h3 id="模拟场景-2"><a href="#模拟场景-2" class="headerlink" title="模拟场景"></a>模拟场景</h3><p>关于里氏替换的场景，最有名的就是“正方形不是长方形”。同时还有一些关于动物的例子，比如鸵鸟、企鹅都是鸟，但是却不能飞。这样的例子可以非常形象地帮助我们理解里氏替换中关于两个类的继承不能破坏原有特性的含义。</p><p>为了从真实的开发场景感受里氏替换原则，这里选择不同种类的银行卡作为场景对象进行学习。</p><p>我们会使用各种类型的银行卡，例如储蓄卡、信用卡，还有一些其他特性的银行卡。储蓄卡和信用卡都具备一定的消费功能，但又有 一些不同。例如信用卡不宜提现，如果提现可能会产生高额的利息。</p><p>下面构建这样一个模拟场景，假设在构建银行系统时，储蓄卡是第一个类，信用卡是第二个类。为了让信用卡可以使用储蓄卡的一些方法，选择由信用卡类继承储蓄卡类，讨论是否满足里氏替换原则产生的一些要点。</p><h3 id="违背原则方案-2"><a href="#违背原则方案-2" class="headerlink" title="违背原则方案"></a>违背原则方案</h3><p>储蓄卡和信用卡在使用功能上类似，都有支付、提现、还款、充值等功能，也有些许不同，例如支付，储蓄卡做的是账户扣款动作，信用卡做的是生成贷款单动作。下面这里模拟先有储蓄卡的类，之后继承这个类的基本功能，以实现信用卡的功能。</p><p><strong>储蓄卡类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CashCard</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(CashCard.class);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提现</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 单号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 状态码 0000成功、0001失败、0002重复</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">withdrawal</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟支付成功</span><br>        logger.info(<span class="hljs-string">&quot;提现成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 储蓄</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 单号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">recharge</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟充值成功</span><br>        logger.info(<span class="hljs-string">&quot;储蓄成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交易流水查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 交易流水</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">tradeFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;交易流水查询成功&quot;</span>);<br>        List&lt;String&gt; tradeList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        tradeList.add(<span class="hljs-string">&quot;100001,100.00&quot;</span>);<br>        tradeList.add(<span class="hljs-string">&quot;100001,80.00&quot;</span>);<br>        tradeList.add(<span class="hljs-string">&quot;100001,76.50&quot;</span>);<br>        tradeList.add(<span class="hljs-string">&quot;100001,126.00&quot;</span>);<br>        <span class="hljs-keyword">return</span> tradeList;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在储蓄卡的功能实现中包括了三个方法：提现、储蓄、交易流水查询，这些是模拟储蓄卡的基本功能。接下来通过继承储蓄卡的功能，实现信用卡服务。</p><p><strong>信用卡类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreditCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CashCard</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(CashCard.class);<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">withdrawal</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 校验</span><br>        <span class="hljs-keyword">if</span> (amount.compareTo(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">1000</span>)) &gt;= <span class="hljs-number">0</span>)&#123;<br>            logger.info(<span class="hljs-string">&quot;贷款金额校验(限额1000元)，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0001&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 模拟生成贷款单</span><br>        logger.info(<span class="hljs-string">&quot;生成贷款单，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-comment">// 模拟支付成功</span><br>        logger.info(<span class="hljs-string">&quot;贷款成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">recharge</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟生成还款单</span><br>        logger.info(<span class="hljs-string">&quot;生成还款单，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-comment">// 模拟还款成功</span><br>        logger.info(<span class="hljs-string">&quot;还款成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">tradeFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.tradeFlow();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>信用卡的功能实现是在继承了储蓄卡类后，进行方法重写：支付withdrawal（）、还款recharge（）。其实交易流水可以复用，也可以不用重写这个类。</p><p>这种继承父类方式的优点是复用了父类的核心功能逻辑，但是也破坏了原有的方法。此时继承父类实现的信用卡类并不满足里氏替换原则，也就是说，此时的子类不能承担原父类的功能，直接给储蓄卡使用。</p><h3 id="里氏替换原则改善代码"><a href="#里氏替换原则改善代码" class="headerlink" title="里氏替换原则改善代码"></a>里氏替换原则改善代码</h3><p>储蓄卡和信用卡在功能使用上有些许类似，在实际的开发过程中也有很多共同可复用的属性及逻辑。实现这样的类的最好方式是提取出一个抽象类，由抽象类定义所有卡的共用核心属性、逻辑，把卡的支付和还款等动作抽象成正向和逆向操作。</p><ol><li><p><strong>抽象银行卡类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankCard</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(BankCard.class);<br><br>    <span class="hljs-keyword">private</span> String cardNo;   <span class="hljs-comment">// 卡号</span><br>    <span class="hljs-keyword">private</span> String cardDate; <span class="hljs-comment">// 开卡时间</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BankCard</span><span class="hljs-params">(String cardNo, String cardDate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cardNo = cardNo;<br>        <span class="hljs-keyword">this</span>.cardDate = cardDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rule</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br>    <span class="hljs-comment">// 正向入账，+ 钱</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">positive</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 入款成功，存款、还款</span><br>        logger.info(<span class="hljs-string">&quot;卡号&#123;&#125; 入款成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, cardNo, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 逆向入账，- 钱</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">negative</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 入款成功，存款、还款</span><br>        logger.info(<span class="hljs-string">&quot;卡号&#123;&#125; 出款成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, cardNo, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交易流水查询</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 交易流水</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">tradeFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;交易流水查询成功&quot;</span>);<br>        List&lt;String&gt; tradeList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        tradeList.add(<span class="hljs-string">&quot;100001,100.00&quot;</span>);<br>        tradeList.add(<span class="hljs-string">&quot;100001,80.00&quot;</span>);<br>        tradeList.add(<span class="hljs-string">&quot;100001,76.50&quot;</span>);<br>        tradeList.add(<span class="hljs-string">&quot;100001,126.00&quot;</span>);<br>        <span class="hljs-keyword">return</span> tradeList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCardNo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cardNo;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCardDate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cardDate;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在抽象银行卡类中，提供了基本的卡属性，包括卡号、开卡时间及三个核心方法。①正向入账，加钱；②逆向入账，减钱；③交易流水查询。当然，实际的业务开发抽象出来的逻辑会比模拟场景多一些。接下来继承这个抽象类，实现储蓄卡的功能逻辑。</p></li><li><p><strong>储蓄卡类实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CashCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BankCard</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(CashCard.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CashCard</span><span class="hljs-params">(String cardNo, String cardDate)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(cardNo, cardDate);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">rule</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提现</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 单号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 状态码 0000成功、0001失败、0002重复</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">withdrawal</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟支付成功</span><br>        logger.info(<span class="hljs-string">&quot;提现成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.negative(orderId, amount);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 储蓄</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 单号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">recharge</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟充值成功</span><br>        logger.info(<span class="hljs-string">&quot;储蓄成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.positive(orderId, amount);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 风险校验</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cardNo  卡号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 单号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkRisk</span><span class="hljs-params">(String cardNo, String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟风控校验</span><br>        logger.info(<span class="hljs-string">&quot;风控校验，卡号：&#123;&#125; 单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, cardNo, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>储蓄卡类中继承抽象银行卡父类 BankCard，实现的核心功能包括规则过滤rule、提现withdrawal、储蓄recharge和新增的扩展方法，即风控校验 checkRisk。</p><p>这样的实现方式满足了里氏替换的基本原则，既实现抽象类的抽象方法，又没有破坏父类中的原有方法。接下来实现信用卡的功能，信用卡的功能可以继承于储蓄卡，也可以继承抽象银行卡父类。但无论哪种实现方式，都需要遵从里氏替换原则，不可以破坏父类原有的方法。</p></li><li><p><strong>信用卡类实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreditCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CashCard</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(CreditCard.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CreditCard</span><span class="hljs-params">(String cardNo, String cardDate)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(cardNo, cardDate);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">rule2</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> amount.compareTo(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">1000</span>)) &lt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提现，信用卡贷款</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 单号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 状态码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loan</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> rule = rule2(amount);<br>        <span class="hljs-keyword">if</span> (!rule) &#123;<br>            logger.info(<span class="hljs-string">&quot;生成贷款单失败，金额超限。单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0001&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 模拟生成贷款单</span><br>        logger.info(<span class="hljs-string">&quot;生成贷款单，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-comment">// 模拟支付成功</span><br>        logger.info(<span class="hljs-string">&quot;贷款成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.negative(orderId, amount);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 还款，信用卡还款</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 单号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 状态码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">repayment</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟生成还款单</span><br>        logger.info(<span class="hljs-string">&quot;生成还款单，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-comment">// 模拟还款成功</span><br>        logger.info(<span class="hljs-string">&quot;还款成功，单号：&#123;&#125; 金额：&#123;&#125;&quot;</span>, orderId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.positive(orderId, amount);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>信用卡类在继承父类后，使用了公用的属性，即卡号 cardNo、开卡时间 cardDate，同时新增了符合信用卡功能的新方法，即贷款loan、还款repayment，并在两个方法中都使用了抽象类的核心功能。</p></li><li><p><strong>功能测试</strong></p><p><strong>测试信用卡</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_CreditCard</span><span class="hljs-params">()</span></span>&#123;<br>    CreditCard creditCard = <span class="hljs-keyword">new</span> CreditCard(<span class="hljs-string">&quot;6214567800989876&quot;</span>, <span class="hljs-string">&quot;2022-03-05&quot;</span>);<br>    <span class="hljs-comment">// 支付，贷款</span><br>    creditCard.loan(<span class="hljs-string">&quot;100001&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>    <span class="hljs-comment">// 还款</span><br>    creditCard.repayment(<span class="hljs-string">&quot;100001&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00.924</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CreditCard</span> - 生成贷款单，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00.927</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CreditCard</span> - 贷款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00.927</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.BankCard</span> - 卡号<span class="hljs-number">6214567800989876</span> 出款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00.927</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CreditCard</span> - 生成还款单，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00.927</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CreditCard</span> - 还款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00.927</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.BankCard</span> - 卡号<span class="hljs-number">6214567800989876</span> 入款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>测试储蓄卡</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_bankCard</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;里氏替换前，CashCard类：&quot;</span>);<br>    CashCard bankCard = <span class="hljs-keyword">new</span> CashCard(<span class="hljs-string">&quot;6214567800989876&quot;</span>, <span class="hljs-string">&quot;2022-03-05&quot;</span>);<br>    <span class="hljs-comment">// 提现</span><br>    bankCard.withdrawal(<span class="hljs-string">&quot;100001&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>    <span class="hljs-comment">// 储蓄</span><br>    bankCard.recharge(<span class="hljs-string">&quot;100001&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br><br>    logger.info(<span class="hljs-string">&quot;里氏替换后，CreditCard类：&quot;</span>);<br>    CashCard creditCard = <span class="hljs-keyword">new</span> CreditCard(<span class="hljs-string">&quot;6214567800989876&quot;</span>, <span class="hljs-string">&quot;2022-03-05&quot;</span>);<br>    <span class="hljs-comment">// 提现</span><br>    creditCard.withdrawal(<span class="hljs-string">&quot;100001&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">1000000</span>));<br>    <span class="hljs-comment">// 储蓄</span><br>    creditCard.recharge(<span class="hljs-string">&quot;100001&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.660</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 里氏替换前，CashCard类：<br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.664</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CashCard</span> - 提现成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.664</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.BankCard</span> - 卡号<span class="hljs-number">6214567800989876</span> 出款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.664</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CashCard</span> - 储蓄成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.664</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.BankCard</span> - 卡号<span class="hljs-number">6214567800989876</span> 入款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.664</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 里氏替换后，CreditCard类：<br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.665</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CashCard</span> - 提现成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">1000000</span><br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.665</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.BankCard</span> - 卡号<span class="hljs-number">6214567800989876</span> 出款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">1000000</span><br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.665</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.CashCard</span> - 储蓄成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br><span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">47.665</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.BankCard</span> - 卡号<span class="hljs-number">6214567800989876</span> 入款成功，单号：<span class="hljs-number">100001</span> 金额：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li></ol><p>通过以上两个测试结果可以看到，储蓄卡功能正常，继承储蓄卡实现的信用卡功能也正常。同时，原有储蓄卡类的功能可以由信用卡类支持，即 CashCard creditCard=new CreditCard（…）。</p><p>继承作为面向对象的重要特征，虽然给程序开发带来了非常大的便利，但也引入了一些弊端。继承的开发方式会给代码带来侵入性，可移植能力降低，类之间的耦合度较高。当对父类修改时，就要考虑一整套子类的实现是否有风险，测试成本较高。</p><p>里氏替换原则的目的是使用约定的方式，让使用继承后的代码具备良好的扩展性和兼容性。</p><p>在日常开发中使用继承的地方并不多，在有些公司的代码规范中也不会允许多层继承，尤其是一些核心服务的扩展。而继承大多数用在系统架构初期定义好的逻辑上或抽象出的核心功能里。如果使用了继承，就一定要遵从里氏替换原则，否则会让代码出现问题的概率变得更大。</p><h2 id="迪米特法则原则"><a href="#迪米特法则原则" class="headerlink" title="迪米特法则原则"></a>迪米特法则原则</h2><h3 id="迪米特法则定义"><a href="#迪米特法则定义" class="headerlink" title="迪米特法则定义"></a>迪米特法则定义</h3><p>迪米特法则（Law of Demeter，LoD）又称为最少知道原则（Least Knowledge Principle，LKP），是指一个对象类对于其他对象类来说，知道得越少越好。也就是说，两个类之间不要有过多的耦合关系，保持最少关联性。</p><p>迪米特法则有一句经典语录：只和朋友通信，不和陌生人说话。也就是说，有内在关联的类要内聚，没有直接关系的类要低耦合。这样的例子在我们生活中也随处可见，就像家里的水管装修，有洗衣机地漏、卫生间地漏、厨房地漏，但它们最终都汇到同一个污水处理系统里。在平常使用时，我们不会考虑这些水管是怎么关联流向的，只需要考虑最上层的使用即可。</p><h3 id="模拟场景-3"><a href="#模拟场景-3" class="headerlink" title="模拟场景"></a>模拟场景</h3><p>本书通过模拟学生、老师、校长之间关系的例子来说明迪米特法则。老师需要负责具体某一个学生的学习情况，而校长只会关心老师所在班级的总体成绩，不会去过问具体某一个学生的学习情况。</p><p>下面模拟这样的例子，如果校长想知道一个班级的总分和平均分，是应该找老师要，还是跟每一个学生要再进行统计呢？显然是应该找具体的班主任老师。我们在实际开发时，容易忽略这样的真实情况，开发出逻辑错误的程序。</p><h3 id="违背原则方案-3"><a href="#违背原则方案-3" class="headerlink" title="违背原则方案"></a>违背原则方案</h3><p>首先定义一个学生信息类，这个类比较简单，包括学生姓名、考试排名、总分。在实际的业务开发中会更复杂，这里只是简化后的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 学生姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rank;       <span class="hljs-comment">// 考试排名(总排名)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> grade;   <span class="hljs-comment">// 考试分数(总分)</span><br>    <br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后再定义出老师类，在老师类里初始化学生的信息，以及提供基本的信息获取接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;                <span class="hljs-comment">// 老师名称</span><br>    <span class="hljs-keyword">private</span> String clazz;               <span class="hljs-comment">// 班级</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Student&gt; studentList;  <span class="hljs-comment">// 学生</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name, String clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        studentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">589</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;豆豆&quot;</span>, <span class="hljs-number">54</span>, <span class="hljs-number">356</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;秋雅&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">439</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;皮皮&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">665</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;蛋蛋&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">502</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Student&gt; <span class="hljs-title">getStudentList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> studentList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClazz</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> clazz;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来定义校长类，校长管理全局，并在校长类中获取学生人数、总分、平均分等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Principal</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Teacher teacher = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;丽华&quot;</span>, <span class="hljs-string">&quot;3年1班&quot;</span>);<br><br>    <span class="hljs-comment">// 查询班级信息，学生人数、总分数、平均分</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">queryClazzInfo</span><span class="hljs-params">(String clazzId)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取班级信息；学生总人数、总分、平均分</span><br>        <span class="hljs-keyword">int</span> stuCount = clazzStudentCount();<br>        <span class="hljs-keyword">double</span> totalScore = clazzTotalScore();<br>        <span class="hljs-keyword">double</span> averageScore = clazzAverageScore();<br><br>        <span class="hljs-comment">// 组装对象，实际业务开发会有对应的类</span><br>        Map&lt;String, Object&gt; mapObj = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        mapObj.put(<span class="hljs-string">&quot;班级&quot;</span>, teacher.getClazz());<br>        mapObj.put(<span class="hljs-string">&quot;老师&quot;</span>, teacher.getName());<br>        mapObj.put(<span class="hljs-string">&quot;学生人数&quot;</span>, stuCount);<br>        mapObj.put(<span class="hljs-string">&quot;班级总分数&quot;</span>, totalScore);<br>        mapObj.put(<span class="hljs-string">&quot;班级平均分&quot;</span>, averageScore);<br>        <span class="hljs-keyword">return</span> mapObj;<br>    &#125;<br><br>    <span class="hljs-comment">// 总分</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">clazzTotalScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> totalScore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Student stu : Teacher.getStudentList()) &#123;<br>            totalScore += stu.getGrade();<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalScore;<br>    &#125;<br><br>    <span class="hljs-comment">// 平均分</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">clazzAverageScore</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">double</span> totalScore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Student stu : Teacher.getStudentList()) &#123;<br>            totalScore += stu.getGrade();<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalScore / Teacher.getStudentList().size();<br>    &#125;<br><br>    <span class="hljs-comment">// 班级人数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">clazzStudentCount</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Teacher.getStudentList().size();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是通过校长管理所有学生，老师只提供了非常简单的信息。虽然可以查询到结果，但是违背了迪米特法则，因为校长需要了解每个学生的情况，如果所有班级都让校长类统计，代码就会变得非常臃肿，也不易于维护和扩展。</p><h3 id="迪米特法则改善代码"><a href="#迪米特法则改善代码" class="headerlink" title="迪米特法则改善代码"></a>迪米特法则改善代码</h3><p>从以上的实现方式我们发现，不该让校长直接管理学生，应该让校长管理老师，再由老师提供相应的学生信息查询服务。那么，接下来我们就把校长要的信息交给老师类去处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;                <span class="hljs-comment">// 老师名称</span><br>    <span class="hljs-keyword">private</span> String clazz;               <span class="hljs-comment">// 班级</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Student&gt; studentList;  <span class="hljs-comment">// 学生</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name, String clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        studentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">589</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;豆豆&quot;</span>, <span class="hljs-number">54</span>, <span class="hljs-number">356</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;秋雅&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">439</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;皮皮&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">665</span>));<br>        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;蛋蛋&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">502</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 总分</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">clazzTotalScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> totalScore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Student stu : studentList) &#123;<br>            totalScore += stu.getGrade();<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalScore;<br>    &#125;<br><br>    <span class="hljs-comment">// 平均分</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">clazzAverageScore</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">double</span> totalScore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Student stu : studentList) &#123;<br>            totalScore += stu.getGrade();<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalScore / studentList.size();<br>    &#125;<br><br>    <span class="hljs-comment">// 班级人数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">clazzStudentCount</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> studentList.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Student&gt; <span class="hljs-title">getStudentList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> studentList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClazz</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> clazz;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用迪米特法则后，把原来违背迪米特法则的服务接口交给老师类处理。这样每一位老师都会提供相应的功能，校长类只需要调用使用即可，而不需要了解每一位学生的分数。</p><p>接下来再看校长类是如何使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Principal</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Teacher teacher = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;丽华&quot;</span>, <span class="hljs-string">&quot;3年1班&quot;</span>);<br><br>    <span class="hljs-comment">// 查询班级信息，总分数、学生人数、平均值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">queryClazzInfo</span><span class="hljs-params">(String clazzId)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取班级信息；学生总人数、总分、平均分</span><br>        <span class="hljs-keyword">int</span> stuCount = teacher.clazzStudentCount();<br>        <span class="hljs-keyword">double</span> totalScore = teacher.clazzTotalScore();<br>        <span class="hljs-keyword">double</span> averageScore = teacher.clazzAverageScore();<br><br>        <span class="hljs-comment">// 组装对象，实际业务开发会有对应的类</span><br>        Map&lt;String, Object&gt; mapObj = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        mapObj.put(<span class="hljs-string">&quot;班级&quot;</span>, teacher.getClazz());<br>        mapObj.put(<span class="hljs-string">&quot;老师&quot;</span>, teacher.getName());<br>        mapObj.put(<span class="hljs-string">&quot;学生人数&quot;</span>, stuCount);<br>        mapObj.put(<span class="hljs-string">&quot;班级总分数&quot;</span>, totalScore);<br>        mapObj.put(<span class="hljs-string">&quot;班级平均分&quot;</span>, averageScore);<br>        <span class="hljs-keyword">return</span> mapObj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>校长类直接调用老师类的接口，并获取相应的信息。这样一来，整个功能逻辑就非常清晰了。</p><p>使用单元测试验证程序结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_Principal</span><span class="hljs-params">()</span> </span>&#123;<br>        Principal principal = <span class="hljs-keyword">new</span> Principal();<br>        Map&lt;String, Object&gt; map = principal.queryClazzInfo(<span class="hljs-string">&quot;3年1班&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;查询结果：&#123;&#125;&quot;</span>, JSON.toJSONString(map));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">22</span>:<span class="hljs-number">39</span>:<span class="hljs-number">53.624</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 查询结果：&#123;<span class="hljs-string">&quot;学生人数&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;班级平均分&quot;</span>:<span class="hljs-number">510.2</span>,<span class="hljs-string">&quot;班级&quot;</span>:<span class="hljs-string">&quot;3年1班&quot;</span>,<span class="hljs-string">&quot;老师&quot;</span>:<span class="hljs-string">&quot;丽华&quot;</span>,<span class="hljs-string">&quot;班级总分数&quot;</span>:<span class="hljs-number">2551.0</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="接口隔离原则定义"><a href="#接口隔离原则定义" class="headerlink" title="接口隔离原则定义"></a>接口隔离原则定义</h3><p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>接口隔离是为了高内聚、低耦合。在实际的业务开发中，通常会先定义好需要开发的接口，并由各个服务类实现。但如果没有经过考虑和设计，就很可能造成一个接口中包括众多的接口方法，而这些接口并不一定在每一个类中都需要实现。这样的接口很难维护，也不易于扩展，每一次修改验证都有潜在的风险。</p><p>在具体应用接口隔离原则时，应该根据以下几个规则衡量：</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同，要深入了解业务逻辑。</li><li>提高内聚，减少对外交互。让接口用最少的方法完成最多的事情。</li></ul><h3 id="模拟场景-4"><a href="#模拟场景-4" class="headerlink" title="模拟场景"></a>模拟场景</h3><p>对于接口隔离的场景，在平时简单的业务开发中可能不会遇到，也可能体现得不明显。为了让大家更好地理解，举一个《王者荣耀》中英雄技能的例子，如果由你来开发这样的功能，会怎样设计？</p><p>《王者荣耀》里有很多英雄，可以分为射手、战士、刺客等，每个英雄有三种技能。这些技能该如何定义，让每个英雄实现相应的技能效果呢？接下来就分别使用两种不同的方式实现，来体现设计原则的应用。</p><h3 id="违背原则方案-4"><a href="#违背原则方案-4" class="headerlink" title="违背原则方案"></a>违背原则方案</h3><p>首先定义一个技能接口，所有的英雄都需要实现这个接口，进而实现自己的技能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISkill</span> </span>&#123;<br>    <span class="hljs-comment">// 射箭</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doArchery</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 隐袭</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doInvisible</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 沉默</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSilent</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 眩晕</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doVertigo</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里提供了四个技能的接口，包括射箭、隐袭、沉默、眩晕，每个英雄都实现这个接口。接下来实现两个英雄：后羿和廉颇。当然，这里为了说明问题而进行了简化，英雄技能只有三个，与真实游戏中有所差别。</p><p>英雄后裔，在英雄后羿的类中，实现了三个技能，最后一个眩晕的技能是不需要实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroHouYi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISkill</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doArchery</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后裔的灼日之矢&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInvisible</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后裔的隐身技能&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSilent</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后裔的沉默技能&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doVertigo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 无此技能的实现</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>英雄廉颇，在英雄廉颇的类中，同样只实现了三个技能，第一个射箭的技能没有实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroLianPo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISkill</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doArchery</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 无此技能的实现</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInvisible</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;廉颇的隐身技能&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSilent</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;廉颇的沉默技能&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doVertigo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;廉颇的眩晕技能&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>综上，每个英雄的实现类里都有一个和自己无关的接口实现类，非常不符合设计模式，也不易于维护。因为不仅无法控制外部的调用，还需要维护对应的文档，来说明这个接口不需要实现。如果有更多这样的接口，就会变得非常麻烦。</p><h3 id="接口隔离原则改善代码"><a href="#接口隔离原则改善代码" class="headerlink" title="接口隔离原则改善代码"></a>接口隔离原则改善代码</h3><p>按照接口隔离原则的约定，应该在确保合理的情况下，把接口细分。保证一个松散的结构，也就是把技能拆分出来，每个英雄都可以按需继承实现。</p><p>接下来分别定义四个技能接口，包括射箭（ISkillArchery）、隐身（ISkillInvisible）、沉默（ISkillSilent）、眩晕（ISkillVertigo）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISkillArchery</span> </span>&#123;<br>    <span class="hljs-comment">// 射箭</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doArchery</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISkillInvisible</span> </span>&#123;<br>    <span class="hljs-comment">// 隐袭</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doInvisible</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISkillSilent</span> </span>&#123;<br>    <span class="hljs-comment">// 沉默</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSilent</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISkillVertigo</span> </span>&#123;<br>    <span class="hljs-comment">// 眩晕</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doVertigo</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了四个技能细分的接口，英雄的类就可以自由地组合了。</p><p>英雄后羿的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroHouYi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISkillArchery</span>, <span class="hljs-title">ISkillInvisible</span>, <span class="hljs-title">ISkillSilent</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doArchery</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后裔的灼日之矢&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInvisible</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后裔的隐身技能&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSilent</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后裔的沉默技能&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>英雄廉颇的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroLianPo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISkillInvisible</span>, <span class="hljs-title">ISkillSilent</span>, <span class="hljs-title">ISkillVertigo</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInvisible</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;廉颇的隐身技能&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSilent</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;廉颇的沉默技能&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doVertigo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;廉颇的眩晕技能&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以看到这两个英雄的类都按需实现了自己需要的技能接口。这样的实现方式就可以避免一些本身不属于自己的技能还需要不断地用文档的方式进行维护，同时提高了代码的可靠性，在别人接手或者修改时，可以降低开发成本和维护风险。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><h3 id="依赖倒置原则定义"><a href="#依赖倒置原则定义" class="headerlink" title="依赖倒置原则定义"></a>依赖倒置原则定义</h3><p>依赖倒置原则（Dependence Inversion Principle，DIP）是指在设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，而细节应该依赖于抽象。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了类之间的耦合，提高了系统的稳定性和可维护性，同时这样的代码一般更易读，且便于传承。</p><h3 id="模拟场景-5"><a href="#模拟场景-5" class="headerlink" title="模拟场景"></a>模拟场景</h3><p>在互联网的营销活动中，经常为了拉新和促活，会做一些抽奖活动。这些抽奖活动的规则会随着业务的不断发展而调整，如随机抽奖、权重抽奖等。其中，权重是指用户在当前系统中的一个综合排名，比如活跃度、贡献度等。</p><p>下面模拟出抽奖的一个系统服务，如果是初次搭建这样的系统会怎么实现？这个系统是否有良好的扩展性和可维护性，同时在变动和新增业务时测试的复杂度是否高？这些都是在系统服务设计时需要考虑的问题。</p><h3 id="违背原则方案-5"><a href="#违背原则方案-5" class="headerlink" title="违背原则方案"></a>违背原则方案</h3><p>下面先用最直接的方式，即按照不同的抽奖逻辑定义出不同的接口，让外部的服务调用。</p><p>定义抽奖用户类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BetUser</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String userName;  <span class="hljs-comment">// 用户姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userWeight;   <span class="hljs-comment">// 用户权重</span><br><br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类就是一个普通的对象类，其中包括了用户姓名和对应的权重，方便满足不同的抽奖方式。</p><p>接下来实现两种不同的抽奖逻辑，在一个类中用两个接口实现， 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawControl</span> </span>&#123;<br><br>    <span class="hljs-comment">// 随机抽取指定数量的用户，作为中奖用户</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;BetUser&gt; <span class="hljs-title">doDrawRandom</span><span class="hljs-params">(List&lt;BetUser&gt; list, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-comment">// 集合数量很小直接返回</span><br>        <span class="hljs-keyword">if</span> (list.size() &lt;= count) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-comment">// 乱序集合</span><br>        Collections.shuffle(list);<br>        <span class="hljs-comment">// 取出指定数量的中奖用户</span><br>        List&lt;BetUser&gt; prizeList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(count);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            prizeList.add(list.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> prizeList;<br>    &#125;<br><br>    <span class="hljs-comment">// 权重排名获取指定数量的用户，作为中奖用户</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;BetUser&gt; <span class="hljs-title">doDrawWeight</span><span class="hljs-params">(List&lt;BetUser&gt; list, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-comment">// 按照权重排序</span><br>        list.sort((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> e = o2.getUserWeight() - o1.getUserWeight();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == e) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> e &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;);<br>        <span class="hljs-comment">// 取出指定数量的中奖用户</span><br>        List&lt;BetUser&gt; prizeList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(count);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            prizeList.add(list.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> prizeList;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个抽奖逻辑类中包括了两个接口，一个是随机抽奖，另一个是按照权重排序。</p><ul><li>随机抽取好理解，把集合中的元素使用工具包Collections.shuffle() 进行乱序，之后选取三个元素。当然，除了这样的随机抽取方式，还有其他方式。</li><li>按照权重排序，这里使用了list.sort的方法，并按排序逻辑的方式进行自定义排序。最终选择权重最高的前三名作为中奖用户。</li></ul><p>这里使用单元测试的方式，在初始化数据后分别调用两个接口方法进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_DrawControl</span><span class="hljs-params">()</span></span>&#123;<br>        List&lt;BetUser&gt; betUserList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-number">65</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;豆豆&quot;</span>, <span class="hljs-number">43</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-number">72</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;笨笨&quot;</span>, <span class="hljs-number">89</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;丑蛋&quot;</span>, <span class="hljs-number">10</span>));<br><br>        DrawControl drawControl = <span class="hljs-keyword">new</span> DrawControl();<br>        List&lt;BetUser&gt; prizeRandomUserList = drawControl.doDrawRandom(betUserList, <span class="hljs-number">3</span>);<br>        logger.info(<span class="hljs-string">&quot;随机抽奖，中奖用户名单：&#123;&#125;&quot;</span>, JSON.toJSON(prizeRandomUserList));<br><br>        List&lt;BetUser&gt; prizeWeightUserList = drawControl.doDrawWeight(betUserList, <span class="hljs-number">3</span>);<br>        logger.info(<span class="hljs-string">&quot;权重抽奖，中奖用户名单：&#123;&#125;&quot;</span>, JSON.toJSON(prizeWeightUserList));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">23</span>:<span class="hljs-number">23</span>:<span class="hljs-number">47.933</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 随机抽奖，中奖用户名单：<span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:43,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;豆豆&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:10,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;丑蛋&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:89,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;笨笨&quot;</span>&#125;]</span><br><span class="hljs-number">23</span>:<span class="hljs-number">23</span>:<span class="hljs-number">47.973</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 权重抽奖，中奖用户名单：<span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:89,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;笨笨&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:72,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;小白&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:65,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;花花&quot;</span>&#125;]</span><br></code></pre></td></tr></table></figure><p>从测试结果上看，程序没有问题，验证结果正常。但是这样实现有什么问题呢？</p><p>如果程序是一次性的、几乎不变的，那么可以不考虑很多的扩展性和可维护性因素；但如果这些程序具有不确定性，或者当业务发展时需要不断地调整和新增，那么这样的实现方式就很不友好了。</p><p>首先，这样的实现方式扩展起来很麻烦，每次扩展都需要新增接口，同时对于调用方来说需要新增调用接口的代码。其次，对于这个服务类来说，随着接口数量的增加，代码行数会不断地暴增，最后难以维护。</p><h3 id="依赖倒置原则改善代码"><a href="#依赖倒置原则改善代码" class="headerlink" title="依赖倒置原则改善代码"></a>依赖倒置原则改善代码</h3><p>既然上述方式不具备良好的扩展性，那么用依赖倒置、面向抽象编程的方式来实现。</p><p>首先定义抽奖功能的接口，任何一个实现方都可以实现自己的抽奖逻辑。</p><p><strong>抽奖接口</strong>：这里只有一个抽奖接口，接口中包括了需要传输的 list 集合，以及中奖用户数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDraw</span> </span>&#123;<br>    <span class="hljs-function">List&lt;BetUser&gt; <span class="hljs-title">prize</span><span class="hljs-params">(List&lt;BetUser&gt; list, <span class="hljs-keyword">int</span> count)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>随机抽奖实现</strong>：这部分随机抽奖逻辑与上面的抽奖方式逻辑是一样的，只不过放到接口实现中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawRandom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDraw</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;BetUser&gt; <span class="hljs-title">prize</span><span class="hljs-params">(List&lt;BetUser&gt; list, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-comment">// 集合数量很小直接返回</span><br>        <span class="hljs-keyword">if</span> (list.size() &lt;= count) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-comment">// 乱序集合</span><br>        Collections.shuffle(list);<br>        <span class="hljs-comment">// 取出指定数量的中奖用户</span><br>        List&lt;BetUser&gt; prizeList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(count);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            prizeList.add(list.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> prizeList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>权重抽奖实现</strong>：权重抽奖也是一样，把这些都放到自己的接口实现中。这样一来，任何一种抽奖都有自己的实现类，既可以不断地完善，也可以新增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawWeightRank</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDraw</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;BetUser&gt; <span class="hljs-title">prize</span><span class="hljs-params">(List&lt;BetUser&gt; list, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-comment">// 按照权重排序</span><br>        list.sort((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> e = o2.getUserWeight() - o1.getUserWeight();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == e) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> e &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;);<br>        <span class="hljs-comment">// 取出指定数量的中奖用户</span><br>        List&lt;BetUser&gt; prizeList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(count);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            prizeList.add(list.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> prizeList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建抽奖服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawControl</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IDraw draw;<br><br>    <span class="hljs-comment">//通过构造方法传递依赖关系 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DrawControl</span><span class="hljs-params">(IDraw draw)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.draw = draw;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;BetUser&gt; <span class="hljs-title">doDraw</span><span class="hljs-params">(List&lt;BetUser&gt; betUserList, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> draw.prize(betUserList, count);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中体现了依赖倒置的重要性，可以把任何一种抽奖逻辑传递给这个类。这样实现的好处是可以不断地扩展，但是不需要在外部新增调用接口，降低了一套代码的维护成本，并提高了可扩展性及可维护性。</p><p>单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_DrawControl</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;BetUser&gt; betUserList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-number">65</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;豆豆&quot;</span>, <span class="hljs-number">43</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-number">72</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;笨笨&quot;</span>, <span class="hljs-number">89</span>));<br>        betUserList.add(<span class="hljs-keyword">new</span> BetUser(<span class="hljs-string">&quot;丑蛋&quot;</span>, <span class="hljs-number">10</span>));<br><br>        DrawControl drawControl = <span class="hljs-keyword">new</span> DrawControl(<span class="hljs-keyword">new</span> DrawRandom());<br>        List&lt;BetUser&gt; prizeRandomUserList = drawControl.doDraw(betUserList, <span class="hljs-number">3</span>);<br>        logger.info(<span class="hljs-string">&quot;随机抽奖，中奖用户名单：&#123;&#125;&quot;</span>, JSON.toJSON(prizeRandomUserList));<br><br>        drawControl = <span class="hljs-keyword">new</span> DrawControl(<span class="hljs-keyword">new</span> DrawWeightRank());<br>        List&lt;BetUser&gt; prizeWeightUserList = drawControl.doDraw(betUserList, <span class="hljs-number">3</span>);<br>        logger.info(<span class="hljs-string">&quot;权重抽奖，中奖用户名单：&#123;&#125;&quot;</span>, JSON.toJSON(prizeWeightUserList));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">23</span>:<span class="hljs-number">41</span>:<span class="hljs-number">37.070</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 随机抽奖，中奖用户名单：<span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:89,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;笨笨&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:72,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;小白&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:10,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;丑蛋&quot;</span>&#125;]</span><br><span class="hljs-number">23</span>:<span class="hljs-number">41</span>:<span class="hljs-number">37.125</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ApiTest</span> - 权重抽奖，中奖用户名单：<span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:89,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;笨笨&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:72,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;小白&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;userWeight&quot;</span>:65,<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;花花&quot;</span>&#125;]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JDK8新特性笔记</title>
    <link href="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>创建一个新的线程，指定线程要执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//开启一个新的线程</span><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;新线程中执行的代码：&quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;).start();<br>        System.out.println(<span class="hljs-string">&quot;主线程中的代码：&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;新线程Lambda表达式：&quot;</span> + Thread.currentThread().getName());<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码分析：</p><ul><li>Thread类需要一个Runnable接口作为参数，其中的抽象方法run方法是用来指定线程任务内容的核心</li><li>为了指定run方法体，不得不需要一个Runnable的实现类</li><li>为了省去定义一个Runnable的实现类，不得不使用匿名内部类</li><li>必须覆盖重写抽象的run方法，所有的方法名称、方法参数、方法返回值都不得不重写一遍，而且不能出错</li><li>但是，在实际上我们只在乎方法体中的代码</li></ul><h2 id="Lambda表达式初体验"><a href="#Lambda表达式初体验" class="headerlink" title="Lambda表达式初体验"></a>Lambda表达式初体验</h2><p>Lambda表达式是一个匿名函数，可以理解为一段可以传递的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;新线程Lambda表达式：&quot;</span> + Thread.currentThread().getName());<br>&#125;).start();<br></code></pre></td></tr></table></figure><p>Lambda表达式的优点：简化了匿名内部类的使用，语法更简单。</p><p>匿名内部类语法冗余，体验了Lambda表达式后，发现Lambda表达式时简化匿名内部类的一种方式。</p><h2 id="Lambda语法规则"><a href="#Lambda语法规则" class="headerlink" title="Lambda语法规则"></a>Lambda语法规则</h2><p>lambda表达式使用场景(前提)：</p><ul><li>方法的参数或局部变量类型必须为接口才能使用Lambda</li><li>⼀个接口中只包含一个方法，则可以使用Lambda表达式，这样的接口称之为“函数接口” （@FunctionalInterface）</li></ul><p>语法： (params) -&gt; expression</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">第一部分 括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数<br>第二部分 一个箭头符号：-&gt;<br>第三部分 方法体，可以是表达式和代码块<br><br>参数列表 ：<br> 括号中参数列表的参数类型可以省略不写<br> 括号中的参数只有⼀个，那么参数类型和()都可以省略不写<br> <br>方法体：<br> 如果&#123;&#125;中的代码只有一行，无论是否有返回值，可以省略&#123;&#125;和<span class="hljs-keyword">return</span>及语句分号<br></code></pre></td></tr></table></figure><h3 id="Lambda练习1"><a href="#Lambda练习1" class="headerlink" title="Lambda练习1"></a>Lambda练习1</h3><p><strong>无参、无返回值的Lambda</strong></p><p>定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建主方法使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//匿名内部类</span><br>        goShow(<span class="hljs-keyword">new</span> UserService() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类 show方法执行了&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        <br>        <span class="hljs-comment">//Lambda表达式</span><br>        goShow(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Lambda show方法执行了&quot;</span>);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goShow</span><span class="hljs-params">(UserService userService)</span> </span>&#123;<br>        userService.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">匿名内部类 show方法执行了</span><br><span class="hljs-section">----------</span><br>Lambda show方法执行了<br></code></pre></td></tr></table></figure><h3 id="Lambda练习2"><a href="#Lambda练习2" class="headerlink" title="Lambda练习2"></a>Lambda练习2</h3><p><strong>有参、有返回值的Lambda</strong></p><p>创建一个Person对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Integer height;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在List集合中保存多个Person对象，然后对这些对象做根据age排序操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">165</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">170</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">175</span>));<br><br>        <span class="hljs-comment">//匿名内部类</span><br>        <span class="hljs-comment">/*Collections.sort(list, new Comparator&lt;Person&gt;() &#123;</span><br><span class="hljs-comment">            @Override</span><br><span class="hljs-comment">            public int compare(Person o1, Person o2) &#123;</span><br><span class="hljs-comment">                return o1.getAge() - o2.getAge();</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;);</span><br><span class="hljs-comment">        for (Person person : list) &#123;</span><br><span class="hljs-comment">            System.out.println(person);</span><br><span class="hljs-comment">        &#125;*/</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        <br>        <span class="hljs-comment">//Lambda表达式</span><br>        Collections.sort(list, (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span> (Person person : list) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Person(<span class="hljs-attribute">name</span>=张三, <span class="hljs-attribute">age</span>=18, <span class="hljs-attribute">height</span>=165)<br>Person(<span class="hljs-attribute">name</span>=王五, <span class="hljs-attribute">age</span>=20, <span class="hljs-attribute">height</span>=175)<br>Person(<span class="hljs-attribute">name</span>=李四, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">height</span>=170)<br></code></pre></td></tr></table></figure><h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@FunctionalInterface</span> 这是一个标志注解，被该注解修饰的接口只能声明一个抽象方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lambda表达式的原理"><a href="#Lambda表达式的原理" class="headerlink" title="Lambda表达式的原理"></a>Lambda表达式的原理</h2><p>匿名内部类的本质是在编译时生成一个Class文件，XXX$1.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//开启一个新的线程</span><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;新线程中执行的代码：&quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;).start();<br>        System.out.println(<span class="hljs-string">&quot;主线程中的代码：&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-comment">/*new Thread(() -&gt; &#123;</span><br><span class="hljs-comment">            System.out.println(&quot;新线程Lambda表达式：&quot; + Thread.currentThread().getName());</span><br><span class="hljs-comment">        &#125;).start();*/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-1.png" alt></p><p>还可以通过 javap 反编译来查看生成的代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">javap -c -<span class="hljs-selector-tag">p</span> 文件名<span class="hljs-selector-class">.class</span><br>-c:表示对代码进行反汇编<br>-<span class="hljs-selector-tag">p</span>:显示所有的类和成员<br></code></pre></td></tr></table></figure><p>反汇编的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">PS C:\IDEA\IdeaProjects\JDK8Test\target\classes\pers\lp\lambda&gt; javap -c -p Demo02Lambda.class<br>Compiled from <span class="hljs-string">&quot;Demo02Lambda.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pers</span>.<span class="hljs-title">lp</span>.<span class="hljs-title">lambda</span>.<span class="hljs-title">Demo02Lambda</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> pers.lp.lambda.Demo02Lambda();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokedynamic #<span class="hljs-number">2</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:show:()Lpers/lp/lambda/service/UserService;</span><br>       <span class="hljs-number">5</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method goShow:(Lpers/lp/lambda/service/UserService;)V</span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goShow</span><span class="hljs-params">(pers.lp.lambda.service.UserService)</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokeinterface #<span class="hljs-number">4</span>,  <span class="hljs-number">1</span>            <span class="hljs-comment">// InterfaceMethod pers/lp/lambda/service/UserService.show:()V</span><br>       <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>    Code:<br>       <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String Lambda show方法又执行了</span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在反编译的源码中我们看到了一个静态方法 <code>lambda$main$0()</code> 这个方法里面做了什么事情呢？我们通过debug的方式来查看下：</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-2.png" alt></p><p>可以发现方法体中的代码实在 lambda$main$0 中执行的。</p><p>上面的效果可以理解为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Lambda</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ……<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>()&#123;<br>        System.out.println(<span class="hljs-string">&quot;Lambda show方法又执行了&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更加直观的理解这个内容，我们可以在运行的时候添加</p><p><code>-Djdk.internal.lambda.dumpProxyClasses</code>这个参数会将内部class码输出到一个文件中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java -Djdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.lambda</span><span class="hljs-selector-class">.dumpProxyClasses</span> 要运行的包名.类名<br></code></pre></td></tr></table></figure><p>命令执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">E:\workspace\OpenClassWorkSpace\JDK8Demo\target\classes&gt;java -Djdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.lambda</span><span class="hljs-selector-class">.dumpProxyClasses</span> com<span class="hljs-selector-class">.bobo</span><span class="hljs-selector-class">.jdk</span><span class="hljs-selector-class">.lambda</span><span class="hljs-selector-class">.Demo03Lambda</span> Lambda <br></code></pre></td></tr></table></figure><p>show 方法执行了…</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-3.png" alt></p><p>反编译后的内容：</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-4.png" alt></p><p>可以看到这个匿名的内部类实现了UserService接口，并重写了show()方法。在show方法中调用了Demo03Lambda.lambda$main$0(),也就是调用了Lambda中的内容。</p><p>上面的效果可以理解为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03Lambda</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>goShow(<span class="hljs-keyword">new</span> UserService() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>Demo03Lambda.lambda$main$<span class="hljs-number">0</span>();<br>&#125;<br>&#125;);<br>System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goShow</span><span class="hljs-params">(UserService userService)</span></span>&#123;<br>userService.show();<br>&#125;<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>System.out.println(<span class="hljs-string">&quot;Lambda show 方法执行了...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><p>匿名内部类在编译的时候会产生一个class</p><p>Lambda表达式在程序运行的时候动态生成class</p><ol><li>在类中新增了一个方法，这个方法的方法体就是Lambda表达式中的代码</li><li>还会形成一个匿名内部类，实现接口，重写抽象方法</li><li>在接口中重写方法会调用新生成的方法</li></ol><h2 id="Lambda和匿名内部类的对比"><a href="#Lambda和匿名内部类的对比" class="headerlink" title="Lambda和匿名内部类的对比"></a>Lambda和匿名内部类的对比</h2><p>Lambda和匿名内部类的对比：</p><ol><li>所需类型不同：<ul><li>Lambda表达式需要的类型必须是<code>接口</code></li><li>匿名内部类的类型可以是 <code>类、抽象类、接口</code></li></ul></li><li>抽象方法的数量不同：<ul><li>Lambda表达式所需的接口中只能有<code>一个抽象方法</code></li><li>匿名内部类所需的接口中的<code>抽象方法的数量是任意的</code></li></ul></li><li>实现原理不同：<ul><li>Lambda表达式是在<code>程序运行时动态生成class</code></li><li>匿名内部类是在<code>编译后生成一个class</code></li></ul></li></ol><h1 id="接口中新增的方法"><a href="#接口中新增的方法" class="headerlink" title="接口中新增的方法"></a>接口中新增的方法</h1><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><p>在JDK8之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>静态常量;<br>抽象方法;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK8之后，对接口做了增强，接口中允许有默认方法和静态方法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">interface 接口名&#123;<br>静态常量<span class="hljs-comment">;</span><br>抽象方法<span class="hljs-comment">;</span><br>默认方法<span class="hljs-comment">;</span><br>静态方法<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p><strong>为什么要增加默认方法？</strong></p><p>在JDK8之前接口中只能有静态变量、抽象方法，会存在以下问题：</p><p>如果接口中新增抽象方法，那么实现类都必须要重写这个抽象方法，非常不利于接口的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Interface</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A a1 = <span class="hljs-keyword">new</span> B();<br>        A a2 = <span class="hljs-keyword">new</span> C();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//在接口中新增抽象方法，所有实现都都必须重写这个抽象方法</span><br>    <span class="hljs-comment">//不利于接口扩展</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口中默认方法的语法规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>    修饰符 <span class="hljs-keyword">default</span> 返回值类型 方法名&#123;<br>        方法体;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法通过实例调用吗，默认方法可以被继承，也可以重写接口中的默认方法。<strong>实例.默认方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Interface</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//实现类直接调用接口中的默认方法</span><br>        A a1 = <span class="hljs-keyword">new</span> B();<br>        a1.test3();<br>        <span class="hljs-comment">//实现类重写接口中的默认方法</span><br>        A a2 = <span class="hljs-keyword">new</span> C();<br>        a2.test3();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//在接口中新增抽象方法，所有实现都都必须重写这个抽象方法</span><br>    <span class="hljs-comment">//不利于接口扩展</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//接口中定义的默认方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接口中的默认方法执行了&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;C 实现类重写了默认方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CCC&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">接口中的默认方法执行了<br><span class="hljs-built_in">C</span> 实现类重写了默认方法<br></code></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>JDK8中为接口新增了静态方法，作用也是为了提高接口的扩展性。</p><p><strong>接口中静态方法的语法规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>    修饰符 <span class="hljs-keyword">static</span> 返回值类型 方法名&#123;<br>        方法体;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中的静态方法在实现类中是不能被重写的，因此调用的方式是：<strong>接口.静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Interface</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A a1 = <span class="hljs-keyword">new</span> B();<br>        a1.test3();<br>        A a2 = <span class="hljs-keyword">new</span> C();<br>        a2.test3();<br>        A.test4();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//在接口中新增抽象方法，所有实现都都必须重写这个抽象方法</span><br>    <span class="hljs-comment">//不利于接口扩展</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//接口中定义的默认方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接口中的默认方法执行了&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//接口中定义的静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接口中的静态方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;world&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;C 实现类重写了默认方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CCC&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">接口中的默认方法执行了<br><span class="hljs-built_in">C</span> 实现类重写了默认方法<br>接口中的静态方法<br></code></pre></td></tr></table></figure><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h2 id="函数式接口的由来"><a href="#函数式接口的由来" class="headerlink" title="函数式接口的由来"></a>函数式接口的由来</h2><p>我们知道使用Lambda表达式的前提是需要有函数式接口，而<strong>Lambda表达式使用时不关心接口名、抽象方法名，只关心抽象方法的参数列表和返回值类型</strong>。因此为了让我们使用Lambda表达式更方便，在JDK中提供了大量常用的函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Fun</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        fun1((arr) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>                sum += i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(Operator operator)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-keyword">int</span> sum = operator.getSum(arr);<br>        System.out.println(<span class="hljs-string">&quot;sum = &quot;</span> + sum);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Operator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数式接口介绍"><a href="#函数式接口介绍" class="headerlink" title="函数式接口介绍"></a>函数式接口介绍</h2><p>在JDK中帮我们提供的有函数式接口，主要是在 <code>java.util.function</code> 包中。</p><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p><strong>无参、有返回值的接口</strong>。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>来看看Supplier中的<code>get</code>方法的使用：</p><p>使用示例：计算出数组中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Supplier 函数式接口get的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupplierTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        fun1(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;;<br>            <span class="hljs-comment">//计算出数组中的最大值</span><br>            Arrays.sort(arr);<br>            <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(Supplier&lt;Integer&gt; supplier)</span> </span>&#123;<br>        <span class="hljs-comment">//get()是一个无参、有返回值的抽象方法</span><br>        Integer max = supplier.get();<br>        System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">max</span> = <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p><strong>有参、无返回值的接口</strong>。Consumer接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Performs this operation on the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; after)</span> </span>&#123;<br>        Objects.requireNonNull(after);<br>    <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先来看看Consumer中的<code>accept</code>方法的使用：</p><p>使用示例：将输入的数据统一转换为小写输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ConsumerTest 函数式接口accept的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str) -&gt; &#123;<br>            System.out.println(str + <span class="hljs-string">&quot;-&gt;转换为小写：&quot;</span> + str.toLowerCase());<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Consumer&lt;String&gt; consumer)</span> </span>&#123;<br>        consumer.accept(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">H<span class="hljs-function"><span class="hljs-title">ello</span> World-&gt;</span>转换为小写：hello world<br></code></pre></td></tr></table></figure><p>接着看看Consumer中的默认方法<code>andThen</code>的使用：</p><p>如果一个方法的参数和返回值全部是Consumer类型，那么就可以实现消费一个数据的时候，首先做一个操作，然后再做一个操作，实现组合。</p><p>使用示例：将输入的数据统一转换为大写输出，然后转换为小写输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ConsumerTest 函数式接口andThen的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerAndThenTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str1) -&gt; &#123;<br>            System.out.println(str1 + <span class="hljs-string">&quot;转换为小写：&quot;</span> + str1.toLowerCase());<br>        &#125;, (str2) -&gt; &#123;<br>            System.out.println(str2 + <span class="hljs-string">&quot;转换为大写：&quot;</span> + str2.toUpperCase());<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Consumer&lt;String&gt; c1, Consumer&lt;String&gt; c2)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>        <span class="hljs-comment">//转换为小写</span><br><span class="hljs-comment">//c1.accept(str);</span><br>        <span class="hljs-comment">//转换为大写</span><br><span class="hljs-comment">//c2.accept(str);</span><br>        <span class="hljs-comment">//先转小写，然后转大写</span><br><span class="hljs-comment">//c1.andThen(c2).accept(str);</span><br>        <span class="hljs-comment">//先转大写，然后转小写</span><br>        c2.andThen(c1).accept(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Hello</span> World转换为大写：HELLO WORLD<br>Hello World转换为小写：hello world<br></code></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><strong>有参、有返回值的接口</strong>。根据一个类型的数据得到另一个类型的数据，前者为前置条件，后者为后置条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Applies this function to the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the function argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the function result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br>    <br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先来看看Function中的<code>apply</code>方法的使用：</p><p>使用示例：传递一个字符串返回一个数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * FunctionTest 函数式接口apply的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(msg -&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.valueOf(msg);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Function&lt;String, Integer&gt; function)</span> </span>&#123;<br>        Integer apply = function.apply(<span class="hljs-string">&quot;666&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;apply = &quot;</span> + apply);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法 <code>andThen</code> 也是用来进行组合操作的：</p><p>使用示例：传递一个字符串得到一个数值，再从数值得到一个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * FunctionTest 函数式接口andThen的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionAndThenTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((msg1) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.valueOf(msg1);<br>        &#125;, (msg2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> String.valueOf(msg2);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Function&lt;String, Integer&gt; f1, Function&lt;Integer, String&gt; f2)</span> </span>&#123;<br>        String apply = f1.andThen(f2).apply(<span class="hljs-string">&quot;666&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;apply = &quot;</span> + apply);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法 <code>compose</code> 的作用顺序与  <code>andThen</code> 方法正好相反。</p><p>静态方法 <code>identity</code> 则是，输入什么参数就返回什么参数</p><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p><strong>有参、有返回值（boolean）的接口</strong>。对某种类型的数据进行判断，从而得到一个boolean值结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Evaluates this predicate on the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if the input argument matches the predicate,</span><br><span class="hljs-comment">     * otherwise &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先来看看Predicate中的<code>test</code>方法的使用：</p><p>使用示例：判断字符串的长度是否超过5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Predicate 函数式接口test的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredicateTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> str.length() &gt; <span class="hljs-number">5</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> b = predicate.test(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串长度超过5了吗？&quot;</span> + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">字符串长度超过<span class="hljs-number">5</span>了吗？<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>在Predicate中还有 <code>and</code> <code>or</code> <code>negate</code> 默认方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Predicate 函数式接口默认方法 and or negate</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredicateDefaultTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str1) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> str1.contains(<span class="hljs-string">&quot;H&quot;</span>);<br>        &#125;, (str2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> str2.contains(<span class="hljs-string">&quot;W&quot;</span>);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2)</span> </span>&#123;<br>        <span class="hljs-comment">//p1包含H 同时 p2包含W</span><br>        <span class="hljs-keyword">boolean</span> b1 = p1.and(p2).test(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.out.println(b1);<br>        <span class="hljs-comment">//p1包含H 或者 p2包含W</span><br>        <span class="hljs-keyword">boolean</span> b2 = p1.or(p2).test(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.out.println(b2);<br>        <span class="hljs-comment">//p1不包含H</span><br>        <span class="hljs-keyword">boolean</span> b3 = p1.negate().test(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.out.println(b3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h2 id="为什么使用方法引用"><a href="#为什么使用方法引用" class="headerlink" title="为什么使用方法引用"></a>为什么使用方法引用</h2><p>在使用Lambda表达式的时候，也会出现代码冗余的情况。</p><p>比如：用Lambda表达式求一个数组的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        printElement((arr) -&gt; &#123;<br>            <span class="hljs-comment">//Lambda表达式中的代码和getTotal中的代码冗余了</span><br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>                sum += i;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;数组之和：&quot;</span> + sum);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">//求数组中的所有元素的和</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTotal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数组之和：&quot;</span> + sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printElement</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">int</span>[]&gt; consumer)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;;<br>        consumer.accept(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现Lambda表达式中要执行的代码和我们另外一个方法中的代码是一样的，这时就没有必要重写这一份逻辑了， 于是我们可以“引用”重复代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// :: 方法引用</span><br>        printElement(FunctionRefTest02::getTotal);<br>    &#125;<br><br>    <span class="hljs-comment">//求数组中的所有元素的和</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTotal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数组之和：&quot;</span> + sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printElement</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">int</span>[]&gt; consumer)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;;<br>        consumer.accept(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法引用语法规则"><a href="#方法引用语法规则" class="headerlink" title="方法引用语法规则"></a>方法引用语法规则</h2><p>符号表示：<code>::</code></p><p>符号说明：双冒号是方法引用运算符，而它所在的表达式被称为<code>方法引用</code></p><p>应用场景：如果Lambda表达式所要实现的方案，已经有其他方法存在相同的方案，那么则可以使用方法引用。</p><p>常见的引用方式：</p><ol><li><strong>instanceName::methodName 对象::方法名</strong></li><li><strong>ClassName::staticMethodName 类名::静态方法</strong></li><li><strong>ClassName::methodName 类名::普通方法</strong></li><li><strong>ClassName::new    类名::new 调用的构造器</strong></li><li><strong>TypeName[]::new    数组类型[]::new 调用数组的构造器</strong></li></ol><blockquote><p>注意事项：</p><ol><li>被引用的方法，参数要和接口中的抽象方法的参数一样</li><li>当接口抽象方法有返回值时，被引用的方法也必须有返回值</li></ol></blockquote><h3 id="对象-方法名"><a href="#对象-方法名" class="headerlink" title="对象::方法名"></a>对象::方法名</h3><p>如果一个类中已经存在了一个成员方法，则可以通过对象名引用成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        Supplier&lt;Long&gt; supplier1 = () -&gt; &#123;<br>            <span class="hljs-keyword">return</span> date.getTime();<br>        &#125;;<br>        System.out.println(supplier1.get());<br>        <span class="hljs-comment">//方法引用</span><br>        Supplier&lt;Long&gt; supplier2 = date::getTime;<br>        System.out.println(supplier2.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类名-静态方法"><a href="#类名-静态方法" class="headerlink" title="类名::静态方法"></a>类名::静态方法</h3><p>也是比较常用的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest04</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Long&gt; supplier1 = () -&gt; &#123;<br>            <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>        &#125;;<br>        System.out.println(supplier1.get());<br>        <span class="hljs-comment">//方法引用</span><br>        Supplier&lt;Long&gt; supplier2 = System::currentTimeMillis;<br>        System.out.println(supplier2.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类名-普通方法"><a href="#类名-普通方法" class="headerlink" title="类名::普通方法"></a>类名::普通方法</h3><p> Java面向对象中，类名只能调用静态方法，而在方法引用中却可以类名引用实例方法。</p><p>当然使用这种形式也是有前提的，<strong>用第一个参数作为方法的调用者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest05</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;String, Integer&gt; function1 = (s) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> s.length();<br>        &#125;;<br>        System.out.println(function1.apply(<span class="hljs-string">&quot;hello&quot;</span>));<br>        <span class="hljs-comment">//方法引用</span><br>        Function&lt;String, Integer&gt; function2 = String::length;<br>        System.out.println(function2.apply(<span class="hljs-string">&quot;world&quot;</span>));<br><br>        BiFunction&lt;String, Integer, String&gt; biFunction = String::substring;<br>        String str = biFunction.apply(<span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-number">3</span>);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类名-构造器"><a href="#类名-构造器" class="headerlink" title="类名::构造器"></a>类名::构造器</h3><p> 由于构造器的名称和类名完全一致，所以构造器引用要使用 <code>::new</code> 的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest06</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Person&gt; supplier1 = () -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();<br>        &#125;;<br>        System.out.println(supplier1.get());<br>        <span class="hljs-comment">//方法引用</span><br>        Supplier&lt;Person&gt; supplier2 = Person::<span class="hljs-keyword">new</span>;<br>        System.out.println(supplier2.get());<br>        BiFunction&lt;String, Integer, Person&gt; function = Person::<span class="hljs-keyword">new</span>;<br>        System.out.println(function.apply(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组-构造器"><a href="#数组-构造器" class="headerlink" title="数组::构造器"></a>数组::构造器</h3><p>数组是怎么构造出来的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest07</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;Integer, String[]&gt; function1 = (len) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[len];<br>        &#125;;<br>        String[] a1 = function1.apply(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;数组的长度是：&quot;</span> + a1.length);<br>        <span class="hljs-comment">//方法引用</span><br>        Function&lt;Integer, String[]&gt; function2 = String[]::<span class="hljs-keyword">new</span>;<br>        String[] a2 = function2.apply(<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;数组的长度是：&quot;</span> + a2.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小结：方法引用是对Lambda表达式在符合特定情况下的一种缩写方式，它使得我们的Lambda表达式更加的精简，也可以理解为lambda表达式的缩写形式，不过要注意的是方法引用只能引用已经存在的方法。</p></blockquote><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><h2 id="集合处理数据的弊端"><a href="#集合处理数据的弊端" class="headerlink" title="集合处理数据的弊端"></a>集合处理数据的弊端</h2><p>当我们在需要对集合中的元素进行操作的时候，除了必须的添加、删除、获取外，最典型的操作就是集合遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个List集合</span><br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;成龙&quot;</span>, <span class="hljs-string">&quot;周星驰&quot;</span>);<br>        <span class="hljs-comment">//1、先获取所有姓张的信息</span><br>        List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list) &#123;<br>            <span class="hljs-keyword">if</span> (s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)) &#123;<br>                list1.add(s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//2、再获取名字长度为3的用户</span><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list1) &#123;<br>            <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">3</span>) &#123;<br>                list2.add(s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//3、输出符合前两个条件的用户信息</span><br>        <span class="hljs-keyword">for</span> (String s : list2) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码针对于不同的需求必须一次次的循环，这时我们希望有高效的处理方式，这时我们就可以通过JDK8中提供的Stream API来解决。</p><p>Stream更加优雅的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个List集合</span><br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;成龙&quot;</span>, <span class="hljs-string">&quot;周星驰&quot;</span>);<br>        <span class="hljs-comment">//1、先获取所有姓张的信息</span><br>        <span class="hljs-comment">//2、再获取名字长度为3的用户</span><br>        <span class="hljs-comment">//3、输出符合前两个条件的用户信息</span><br>        list.stream()<br>                .filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>                .filter(s -&gt; s.length() == <span class="hljs-number">3</span>)<br>                .forEach(s -&gt; System.out.println(s));<br>        System.out.println(<span class="hljs-string">&quot;-----方法引用-----&quot;</span>);<br>        list.stream()<br>                .filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>                .filter(s -&gt; s.length() == <span class="hljs-number">3</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的Stream API代码的含义：获取流、过滤张、过滤长度3，逐一打印。代码相比于之前的不断循环更加的简洁直观。</p><h2 id="Stream流式思想"><a href="#Stream流式思想" class="headerlink" title="Stream流式思想"></a>Stream流式思想</h2><blockquote><p>注意：Stream和IO流(InputStream/OutputStream)没有任何关系，请暂时忘记对传统IO流的固有印 象！</p></blockquote><p>Stream流式思想类似于工厂车间的“生产流水线”，Stream流不是一种数据结构，不保存数据，而是对数 据进行加工 处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商 品。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-5.png" alt></p><p>Stream API能让我们快速完成许多复杂的操作，如筛选、切片、映射、查找、去除重复，统计，匹配和 归约。</p><h2 id="Stream流的获取方式"><a href="#Stream流的获取方式" class="headerlink" title="Stream流的获取方式"></a>Stream流的获取方式</h2><p>获取一个Stream流非常简单，常见的有两种获取方式：</p><ol><li>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取；</li><li><code>Stream</code>接口的静态方法<code>of</code>可以获取对应的流；</li></ol><h3 id="根据Collection集合中的stream方法获取"><a href="#根据Collection集合中的stream方法获取" class="headerlink" title="根据Collection集合中的stream方法获取"></a>根据Collection集合中的stream方法获取</h3><p>首先 <code>java.util.Collection</code> 接口中加入了default方法 stream，也就是说Collection接口下的所有的实现都可以通过steam方法来获取Stream流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; lits = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        lits.stream();<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        set.stream();<br>        Vector vector = <span class="hljs-keyword">new</span> Vector();<br>        vector.stream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是Map接口没有实现Collection接口，这时我们可以根据Map获取对应的key-value的集合再来获取Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest04</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//key</span><br>        Stream&lt;String&gt; stream1 = map.keySet().stream();<br>        <span class="hljs-comment">//value</span><br>        Stream&lt;Object&gt; stream2 = map.values().stream();<br>        <span class="hljs-comment">//entry</span><br>        Stream&lt;Map.Entry&lt;String, Object&gt;&gt; stream3 = map.entrySet().stream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据Stream接口中的静态方法of方法获取"><a href="#根据Stream接口中的静态方法of方法获取" class="headerlink" title="根据Stream接口中的静态方法of方法获取"></a>根据Stream接口中的静态方法of方法获取</h3><p>由于数组对象不可能添加默认方法，所以<code>Stream</code>接口中提供了静态方法<code>of</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest05</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过Stream的of方法获取</span><br>        Stream&lt;String&gt; a = Stream.of(<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-string">&quot;a3&quot;</span>);<br>        a.forEach(System.out::println);<br><br>        String[] arr1 = &#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>&#125;;<br>        Stream&lt;String&gt; arr11 = Stream.of(arr1);<br>        arr11.forEach(System.out::println);<br><br>        Integer[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        Stream&lt;Integer&gt; arr22 = Stream.of(arr2);<br>        arr22.forEach(System.out::println);<br><br>        <span class="hljs-comment">//注意：基本数据类型的数组是不行的</span><br>        <span class="hljs-keyword">int</span>[] arr3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        Stream&lt;<span class="hljs-keyword">int</span>[]&gt; arr33 = Stream.of(arr3);<br>        arr33.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">a1</span><br><span class="hljs-built_in">a2</span><br><span class="hljs-built_in">a3</span><br>aa<br><span class="hljs-keyword">bb</span><br><span class="hljs-keyword"></span>cc<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>[I@<span class="hljs-number">36</span>d64342<br><br>进程已结束,退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="Stream流常用方法介绍"><a href="#Stream流常用方法介绍" class="headerlink" title="Stream流常用方法介绍"></a>Stream流常用方法介绍</h2><p>Stream流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>方法作用</th><th>返回值类型</th><th>方法种类</th></tr></thead><tbody><tr><td>count</td><td>统计个数</td><td>long</td><td>终结</td></tr><tr><td>forEach</td><td>逐一处理</td><td>void</td><td>终结</td></tr><tr><td>filter</td><td>过滤</td><td>Stream</td><td>函数拼接</td></tr><tr><td>limit</td><td>取用前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>skip</td><td>跳过前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>map</td><td>映射</td><td>Stream</td><td>函数拼接</td></tr><tr><td>concat</td><td>组合</td><td>Stream</td><td>函数拼接</td></tr></tbody></table></div><p><strong>终结方法</strong>：返回值类型不再是 Stream 类型的方法，不再支持链式调用。终结方法包括 <code>count</code> 和 <code>forEach</code> 方法。</p><p><strong>非终结方法</strong>：返回值类型仍然是 Stream 类型的方法，支持链式调用。（除了终结方法外，其余方法均为非终结方法。）</p><p><strong>Stream注意事项(重要)</strong> </p><ol><li>Stream只能操作一次</li><li>Stream方法返回的是新的流</li><li>Stream不调用终结方法，中间的操作不会执行</li></ol><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>Stream流中的count方法用来统计其中的元素个数的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>该方法返回一个long值，代表元素的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamCount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> count = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>).count();<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream流中的forEach方法用来遍历流中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>该方法接受一个Consumer接口，会将每一个流元素交给函数处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamforEach</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>c<br></code></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Stream流中的filter方法用于过滤数据，返回符合条件的数据。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-6.png" alt></p><p>可以通过filter方法将一个流转换成另一个子集流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><p>该接口接收一个Predicate函数式接口参数作为筛选条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamFilter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)<br>                .filter(s -&gt; s.contains(<span class="hljs-string">&quot;b&quot;</span>))<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">b</span><br><span class="hljs-symbol">bb</span><br></code></pre></td></tr></table></figure><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>Stream流中的limit方法可以对流进行截取处理，获取前n个数据。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br></code></pre></td></tr></table></figure><p>参数是一个long类型的数值，如果集合当前长度大于参数就进行截取，否则不操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamLimit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)<br>                .limit(<span class="hljs-number">3</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>c<br></code></pre></td></tr></table></figure><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>Stream流中的skip方法用于跳过前面几个元素，获取后面的元素</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure><p>操作实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamSkip</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)<br>                .skip(<span class="hljs-number">3</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">aa<br>bb<br>cc<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Stream流中的map方法用于将流中的元素映射到另一个流中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">Stream&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends R&gt; mapper)</span></span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-9.png" alt></p><p>该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMap</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>)<br>                <span class="hljs-comment">//.map(s -&gt; Integer.valueOf(s))</span><br>                .map(Integer::valueOf)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>Stream流中的sorted方法用于将数据排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure><p>在使用的时候可以根据自然规则排序，也可以根据比较器指定的规则来排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamSorted</span> </span>&#123;<br>    <span class="hljs-comment">// sorted(): 根据元素的自然顺序排序</span><br>    <span class="hljs-comment">// sorted(Comparator&lt;? super T&gt; comparator): 根据比较器指定的规则排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>                <span class="hljs-comment">//.sorted()</span><br>                .sorted((o1, o2) -&gt; o2 - o1)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>4<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>Stream流中的distinct方法用于去掉重复数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">distinct</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-10.png" alt></p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDistinct</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>).distinct().forEach(System.out::println);<br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        Stream.of(<br>                <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>),<br>                <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>),<br>                <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>))<br>                .distinct()<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1<br>5<br>8<br>4<br>7<br>3<br>----------<br>执行有参构造：张三,18<br>执行有参构造：李四,19<br>执行有参构造：张三,20<br>Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-attribute">age</span>=19&#125;<br>Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attribute">age</span>=20&#125;<br></code></pre></td></tr></table></figure><p>Stream流中的distinct方法对于基本数据类型是可以直接出重的，但是对于自定义类型，我们是必须重写hashCode和equals方法来移除重复元素。</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>Stream流中的match方法用于判断数据是否匹配指定的条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 元素是否有任意一个满足条件</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">anyMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br><span class="hljs-comment">// 元素是否都满足条件</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>; <br><span class="hljs-comment">// 元素是否都不满足条件</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">noneMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>; <br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMatch</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> b = Stream.of(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>                <span class="hljs-comment">//.anyMatch(e -&gt; e &gt; 4);</span><br>                <span class="hljs-comment">//.allMatch(e -&gt; e &gt; 4);</span><br>                .noneMatch(e -&gt; e &lt; <span class="hljs-number">0</span>);<br>        System.out.println(b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>Stream流中的find方法用于找到某些数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">findFirst</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">findAny</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-11.png" alt></p><blockquote><p>注意：</p><p>findFirst总能保证找到第一个元素，</p><p>findAny在并行操作中，可能会返回Stream中的第一个元素，但不能保证</p></blockquote><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamFind</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Optional&lt;Integer&gt; first = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).findFirst();<br>        System.out.println(<span class="hljs-string">&quot;first = &quot;</span> + first.get());<br><br>        Optional&lt;Integer&gt; any = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).findAny();<br>        System.out.println(<span class="hljs-string">&quot;any = &quot;</span> + any.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="max、min"><a href="#max、min" class="headerlink" title="max、min"></a>max、min</h3><p>Stream流中的max、min方法用于获取最大值和最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">max</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">min</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMaxMin</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Optional&lt;Integer&gt; max = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).max((o1, o2) -&gt; o1 - o2);<br>        System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + max);<br>        Optional&lt;Integer&gt; min = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).min((o1, o2) -&gt; o1 - o2);<br>        System.out.println(<span class="hljs-string">&quot;min = &quot;</span> + min);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>Stream流中的reduce方法用于将所有数据归纳得到一个数据</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamReduce</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer reduce1 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>                .reduce(<span class="hljs-number">0</span>, (x, y) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;x = &quot;</span> + x + <span class="hljs-string">&quot;, y = &quot;</span> + y);<br>                    <span class="hljs-keyword">return</span> x + y;<br>                &#125;);<br>        <span class="hljs-comment">// reduce:</span><br>        <span class="hljs-comment">// 第一次将默认做赋值给x, 取出第一个元素赋值给y,进行操作</span><br>        <span class="hljs-comment">// 第二次,将第一次的结果赋值给x, 取出二个元素赋值给y,进行操作</span><br>        <span class="hljs-comment">// 第三次,将第二次的结果赋值给x, 取出三个元素赋值给y,进行操作</span><br>        <span class="hljs-comment">// 第四次,将第三次的结果赋值给x, 取出四个元素赋值给y,进行操作</span><br>        System.out.println(<span class="hljs-string">&quot;reduce1 = &quot;</span> + reduce1);<br><br>        <span class="hljs-keyword">int</span> reduce2 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(<span class="hljs-string">&quot;reduce3 = &quot;</span> + reduce2);<br><br>        <span class="hljs-comment">//获取最大值</span><br>        <span class="hljs-keyword">int</span> max = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::max);<br>        System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = <span class="hljs-number">0</span>, y = <span class="hljs-number">1</span><br><span class="hljs-attr">x</span> = <span class="hljs-number">1</span>, y = <span class="hljs-number">3</span><br><span class="hljs-attr">x</span> = <span class="hljs-number">4</span>, y = <span class="hljs-number">1</span><br><span class="hljs-attr">x</span> = <span class="hljs-number">5</span>, y = <span class="hljs-number">4</span><br><span class="hljs-attr">reduce1</span> = <span class="hljs-number">9</span><br><span class="hljs-attr">reduce3</span> = <span class="hljs-number">9</span><br><span class="hljs-attr">max</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="map、reduce组合使用"><a href="#map、reduce组合使用" class="headerlink" title="map、reduce组合使用"></a>map、reduce组合使用</h3><p>在实际开发中我们经常会将map和reduce一块来使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMapReduce</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1、求出所有年龄的总和</span><br>        Integer sumAge = Stream.of(<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">21</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>)<br>                        <span class="hljs-comment">//实现数据类型的转换</span><br>                ).map(Person::getAge)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(<span class="hljs-string">&quot;sumAge = &quot;</span> + sumAge);<br><br>        <span class="hljs-comment">//2、求出所有年龄中的最大值</span><br>        Integer maxAge = Stream.of(<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">21</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>)<br>                        <span class="hljs-comment">//实现数据类型的转换,符合reduce对数据的要求</span><br>                ).map(Person::getAge)<br>                <span class="hljs-comment">//reduce实现数据的处理</span><br>                .reduce(<span class="hljs-number">0</span>, Math::max);<br>        System.out.println(<span class="hljs-string">&quot;maxAge = &quot;</span> + maxAge);<br><br>        <span class="hljs-comment">//3、统计字符a的出现次数</span><br>        Integer count = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br>                .map(ch -&gt; <span class="hljs-string">&quot;a&quot;</span>.equals(ch) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">sumAge</span> = <span class="hljs-number">100</span><br><span class="hljs-attr">maxAge</span> = <span class="hljs-number">22</span><br><span class="hljs-attr">count</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="mapToInt"><a href="#mapToInt" class="headerlink" title="mapToInt"></a>mapToInt</h3><p>Stream流中的mapToInt方法用于将Stream中的Integer类型转换成int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">IntStream <span class="hljs-title">mapToInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-keyword">super</span> T&gt; mapper)</span></span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-14.png" alt></p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMapToInt</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//Integer占用的内存比int多很多，在Stream流操作中会自动装箱和拆箱</span><br>        Stream&lt;Integer&gt; stream = Arrays.stream(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;);<br><br>        <span class="hljs-comment">//不必要的拆箱</span><br>        <span class="hljs-comment">/*Integer result1 = stream</span><br><span class="hljs-comment">                .filter(i -&gt; i.intValue() &gt; 3)</span><br><span class="hljs-comment">                .reduce(0, Integer::sum);</span><br><span class="hljs-comment">        System.out.println(result1);*/</span><br><br>        <span class="hljs-comment">//自动拆箱</span><br>        <span class="hljs-comment">/*Integer result2 = stream</span><br><span class="hljs-comment">                .filter(i -&gt; i &gt; 3)</span><br><span class="hljs-comment">                .reduce(0, Integer::sum);</span><br><span class="hljs-comment">        System.out.println(result2);*/</span><br><br>        <span class="hljs-comment">//可以先将流中Integer数据转换为int数据，后续直接操作int类型</span><br>        IntStream intStream1 = stream.mapToInt(Integer::intValue);<br>        <span class="hljs-keyword">int</span> result3 = intStream1<br>                .filter(i -&gt; i &gt; <span class="hljs-number">3</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(result3);<br><br>        <span class="hljs-comment">//将IntStream转化为Stream&lt;Integer&gt;</span><br>        <span class="hljs-comment">//IntStream rangeClosed(int startInclusive，int endInclusive)</span><br>        <span class="hljs-comment">//以增量步长1返回一个从startInclusive(包括)到endInclusive(包括)的IntStream</span><br>        IntStream intStream2 = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        Stream&lt;Integer&gt; boxed = intStream2.boxed();<br>        boxed.forEach(s -&gt; System.out.println(s.getClass() + <span class="hljs-string">&quot;,&quot;</span> + s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">15</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">3</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>Stream流中的concat方法用于将两个流合并成为一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">concat</span><span class="hljs-params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span> </span>&#123;<br>    Objects.requireNonNull(a);<br>    Objects.requireNonNull(b);<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    Spliterator&lt;T&gt; split = <span class="hljs-keyword">new</span> Streams.ConcatSpliterator.OfRef&lt;&gt;(<br>            (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());<br>    Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());<br>    <span class="hljs-keyword">return</span> stream.onClose(Streams.composedClose(a, b));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p></blockquote><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamConcat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>        Stream&lt;String&gt; stream2 = Stream.of(<span class="hljs-string">&quot;李四&quot;</span>);<br>        Stream.concat(stream1, stream2).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">张三<br>李四<br></code></pre></td></tr></table></figure><h3 id="Stream综合案例"><a href="#Stream综合案例" class="headerlink" title="Stream综合案例"></a>Stream综合案例</h3><p>现在有两个<code>ArrayList</code>集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行下列若干操作：</p><ol><li>第一个队伍只要名字为3个字的成员姓名；</li><li>第一个队伍筛选之后只要前3个人；</li><li>第二个队伍只要姓张的成员姓名；</li><li>第二个队伍筛选之后不要前2个人；</li><li>将两个队伍合并为一个队伍；</li><li>根据姓名创建<code>Person</code>对象；</li><li>打印整个队伍的<code>Person</code>对象信息。</li></ol><p>两个队伍（集合）的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamCase</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list1 = Arrays.asList(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>,<br>                <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>, <span class="hljs-string">&quot;洪七 公&quot;</span>);<br>        List&lt;String&gt; list2 = Arrays.asList(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;赵丽颖&quot;</span>,<br>                <span class="hljs-string">&quot;张二狗&quot;</span>, <span class="hljs-string">&quot;张天爱&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Person</code>类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Stream实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamCase</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list1 = Arrays.asList(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>,<br>                <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>, <span class="hljs-string">&quot;洪七 公&quot;</span>);<br>        List&lt;String&gt; list2 = Arrays.asList(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;赵丽颖&quot;</span>,<br>                <span class="hljs-string">&quot;张二狗&quot;</span>, <span class="hljs-string">&quot;张天爱&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        <span class="hljs-comment">// 1. 第一个队伍只保留姓名长度为3的成员</span><br>        <span class="hljs-comment">// 2. 第一个队伍筛选之后只要前3个人</span><br>        Stream&lt;String&gt; stream1 = list1.stream().filter(s -&gt; s.length() == <span class="hljs-number">3</span>).limit(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 3. 第二个队伍只要姓张的成员</span><br>        <span class="hljs-comment">// 4. 第二个队伍筛选之后不要前两个人</span><br>        Stream&lt;String&gt; stream2 = list2.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).skip(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 5. 将两个队伍合并为一个队伍</span><br>        <span class="hljs-comment">// 6. 根据姓名创建Person对象</span><br>        <span class="hljs-comment">// 7. 打印整个队伍的Person信息</span><br>        Stream.concat(stream1, stream2).map(Person::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stream流结果收集"><a href="#Stream流结果收集" class="headerlink" title="Stream流结果收集"></a>Stream流结果收集</h2><p>对流操作完成之后，如果需要将流的结果保存到集合或数组中，可以收集流中的数据。</p><h3 id="结果收集到集合"><a href="#结果收集到集合" class="headerlink" title="结果收集到集合"></a>结果收集到集合</h3><p>Stream流提供 <code>collect</code> 方法，其参数需要一个 <code>java.util.stream.Collector</code> 接口对象来指定收集到哪种集合中。而在<code>java.util.stream.Collectors</code> 类提供了一些方法，可以作为 Collector`接口的实例：</p><ul><li><code>public static Collector&gt; toList()</code> ：转换为 List 集合</li><li><code>public static Collector&gt; toSet()</code> ：转换为 Set 集合</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToCollection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>);<br>        <span class="hljs-comment">//收集到List中</span><br>        List&lt;String&gt; list = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toList());<br>        System.out.println(list);<br>        <span class="hljs-comment">//收集到Set中</span><br>        Set&lt;String&gt; set = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toSet());<br>        System.out.println(set);<br><br>        <span class="hljs-comment">//如果需要获取的类型为具体的实现，比如：ArrayList、HashSet</span><br>        ArrayList&lt;String&gt; arrayList = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword">new</span>));<br>        System.out.println(arrayList);<br>        HashSet&lt;String&gt; hashSet = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>));<br>        System.out.println(hashSet);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[aa, bb, cc, aa]<br>[aa, bb, cc]<br>[aa, bb, cc, aa]<br>[aa, bb, cc]<br></code></pre></td></tr></table></figure><h3 id="结果收集到数组"><a href="#结果收集到数组" class="headerlink" title="结果收集到数组"></a>结果收集到数组</h3><p>Stream中提供了<code>toArray</code>方法来将结果放到一个数组中，返回值类型是<code>Object[]</code>,如果我们要指定返回的类型，那么可以使用另一个重载的<code>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToArray</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//返回的数组中的元素是 Object类型</span><br>        Object[] objects = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).toArray();<br>        System.out.println(objects.getClass());<br>        <span class="hljs-comment">//如果需要指定返回的数组中的元素类型</span><br>        String[] strings = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).toArray(String[]::<span class="hljs-keyword">new</span>);<br>        System.out.println(strings.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> [Ljava.lang.<span class="hljs-keyword">Object</span>;<br><span class="hljs-keyword">class</span> [Ljava.lang.<span class="hljs-keyword">String</span>;<br></code></pre></td></tr></table></figure><h3 id="对流中的数据进行聚合计算"><a href="#对流中的数据进行聚合计算" class="headerlink" title="对流中的数据进行聚合计算"></a>对流中的数据进行聚合计算</h3><p>当我们使用Stream流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作。比如获取最大值，获取最小 值，求总和，平均值，统计数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToAggregate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">77</span>));<br>        <span class="hljs-comment">//获取最大值</span><br>        Optional&lt;Student&gt; max = studentStream.collect(Collectors.maxBy((o1, o2) -&gt; o1.getScore() - o2.getScore()));<br>        System.out.println(max);<br>        <span class="hljs-comment">//获取最小值</span><br>        Optional&lt;Student&gt; min = studentStream.collect(Collectors.minBy((o1, o2) -&gt; o1.getScore() - o2.getScore()));<br>        System.out.println(min);<br>        <span class="hljs-comment">//求年龄总和</span><br>        Integer sumAge = studentStream.collect(Collectors.summingInt(Student::getAge));<br>        System.out.println(sumAge);<br>        <span class="hljs-comment">//求分数平均值</span><br>        Double avgScore = studentStream.collect(Collectors.averagingInt(Student::getScore));<br>        System.out.println(avgScore);<br>        <span class="hljs-comment">//统计学生数量</span><br>        Long count = studentStream.collect(Collectors.counting());<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：Stream流只能使用一次！如果多次使用则会出现stream has already been operated upon or closed异常</p></blockquote><h3 id="对流中的数据进行分组"><a href="#对流中的数据进行分组" class="headerlink" title="对流中的数据进行分组"></a>对流中的数据进行分组</h3><p>使用示例：根据分数来进行分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToGroup</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">55</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">33</span>));<br><span class="hljs-comment">//Map&lt;Integer, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.groupingBy(Student::getAge));</span><br><br>        <span class="hljs-comment">//将分数大于60的分为一组，小于60的分为另一组</span><br>        studentStream.collect(Collectors.groupingBy(s -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (s.getScore() &gt; <span class="hljs-number">60</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;及格&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不及格&quot;</span>;<br>            &#125;<br>        &#125;)).forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">&quot;::&quot;</span> + v);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">不及格::[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;迪丽热巴&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=55&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-attribute">age</span>=52, <span class="hljs-attribute">score</span>=33&#125;]<br>及格::[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;赵丽颖&#x27;</span>, <span class="hljs-attribute">age</span>=58, <span class="hljs-attribute">score</span>=95&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;杨颖&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=88&#125;]<br></code></pre></td></tr></table></figure><h3 id="对流中的数据进行多级分组"><a href="#对流中的数据进行多级分组" class="headerlink" title="对流中的数据进行多级分组"></a>对流中的数据进行多级分组</h3><p>使用示例：先根据age分组，然后再根据score分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToMultiGroup</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">55</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">33</span>));<br>        <span class="hljs-comment">//Map&lt;Integer, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.groupingBy(Student::getAge));</span><br><br>        <span class="hljs-comment">//先根据age分组，然后再根据score分组</span><br>        Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; map = studentStream.collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(s -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (s.getScore() &gt;= <span class="hljs-number">90</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;优秀&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.getScore() &gt;= <span class="hljs-number">80</span> &amp;&amp; s.getScore() &lt; <span class="hljs-number">90</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;良好&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.getScore() &gt;= <span class="hljs-number">60</span> &amp;&amp; s.getScore() &lt; <span class="hljs-number">80</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;及格&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不及格&quot;</span>;<br>            &#125;<br>        &#125;)));<br>        map.forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">&quot;==&quot;</span> + v);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">52</span>==&#123;不及格=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-attribute">age</span>=52, <span class="hljs-attribute">score</span>=33&#125;]&#125;<br><span class="hljs-attribute">56</span>==&#123;不及格=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;迪丽热巴&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=55&#125;], 良好=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;杨颖&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=88&#125;]&#125;<br><span class="hljs-attribute">58</span>==&#123;优秀=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;赵丽颖&#x27;</span>, <span class="hljs-attribute">age</span>=58, <span class="hljs-attribute">score</span>=95&#125;]&#125;<br></code></pre></td></tr></table></figure><h3 id="对流中的数据进行分区"><a href="#对流中的数据进行分区" class="headerlink" title="对流中的数据进行分区"></a>对流中的数据进行分区</h3><p><code>Collectors.partitioningBy</code> 会根据Boolean值，把集合分割为两个列表，一个true列表，一个false列表。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-15.png" alt></p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToPartition</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">77</span>));<br>        Map&lt;Boolean, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.partitioningBy(s -&gt; s.getScore() &gt; <span class="hljs-number">90</span>));<br>        map.forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">&quot;==&quot;</span> + v);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">false</span>==[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;杨颖&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=88&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-attribute">age</span>=52, <span class="hljs-attribute">score</span>=77&#125;]<br><span class="hljs-attribute">true</span>==[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;赵丽颖&#x27;</span>, <span class="hljs-attribute">age</span>=58, <span class="hljs-attribute">score</span>=95&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;迪丽热巴&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=99&#125;]<br></code></pre></td></tr></table></figure><h3 id="对流中的数据进行拼接"><a href="#对流中的数据进行拼接" class="headerlink" title="对流中的数据进行拼接"></a>对流中的数据进行拼接</h3><p><code>Collectors.joining</code> 会根据指定的连接符，将所有元素连接成一个字符串。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToJoining</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">77</span>));<br>        String collect = studentStream<br>                .map(Student::getName)<br>                .collect(Collectors.joining(<span class="hljs-string">&quot;&gt;_&lt;&quot;</span>, <span class="hljs-string">&quot;^_^&quot;</span>, <span class="hljs-string">&quot;^v^&quot;</span>));<br>        System.out.println(collect);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">^<span class="hljs-literal">_</span>^赵丽颖&gt;<span class="hljs-literal">_</span>&lt;杨颖&gt;<span class="hljs-literal">_</span>&lt;迪丽热巴&gt;<span class="hljs-literal">_</span>&lt;柳岩^v^<br></code></pre></td></tr></table></figure><blockquote><p><strong>小结</strong></p><p>收集Stream流中的结果：</p><p>到集合中: Collectors.toList()/Collectors.toSet()/Collectors.toCollection() </p><p>到数组中: toArray()/toArray(类型[]::new) </p><p>聚合计算: Collectors.maxBy/Collectors.minBy/Collectors.counting/Collectors.summingInt/Collectors.averagingInt </p><p>分组: Collectors.groupingBy </p><p>分区: Collectors.partitionBy </p><p>拼接: Collectors.joinging</p></blockquote><h1 id="并行的Stream流"><a href="#并行的Stream流" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h1><p><strong>目标</strong></p><ul><li><p>了解串行的Stream流</p></li><li><p>掌握获取并行Stream流的两种方式</p></li></ul><h2 id="串行的Stream流"><a href="#串行的Stream流" class="headerlink" title="串行的Stream流"></a>串行的Stream流</h2><p>目前我们使用的Stream流是串行的，就是在一个线程上执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamSerial</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> count = Stream.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>)<br>                .filter(s -&gt; &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;,s = &quot;</span> + s);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;)<br>                .count();<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">4</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">5</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">3</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">9</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">6</span><br><span class="hljs-attribute">count</span> = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="并行的Stream流-1"><a href="#并行的Stream流-1" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h2><p><code>parallelStream</code>其实就是一个并行执行的流。它通过默认的<code>ForkJoinPool</code>，可以提高多线程任务的速度。</p><h3 id="获取并行流"><a href="#获取并行流" class="headerlink" title="获取并行流"></a>获取并行流</h3><p><strong>获取并行Stream流的两种方式：</strong></p><ul><li>直接获取并行的流</li><li>将串行流转成并行流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取并行流的两种方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelGet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//直接获取并行流</span><br>        Stream&lt;Integer&gt; parallelStream1 = list.parallelStream();<br>        <span class="hljs-comment">//将已有的串行流转成并行流</span><br>        Stream&lt;Integer&gt; parallelStream2 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).parallel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="操作并行流"><a href="#操作并行流" class="headerlink" title="操作并行流"></a>操作并行流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作并行流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelOperate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> count = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>                .parallel()<br>                .filter(s -&gt; &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;, s = &quot;</span> + s);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;)<br>                .count();<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">11</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">3</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">4</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">6</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">5</span><br><span class="hljs-attribute">count</span> = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>小结</strong></p><p>获取并行流有两种方式:</p><p>直接获取并行流: parallelStream()</p><p>将串行流转成并行流: parallel()</p></blockquote><h2 id="并行流和串行流对比"><a href="#并行流和串行流对比" class="headerlink" title="并行流和串行流对比"></a>并行流和串行流对比</h2><p>我们通过for循环、串行Stream流、并行Stream流来对5亿个数字求和。来看消耗时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelCompare</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> times = <span class="hljs-number">500000000L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        start = System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;消耗时间：&quot;</span> + (end - start));<br>    &#125;<br><br>    <span class="hljs-comment">//普通for循环 消耗时间：306</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFor</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通for循环：&quot;</span>);<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; times; i++) &#123;<br>            res += i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//串行流处理 消耗时间：696</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSerial</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;串行流：&quot;</span>);<br>        LongStream<br>                .rangeClosed(<span class="hljs-number">0</span>, times)<br>                .reduce(<span class="hljs-number">0</span>, Long::sum);<br>    &#125;<br><br>    <span class="hljs-comment">//并行流处理 消耗时间：75</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParallel</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;并行流：&quot;</span>);<br>        LongStream<br>                .rangeClosed(<span class="hljs-number">0</span>, times)<br>                .parallel()<br>                .reduce(<span class="hljs-number">0</span>, Long::sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过案例我们可以看到并行流的效率是最高的。</p><p>Stream并行处理的过程会分而治之，也就是将一个大的任务切分成了多个小任务，这表示每个任务都是 一个线程操作。</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>在多线程的处理下，肯定会出现数据安全问题。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; listOld = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            listOld.add(i);<br>        &#125;<br>        System.out.println(listOld.size());<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//使用并行流来向集合中添加数据</span><br>        listOld.parallelStream().forEach(listNew::add);<br>        System.out.println(listNew.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1000</span><br><span class="hljs-number">837</span><br></code></pre></td></tr></table></figure><p>我们发现明明是向集合中添加1000个元素，而实际上却只有837个元素。</p><p>针对这类问题，我们有那些解决方案呢？</p><ol><li>加同步锁</li><li>使用线程安全的容器</li><li>通过Stream中的<code>toArray()</code> / <code>collect()</code>操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelThreadSafe</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加同步锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Object obj = <span class="hljs-keyword">new</span> Object();<br>        IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br>                .parallel()<br>                .forEach(i -&gt; &#123;<br>                    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                        listNew.add(i);<br>                    &#125;<br>                &#125;);<br>        System.out.println(listNew.size());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用线程安全的容器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//将线程不安全的容器包装为线程安全的容器  或者直接使用Vector也可以</span><br>        List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(listNew);<br>        IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br>                .parallel()<br>                .forEach(synchronizedList::add);<br>        System.out.println(synchronizedList.size());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 我们还可以通过Stream中的 toArray方法或者 collect方法来操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">/*Object[] list = IntStream.rangeClosed(1, 1000)</span><br><span class="hljs-comment">                .parallel()</span><br><span class="hljs-comment">                .boxed()</span><br><span class="hljs-comment">                .toArray();*/</span><br>        List&lt;Integer&gt; list = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br>                .parallel()<br>                .boxed()<br>                .collect(Collectors.toList());<br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>parallelStream使用的是Fork/Join框架。Fork/Join框架自 JDK7 引入。Fork/Join框架可以将一个大任务拆分为很多小任务来异步执行。</p><h3 id="Fork-Join原理-分治法"><a href="#Fork-Join原理-分治法" class="headerlink" title="Fork/Join原理-分治法"></a>Fork/Join原理-分治法</h3><p>ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法， ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-16.png" alt></p><h3 id="Fork-Join原理-工作窃取算法"><a href="#Fork-Join原理-工作窃取算法" class="headerlink" title="Fork/Join原理-工作窃取算法"></a>Fork/Join原理-工作窃取算法</h3><p>Fork/Join最核心的地方就是利用了现代硬件设备多核，在一个操作时候会有空闲的cpu，那么如何利用好这个空闲的cpu就成了提高性能的关键，而这里我们要提到的工作窃取（work-stealing）算法就是整个Fork/Join框架的核心理念 。Fork/Join工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-17.png" alt></p><p>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖 的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来 执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的 任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就 去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任 务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永 远从双端队列的尾部拿任务执行。</p><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争， 比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><p>上文中已经提到了在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，也就是我们使用了ForkJoinPool的ParallelStream。</p><p>对于ForkJoinPool通用线程池的线程数量，通常使用默认值就可以了，即运行时计算机的处理器数量。可以通过设置系统属性：java.util.concurrent.ForkJoinPool.common.parallelism=N （N为线程数量），来调整ForkJoinPool的线程数量，可以尝试调整成不同的参数来观察每次的输出结果。</p><h3 id="Fork-Join案例"><a href="#Fork-Join案例" class="headerlink" title="Fork/Join案例"></a>Fork/Join案例</h3><p>需求：使用Fork/Join计算1-10000的和，当一个任务的计算数量大于3000时拆分任务，数量小于3000时计算。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-18.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool();<br>        SumRecursiveTask sumRecursiveTask = <span class="hljs-keyword">new</span> SumRecursiveTask(<span class="hljs-number">1</span>, <span class="hljs-number">10000L</span>);<br>        Long result = forkJoinPool.invoke(sumRecursiveTask);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;消耗时间：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumRecursiveTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> THRESHOLD = <span class="hljs-number">3000L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> end;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SumRecursiveTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> length = end - start;<br>        <span class="hljs-keyword">if</span> (length &lt;= THRESHOLD) &#123;<br>            <span class="hljs-comment">//任务不再拆分了，可以计算了</span><br>            <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = start; i &lt;= end; i++) &#123;<br>                sum += i;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;计算: &quot;</span> + start + <span class="hljs-string">&quot; -&gt; &quot;</span> + end + <span class="hljs-string">&quot;,结果为: &quot;</span> + sum);<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//数量大于阈值，任务还需要再拆分</span><br>            <span class="hljs-keyword">long</span> middle = (start + end) / <span class="hljs-number">2</span>;<br>            System.out.println(<span class="hljs-string">&quot;拆分: 左边 &quot;</span> + start + <span class="hljs-string">&quot; -&gt; &quot;</span> + middle + <span class="hljs-string">&quot;, 右边 &quot;</span> + (middle +<br>                    <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; -&gt; &quot;</span> + end);<br>            SumRecursiveTask left = <span class="hljs-keyword">new</span> SumRecursiveTask(start, middle);<br>            left.fork();<br>            SumRecursiveTask right = <span class="hljs-keyword">new</span> SumRecursiveTask(middle, end);<br>            right.fork();<br>            <span class="hljs-keyword">return</span> left.join() + right.join();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">拆分:</span> <span class="hljs-string">左边</span> <span class="hljs-number">1</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">5000</span><span class="hljs-string">,</span> <span class="hljs-string">右边</span> <span class="hljs-number">5001</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">10000</span><br><span class="hljs-string">拆分:</span> <span class="hljs-string">左边</span> <span class="hljs-number">1</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">2500</span><span class="hljs-string">,</span> <span class="hljs-string">右边</span> <span class="hljs-number">2501</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">5000</span><br><span class="hljs-string">拆分:</span> <span class="hljs-string">左边</span> <span class="hljs-number">5000</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">7500</span><span class="hljs-string">,</span> <span class="hljs-string">右边</span> <span class="hljs-number">7501</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">10000</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">5000</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">7500</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">15631250</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">2500</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">5000</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">9378750</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">7500</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">10000</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">21883750</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">1</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">2500</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">3126250</span><br><span class="hljs-string">result</span> <span class="hljs-string">=</span> <span class="hljs-number">50020000</span><br><span class="hljs-string">消耗时间：69</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>小结</strong></p><ol><li>parallelStream是线程不安全的。</li><li>parallelStream适用的场景是CPU密集型的，只是做到别浪费CPU，假如本身电脑CPU的负载就很大，还到处用并行流的话，反而不能起到正向作用。</li><li>I/O密集型：磁盘I/O、网络I/O都属于I/O操作，这部分操作是较少消耗CPU资源。一般并行流中不适用于I/O密集型的操作，就比如使用并流行进行大批量的消息推送，涉及到了大量I/O，此时使用并行流反而会导致慢很多。</li><li>在使用并行流的时候是无法保证元素的顺序的，即使你用了同步集合也只能保证元素都正确但无法保证其中的顺序。</li></ol></blockquote><h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><p>这个Optional类主要是解决空指针异常。</p><h2 id="以前对null的处理"><a href="#以前对null的处理" class="headerlink" title="以前对null的处理"></a>以前对null的处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//Optional.of(T t)方式 不支持null</span><br>    Optional&lt;String&gt; op1 = Optional.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-comment">//Optional&lt;Object&gt; op2 = Optional.of(null);</span><br><br>    <span class="hljs-comment">//Optional.ofNullable(T t)方式 支持null</span><br>    Optional&lt;String&gt; op3 = Optional.ofNullable(<span class="hljs-string">&quot;李四&quot;</span>);<br>    Optional&lt;Object&gt; op4 = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">//Optional.empty()方式 直接创建一个空的Optional对象</span><br>    Optional&lt;Object&gt; op5 = Optional.empty();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Optional类介绍"><a href="#Optional类介绍" class="headerlink" title="Optional类介绍"></a>Optional类介绍</h2><p>Optional是一个没有子类的工具类，Optional是一个可以为null的容器对象。它的主要作用就是为了解决避免null检查，防止NullPointerException。</p><p><img src="/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/image-19.png" alt></p><h2 id="Optional的基本使用"><a href="#Optional的基本使用" class="headerlink" title="Optional的基本使用"></a>Optional的基本使用</h2><h3 id="Optional类的创建方式"><a href="#Optional类的创建方式" class="headerlink" title="Optional类的创建方式"></a>Optional类的创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个 Optional 实例</span><br>Optional.of(T t)<br><span class="hljs-comment">//若 t 不为 null,创建 Optional 实例,否则创建空实例</span><br>Optional.ofNullable(T t)<br><span class="hljs-comment">//创建一个空的 Optional 实例</span><br>Optional.empty()<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//Optional.of(T t)方式 不支持null</span><br>    Optional&lt;String&gt; op1 = Optional.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-comment">//Optional&lt;Object&gt; op2 = Optional.of(null);</span><br><br>    <span class="hljs-comment">//Optional.ofNullable(T t)方式 支持null</span><br>    Optional&lt;String&gt; op3 = Optional.ofNullable(<span class="hljs-string">&quot;李四&quot;</span>);<br>    Optional&lt;Object&gt; op4 = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">//Optional.empty()方式 直接创建一个空的Optional对象</span><br>    Optional&lt;Object&gt; op5 = Optional.empty();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Optional类的常用方法"><a href="#Optional类的常用方法" class="headerlink" title="Optional类的常用方法"></a>Optional类的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否包含值,包含值返回true，不包含值返回false</span><br>isPresent()<br><span class="hljs-comment">//如果Optional有值则将其返回，否则抛出NoSuchElementException</span><br>get()<br><span class="hljs-comment">//如果调用对象包含值，返回该值，否则返回参数t</span><br>orElse(T t)<br><span class="hljs-comment">//如果调用对象包含值，返回该值，否则返回Lambda表达式的返回值</span><br>orElseGet(Supplier s)<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    Optional&lt;String&gt; op1 = Optional.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>    Optional&lt;String&gt; op2 = Optional.empty();<br><br>    <span class="hljs-keyword">if</span> (op1.isPresent()) &#123;<br>        String s1 = op1.get();<br>        System.out.println(<span class="hljs-string">&quot;用户名称：&quot;</span> + s1);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (op2.isPresent()) &#123;<br>        String s2 = op2.get();<br>        System.out.println(s2);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;op2是一个空Optional对象&quot;</span>);<br>    &#125;<br><br>    String s3 = op1.orElse(<span class="hljs-string">&quot;李四&quot;</span>);<br>    System.out.println(s3);<br>    <br>    Object s4 = op2.orElse(<span class="hljs-string">&quot;王五&quot;</span>);<br>    System.out.println(s4);<br><br>    String s5 = op2.orElseGet(() -&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;);<br>    System.out.println(s5);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">用户名称：张三<br>op2是一个空<span class="hljs-keyword">Optional</span>对象<br>张三<br>王五<br>hello<br></code></pre></td></tr></table></figure><h1 id="日期和时间-API"><a href="#日期和时间-API" class="headerlink" title="日期和时间 API"></a>日期和时间 API</h1><h2 id="旧版日期和时间-API-存在的问题"><a href="#旧版日期和时间-API-存在的问题" class="headerlink" title="旧版日期和时间 API 存在的问题"></a>旧版日期和时间 API 存在的问题</h2><p>在旧版本中JDK对于日期和时间这块的时间是非常差的。</p><ol><li>设计差： 在java.util和java.sql的包中都有日期类，java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期。此外用于格式化和解析的类在java.text包中定义。</li><li>非线程安全：java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li><li>时区处理麻烦：日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和 java.util.TimeZone类，但他们同样存在上述所有的问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeDemo01</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//1、设计不合理</span><br>        Date date = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">2022</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>);<br>        System.out.println(date);<br><br>        <span class="hljs-comment">//2、时间格式化和解析操作是线程不安全的</span><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(sdf.parse(<span class="hljs-string">&quot;2022-08-18&quot;</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="新版日期和时间-API-介绍"><a href="#新版日期和时间-API-介绍" class="headerlink" title="新版日期和时间 API 介绍"></a>新版日期和时间 API 介绍</h2><p>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于 <code>java.time</code> 包中，下面是一些关键字：</p><ul><li><code>LocalDate</code> ：表示日期，包含年月日，格式为 2019-10-16</li><li><code>LocalTime</code> ：表示时间，包含时分秒，格式为 16:38:54.158549300</li><li><code>LocalDateTime</code> ：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</li><li><code>DateTimeFormatter</code> ：日期时间格式化类</li><li><code>Instant</code>：时间戳，表示一个特定的时间瞬间</li><li><code>Duration</code>：用于计算2个时间(LocalTime，时分秒)的距离</li><li><code>Period</code>：用于计算2个日期(LocalDate，年月日)的距离</li><li><code>ZonedDateTime</code> ：包含时区的时间</li></ul><p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天， 闰年是366天。</p><p>此外Java 8还提供了4套其他历法，分别是：</p><ul><li>ThaiBuddhistDate：泰国佛教历</li><li>MinguoDate：中华民国历</li><li>JapaneseDate：日本历</li><li>HijrahDate：伊斯兰历</li></ul><h3 id="日期和时间的常见操作"><a href="#日期和时间的常见操作" class="headerlink" title="日期和时间的常见操作"></a>日期和时间的常见操作</h3><p>LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDK8 日期操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1、创建指定的日期</span><br>    LocalDate date1 = LocalDate.of(<span class="hljs-number">2022</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>);<br>    System.out.println(<span class="hljs-string">&quot;date1 = &quot;</span> + date1);<br><br>    <span class="hljs-comment">//2、得到当前的日期</span><br>    LocalDate now = LocalDate.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br><br>    <span class="hljs-comment">//3、根据LocalDate对象获取对应的日期信息</span><br>    System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + now.getYear());<br>    System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + now.getMonth().getValue());<br>    System.out.println(<span class="hljs-string">&quot;日：&quot;</span> + now.getDayOfMonth());<br>    System.out.println(<span class="hljs-string">&quot;星期：&quot;</span> + now.getDayOfWeek().getValue());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDK8 时间操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1、得到指定的时间</span><br>    LocalTime time = LocalTime.of(<span class="hljs-number">5</span>, <span class="hljs-number">26</span>, <span class="hljs-number">33</span>, <span class="hljs-number">23145</span>);<br>    System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + time);<br><br>    <span class="hljs-comment">//2、获取当前的时间</span><br>    LocalTime now = LocalTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br><br>    <span class="hljs-comment">//3、获取时间信息</span><br>    System.out.println(<span class="hljs-string">&quot;时：&quot;</span> + now.getHour());<br>    System.out.println(<span class="hljs-string">&quot;分：&quot;</span> + now.getMinute());<br>    System.out.println(<span class="hljs-string">&quot;秒：&quot;</span> + now.getSecond());<br>    System.out.println(<span class="hljs-string">&quot;纳秒：&quot;</span> + now.getNano());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDK8 日期时间操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、获取指定的日期时间</span><br>    LocalDateTime dateTime = LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>, <span class="hljs-number">10</span>, <span class="hljs-number">22</span>, <span class="hljs-number">36</span>, <span class="hljs-number">213</span>);<br>    System.out.println(<span class="hljs-string">&quot;dateTime = &quot;</span>+dateTime);<br><br>    <span class="hljs-comment">//2、获取当前的日期时间</span><br>    LocalDateTime now = LocalDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span>+now );<br><br>    <span class="hljs-comment">//3、获取日期时间信息</span><br>    System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + now.getYear());<br>    System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + now.getMonth().getValue());<br>    System.out.println(<span class="hljs-string">&quot;日：&quot;</span> + now.getDayOfMonth());<br>    System.out.println(<span class="hljs-string">&quot;星期：&quot;</span> + now.getDayOfWeek().getValue());<br>    System.out.println(<span class="hljs-string">&quot;时：&quot;</span> + now.getHour());<br>    System.out.println(<span class="hljs-string">&quot;分：&quot;</span> + now.getMinute());<br>    System.out.println(<span class="hljs-string">&quot;秒：&quot;</span> + now.getSecond());<br>    System.out.println(<span class="hljs-string">&quot;纳秒：&quot;</span> + now.getNano());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日期和时间的修改与比较"><a href="#日期和时间的修改与比较" class="headerlink" title="日期和时间的修改与比较"></a>日期和时间的修改与比较</h3><p>对日期时间的修改，最简单的方式是使用withAttribute方法。 withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。每次操作都是返回了一个新的对象，所以在多线程场景下是数据安全的。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日期时间的修改</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br>    <span class="hljs-comment">// 修改日期时间，修改后返回新的对象</span><br>    LocalDateTime localDateTime = now.withYear(<span class="hljs-number">1999</span>);<br>    System.out.println(<span class="hljs-string">&quot;now :&quot;</span> + now);<br>    System.out.println(<span class="hljs-string">&quot;修改后的：&quot;</span> + localDateTime);<br>    System.out.println(<span class="hljs-string">&quot;月份：&quot;</span> + now.withMonth(<span class="hljs-number">10</span>));<br>    System.out.println(<span class="hljs-string">&quot;天：&quot;</span> + now.withDayOfMonth(<span class="hljs-number">6</span>));<br>    System.out.println(<span class="hljs-string">&quot;小时：&quot;</span> + now.withHour(<span class="hljs-number">8</span>));<br>    System.out.println(<span class="hljs-string">&quot;分钟:&quot;</span> + now.withMinute(<span class="hljs-number">15</span>));<br>    <span class="hljs-comment">// 在当前日期时间的基础上 加上/减去指定的时间</span><br>    System.out.println(<span class="hljs-string">&quot;两天后:&quot;</span> + now.plusDays(<span class="hljs-number">2</span>));<br>    System.out.println(<span class="hljs-string">&quot;10年后:&quot;</span> + now.plusYears(<span class="hljs-number">10</span>));<br>    System.out.println(<span class="hljs-string">&quot;6个月后 = &quot;</span> + now.plusMonths(<span class="hljs-number">6</span>));<br>    System.out.println(<span class="hljs-string">&quot;10年前 = &quot;</span> + now.minusYears(<span class="hljs-number">10</span>));<br>    System.out.println(<span class="hljs-string">&quot;半年前 = &quot;</span> + now.minusMonths(<span class="hljs-number">6</span>));<br>    System.out.println(<span class="hljs-string">&quot;一周前 = &quot;</span> + now.minusDays(<span class="hljs-number">7</span>));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日期时间的比较</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//在JDK8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期，可直接进行比较。</span><br>    LocalDateTime now = LocalDateTime.now();<br>    LocalDateTime dateTime = LocalDateTime.of(<span class="hljs-number">1999</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);<br>    System.out.println(now.isBefore(dateTime));<br>    System.out.println(now.equals(dateTime));<br>    System.out.println(now.isAfter(dateTime));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="格式化和解析操作"><a href="#格式化和解析操作" class="headerlink" title="格式化和解析操作"></a>格式化和解析操作</h3><p>通过 <code>java.time.format.DateTimeFormatter</code> 类可以进行日期时间解析与格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//得到当前日期时间</span><br>    LocalDateTime now = LocalDateTime.now();<br><br>    <span class="hljs-comment">//通过 ofPattern 方法来指定特定的格式</span><br>    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-comment">//将日期时间 格式化为 字符串</span><br>    String format = now.format(formatter);<br>    System.out.println(<span class="hljs-string">&quot;format = &quot;</span> + format);<br><br>    <span class="hljs-comment">//将字符串 解析为 日期时间</span><br>    LocalDateTime parse = LocalDateTime.parse(<span class="hljs-string">&quot;1999-10-10 10:10:10&quot;</span>, formatter);<br>    System.out.println(<span class="hljs-string">&quot;parse = &quot;</span> + parse);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Instant类"><a href="#Instant类" class="headerlink" title="Instant类"></a>Instant类</h3><p>在JDK8中给我们新增一个Instant类(时间戳/时间线)，内部保存了从1970年1月1日 00:00:00 以来的秒和纳秒</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Instant 时间戳，可以用来统计时间消耗</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Instant now = Instant.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br>    <span class="hljs-comment">//获取从1970年一月一日 00:00:00 到现在的纳秒</span><br>    System.out.println(now.getNano());<br>    Thread.sleep(<span class="hljs-number">5</span>);<br>    Instant now1 = Instant.now();<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (now1.getNano() - now.getNano()));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算日期时间差"><a href="#计算日期时间差" class="headerlink" title="计算日期时间差"></a>计算日期时间差</h3><p>JDK8中提供了两个工具类<code>Duration/Period</code>：计算日期时间差</p><ul><li><code>Duration</code>：用来计算两个时间差(LocalTime)</li><li><code>Period</code>:用来计算两个日期差(LocalDate)</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test09</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Duration 计算时间的差距</span><br>    LocalTime nowTime = LocalTime.now();<br>    LocalTime time = LocalTime.of(<span class="hljs-number">15</span>, <span class="hljs-number">38</span>, <span class="hljs-number">36</span>);<br>    Duration duration = Duration.between(time, nowTime);<br>    System.out.println(<span class="hljs-string">&quot;相差的天数:&quot;</span> + duration.toDays());<br>    System.out.println(<span class="hljs-string">&quot;相差的小时数:&quot;</span> + duration.toHours());<br>    System.out.println(<span class="hljs-string">&quot;相差的分钟数:&quot;</span> + duration.toMinutes());<br>    System.out.println(<span class="hljs-string">&quot;相差的秒数:&quot;</span> + duration.toSeconds());<br><br>    <span class="hljs-comment">// Period 计算日期的差距</span><br>    LocalDate nowDate = LocalDate.now();<br>    LocalDate date = LocalDate.of(<span class="hljs-number">1999</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    Period period = Period.between(date, nowDate);<br>    System.out.println(<span class="hljs-string">&quot;相差的年:&quot;</span> + period.getYears());<br>    System.out.println(<span class="hljs-string">&quot;相差的月:&quot;</span> + period.getMonths());<br>    System.out.println(<span class="hljs-string">&quot;相差的天:&quot;</span> + period.getDays());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时间矫正器"><a href="#时间矫正器" class="headerlink" title="时间矫正器"></a>时间矫正器</h3><p>有时我们可能需要获取例如：将日期调整到“下一个月的第一天”等操作。可以通过时间校正器来进行。</p><ul><li><code>TemporalAdjuster</code> : 时间校正器</li><li><code>TemporalAdjusters</code> : 该类通过静态方法提供了大量的常用TemporalAdjuster的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    <span class="hljs-comment">//得到当前的日期调整到下个月的一号</span><br>    TemporalAdjuster firstDayOfNextMonth= temporal -&gt; &#123;<br>        LocalDateTime dateTime = (LocalDateTime) temporal;<br>        LocalDateTime nextMonth = dateTime.plusMonths(<span class="hljs-number">1</span>).withDayOfMonth(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nextMonth;<br>    &#125;;<br>    LocalDateTime newDateTime = now.with(firstDayOfNextMonth);<br>    System.out.println(<span class="hljs-string">&quot;newDateTime = &quot;</span>+newDateTime);<br><br>    <span class="hljs-comment">//可以通过 TemporalAdjusters 来实现</span><br>    LocalDateTime newDateTime2 = now.with(TemporalAdjusters.firstDayOfNextMonth());<br>    System.out.println(<span class="hljs-string">&quot;newDateTime2 = &quot;</span>+newDateTime2);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日期时间的时区"><a href="#日期时间的时区" class="headerlink" title="日期时间的时区"></a>日期时间的时区</h3><p>不带时区的：LocalDate、LocalTime、LocalDateTime</p><p>带时区的：ZonedDateTime</p><p>其中每个时区都对应着 ID，ID的格式为 “区域/城市” 例如 ：Asia/Shanghai 等</p><p>ZoneId：该类中包含了所有的时区信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//获取所有的时区ID</span><br>    <span class="hljs-comment">//ZoneId.getAvailableZoneIds().forEach(System.out::println);</span><br><br>    <span class="hljs-comment">//获取当前时间,中国使用的东八区的时区，比标准时间早8个小时</span><br>    LocalDateTime now = LocalDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span>+now);<br><br>    <span class="hljs-comment">//使用计算机默认的时区，创建日期时间</span><br>    ZonedDateTime now1 = ZonedDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now1 = &quot;</span>+now1);<br><br>    <span class="hljs-comment">//使用指定的时区创建日期时间</span><br>    ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(<span class="hljs-string">&quot;America/Marigot&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;now2 = &quot;</span>+now2);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">now</span> = <span class="hljs-number">2022</span>-<span class="hljs-number">08</span>-<span class="hljs-number">19</span>T<span class="hljs-number">00</span>:<span class="hljs-number">35</span>:<span class="hljs-number">35</span>.<span class="hljs-number">245237600</span><br><span class="hljs-attribute">now1</span> = <span class="hljs-number">2022</span>-<span class="hljs-number">08</span>-<span class="hljs-number">19</span>T<span class="hljs-number">00</span>:<span class="hljs-number">35</span>:<span class="hljs-number">35</span>.<span class="hljs-number">259200800</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>[Asia/Shanghai]<br><span class="hljs-attribute">now2</span> = <span class="hljs-number">2022</span>-<span class="hljs-number">08</span>-<span class="hljs-number">18</span>T<span class="hljs-number">12</span>:<span class="hljs-number">35</span>:<span class="hljs-number">35</span>.<span class="hljs-number">260198300</span>-<span class="hljs-number">04</span>:<span class="hljs-number">00</span>[America/Marigot]<br></code></pre></td></tr></table></figure><h1 id="重复注解与类型注解"><a href="#重复注解与类型注解" class="headerlink" title="重复注解与类型注解"></a>重复注解与类型注解</h1><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>自从Java 5中引入 <code>注解</code> 以来，注解开始变得非常流行，并在各个框架和项目中被广泛使用。不过注解有一个很大的限 制是：在同一个地方不能多次使用同一个注解。JDK 8引入了重复注解的概念，允许在同一个地方多次使用同一个注 解。在JDK 8中使用<code>@Repeatable</code>注解定义重复注解。</p><p>重复注解的使用步骤：</p><ol><li><p>定义一个重复注解的容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotations &#123;<br>    MyAnnotation[] value();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义一个可重复的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(MyAnnotations.class)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置多个重复的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation(&quot;test1&quot;)</span><br><span class="hljs-meta">@MyAnnotation(&quot;test2&quot;)</span><br><span class="hljs-meta">@MyAnnotation(&quot;test3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnoTest01</span> </span>&#123;<br><br>    <span class="hljs-meta">@MyAnnotation(&quot;fun1&quot;)</span><br>    <span class="hljs-meta">@MyAnnotation(&quot;fun2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">//......</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>解析得到指定的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析重复注解</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>    <span class="hljs-comment">//获取类中标注的重复注解</span><br>    MyAnnotation[] annotationsByType = AnnoTest01.class.getAnnotationsByType(MyAnnotation.class);<br>    <span class="hljs-keyword">for</span> (MyAnnotation myAnnotation : annotationsByType) &#123;<br>        System.out.println(myAnnotation.value());<br>    &#125;<br>    <span class="hljs-comment">//获取方法上标注的重复注解</span><br>    MyAnnotation[] test01s = AnnoTest01.class.getMethod(<span class="hljs-string">&quot;test01&quot;</span>).getAnnotationsByType(MyAnnotation.class);<br>    <span class="hljs-keyword">for</span> (MyAnnotation test01 : test01s) &#123;<br>        System.out.println(test01.value());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">test<span class="hljs-number">1</span><br>test<span class="hljs-number">2</span><br>test<span class="hljs-number">3</span><br>fu<span class="hljs-symbol">n1</span><br>fu<span class="hljs-symbol">n2</span><br></code></pre></td></tr></table></figure><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>JDK8为<code>@Target</code>元注解新增了两种类型： TYPE_PARAMETER、TYPE_USE </p><ul><li><code>TYPE_PARAMETER</code> ：表示该注解能写在类型参数的声明语句中</li><li><code>TYPE_USE</code> ：表示注解可以在任何用到类型的地方使用</li></ul><p>TYPE_PARAMETER的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE_PARAMETER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TypeParam &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以把注解放在泛型上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeDemo01</span>&lt;@<span class="hljs-title">TypeParam</span> <span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;<span class="hljs-meta">@TypeParam</span> K extends Objects&gt; <span class="hljs-function">K <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TYPE_USE的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE_USE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NotNull &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以把注解放在类型的前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeDemo02</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@NotNull</span> Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Integer a, <span class="hljs-meta">@NotNull</span> Integer b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO笔记（二）Netty框架</title>
    <link href="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>前面我们学习了Java为我们提供的NIO框架，提供使用NIO提供的三大组件，我们就可以编写更加高性能的客户端/服务端网络程序了，甚至还可以自行规定一种通信协议进行通信。</p><h1 id="NIO框架存在的问题"><a href="#NIO框架存在的问题" class="headerlink" title="NIO框架存在的问题"></a>NIO框架存在的问题</h1><p>但是之前我们在使用NIO框架的时候，还是发现了一些问题，我们先来盘点一下。</p><h2 id="客户端关闭导致服务端空轮询"><a href="#客户端关闭导致服务端空轮询" class="headerlink" title="客户端关闭导致服务端空轮询"></a>客户端关闭导致服务端空轮询</h2><p>可能在之前的实验中，你发现了这样一个问题：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-1.png" alt></p><p>当我们的客户端主动与服务端断开连接时，会导致READ事件一直被触发，也就是说<code>selector.select()</code>会直接通过，并且是可读的状态，但是我们发现实际上读到是数据是一个空的（上面的图中在空轮询两次后抛出异常了，也有可能是无限的循环下去）所以这里我们得稍微处理一下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs java">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isReadable()) &#123;<br>    SocketChannel channel = (SocketChannel) key.channel();<br>    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>    <span class="hljs-comment">//这里我们需要判断一下，如果read操作得到的结果是-1，那么说明服务端已经断开连接了</span><br>    <span class="hljs-keyword">if</span>(channel.read(buffer) &lt; <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端已经断开连接了：&quot;</span>+channel.getRemoteAddress());<br>        <span class="hljs-comment">//直接关闭此通道</span><br>        channel.close();   <br>        <span class="hljs-comment">//继续进行选择</span><br>        <span class="hljs-keyword">continue</span>;   <br>    &#125;<br>    buffer.flip();<br>    System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>    channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以在客户端主动断开时关闭连接了：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-2.png" alt></p><p>当然，除了这种情况可能会导致空轮询之外，实际上还有一种可能，这种情况是NIO框架本身的BUG：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-comment">//由于底层epoll机制的问题，导致select方法可能会一直返回0，造成无限循环的情况。</span><br>    <span class="hljs-keyword">int</span> count = selector.select();  <br>    System.out.println(<span class="hljs-string">&quot;监听到 &quot;</span>+count+<span class="hljs-string">&quot; 个事件&quot;</span>);<br>    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br></code></pre></td></tr></table></figure><p>本质原因也是因为客户端的主动断开导致：</p><blockquote><p>This is an issue with poll (and epoll) on Linux. If a file descriptor for a connected socket is polled with a request event mask of 0, and if the connection is abruptly terminated (RST) then the poll wakes up with the POLLHUP (and maybe POLLERR) bit set in the returned event set. The implication of this behaviour is that Selector will wakeup and as the interest set for the SocketChannel is 0 it means there aren’t any selected events and the select method returns 0.</p></blockquote><p>这个问题本质是与操作系统有关的，所以JDK一直都认为是操作系统的问题，不应该由自己来处理，所以这个问题在当时的好几个JDK版本都是存在的，这是一个很严重的空转问题，无限制地进行空转操作会导致CPU资源被疯狂消耗。</p><p>不过，这个问题，却被Netty框架巧妙解决了，我们后面再说。</p><h2 id="粘包-拆包问题"><a href="#粘包-拆包问题" class="headerlink" title="粘包/拆包问题"></a>粘包/拆包问题</h2><p>除了上面的问题之外，我们接着来看下一个问题。</p><p>我们在<code>计算机网络</code>这门课程中学习过，操作系统通过TCP协议发送数据的时候，也会先将数据存放在缓冲区中，而至于什么时候真正地发出这些数据，是由TCP协议来决定的，这是我们无法控制的事情。</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-3.png" alt="image-3"></p><p>也就是说，比如现在我们要发送两个数据包（P1/P2），理想情况下，这两个包应该是依次到达服务端，并由服务端正确读取两次数据出来，但是由于上面的机制，可能会出现下面的情况：</p><ol><li><strong>这两个包应该是依次到达服务端（理想情况）</strong></li><li>可能P1和P2被合在一起发送给了服务端（粘包现象）</li><li>可能P1和P2的前半部分合在一起发送给了服务端（拆包现象）</li><li>可能P1的前半部分就被单独作为一个部分发给了服务端，P1的后半部分和P2一起发给服务端（也是拆包现象）</li></ol><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-4.png" alt></p><p>当然，对于这种问题，也有一些比较常见的解决方案：</p><ol><li>消息定长，发送方和接收方规定固定大小的消息长度，例如每个数据包大小固定为200字节，如果不够，空位补空格，只有接收了200个字节之后，作为一个完整的数据包进行处理。</li><li>在每个包的末尾使用固定的分隔符，比如每个数据包末尾都是<code>\r\n</code>，这样就一定需要读取到这样的分隔符才能将前面所有的数据作为一个完整的数据包进行处理。</li><li>将消息分为头部和本体，在头部中保存当前整个数据包的长度，只有在读到足够长度之后才算是读到了一个完整的数据包。</li></ol><p>这里我们就来演示一下第一种解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open();<br>         Selector selector = Selector.open())&#123;<br>        serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-comment">//一个数据包要求必须塞满30个字节</span><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> count = selector.select();<br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                ...<br>                    <span class="hljs-keyword">if</span>(buffer.remaining() == <span class="hljs-number">0</span>) &#123;<br>                        buffer.flip();<br>                        System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>                        buffer.clear();<br>                    &#125;<br>                    channel.write(ByteBuffer.wrap((<span class="hljs-string">&quot;已收到 &quot;</span>+size+<span class="hljs-string">&quot; 字节的数据！&quot;</span>).getBytes()));<br>                &#125;<br>               ...<br></code></pre></td></tr></table></figure><p>现在，当我们的客户端发送消息时，如果没有达到30个字节，那么会暂时存储起来，等有30个之后再一次性得到，当然如果数据量超过了30，那么最多也只会读取30个字节，其他的放在下一批：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-5.png" alt></p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-6.png" alt></p><p>这样就可以在一定程度上解决粘包/拆包问题了。</p><h1 id="走进Netty框架"><a href="#走进Netty框架" class="headerlink" title="走进Netty框架"></a>走进Netty框架</h1><p>前面我们盘点了一下NIO存在的一些问题，而在Netty框架中，这些问题都被巧妙的解决了。</p><p>Netty是由JBOSS提供的一个开源的java网络编程框架，主要是对java的nio包进行了再次封装。Netty比java原生的nio包提供了更加强大、稳定的功能和易于使用的api。 netty的作者是Trustin Lee，这是一个韩国人，他还开发了另外一个著名的网络编程框架，mina。二者在很多方面都十分相似，它们的线程模型也是基本一致 。不过netty社区的活跃程度比mina高得多。</p><p>Netty实际上应用场景非常多，比如我们的Minecraft游戏服务器。</p><p>Java版本的Minecraft服务器就是使用Netty框架作为网络通信的基础，正是得益于Netty框架的高性能，我们才能愉快地和其他的小伙伴一起在服务器里面炸服。</p><p>当然除了游戏服务器之外，我们微服务之间的远程调用也可以使用Netty来完成，比如Dubbo的RPC框架，包括最新的SpringWebFlux框架，也抛弃了内嵌Tomcat而使用Netty作为通信框架。既然Netty这么强大，那么现在我们就开始Netty的学习吧！</p><p>首先导包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.76.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="ByteBuf介绍"><a href="#ByteBuf介绍" class="headerlink" title="ByteBuf介绍"></a>ByteBuf介绍</h2><p>Netty并没有使用NIO中提供的ByteBuffer来进行数据装载，而是自行定义了一个ByteBuf类。</p><p>那么这个ByteBuf类相比NIO中的ByteBuffer有什么不同之处呢？</p><ul><li><p>写操作完成后无需进行<code>flip()</code>翻转。</p></li><li><p>具有比ByteBuffer更快的响应速度。</p></li><li><p>动态扩容。</p></li></ul><p>首先我们来看看它的内部结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractByteBuf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteBuf</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">//index被分为了读和写，是两个指针在同时工作</span><br>    <span class="hljs-keyword">int</span> readerIndex;   <br>    <span class="hljs-keyword">int</span> writerIndex;<br>    <span class="hljs-comment">//mark操作也分两种</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> markedReaderIndex;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> markedWriterIndex;<br>    <span class="hljs-comment">//最大容量，没错，这玩意能动态扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxCapacity;    <br></code></pre></td></tr></table></figure><p>可以看到，读操作和写操作分别由两个指针在进行维护，每写入一次，<code>writerIndex</code>向后移动一位，每读取一次，也是<code>readerIndex</code>向后移动一位，当然<code>readerIndex</code>不能大于<code>writerIndex</code>，这样就不会像NIO中的ByteBuffer那样还需要进行翻转了。</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-7.png" alt></p><p>其中<code>readerIndex</code>和<code>writerIndex</code>之间的部分就是可读的内容，而<code>writerIndex</code>之后到<code>capacity</code>都是可写的部分。</p><p>我们来实际使用一下看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个初始容量为10的ByteBuf缓冲区，这里的Unpooled是用于快速生成ByteBuf的工具类</span><br>    <span class="hljs-comment">//ByteBuf有池化和非池化两种，区别在于对内存的复用，我们之后再讨论</span><br>    ByteBuf buf = Unpooled.buffer(<span class="hljs-number">10</span>);<br>    System.out.println(<span class="hljs-string">&quot;初始状态：&quot;</span>+Arrays.toString(buf.array()));<br>    <span class="hljs-comment">//写入一个Int数据</span><br>    buf.writeInt(-<span class="hljs-number">888888888</span>);   <br>    System.out.println(<span class="hljs-string">&quot;写入Int后：&quot;</span>+Arrays.toString(buf.array()));<br>    <span class="hljs-comment">//无需翻转，直接读取一个short数据出来</span><br>    buf.readShort();   <br>    System.out.println(<span class="hljs-string">&quot;读取Short后：&quot;</span>+Arrays.toString(buf.array()));<br>    <span class="hljs-comment">//丢弃操作，会将当前的可读部分内容丢到最前面，并且读写指针向前移动丢弃的距离</span><br>    buf.discardReadBytes();   <br>    System.out.println(<span class="hljs-string">&quot;丢弃之后：&quot;</span>+Arrays.toString(buf.array()));<br>    <span class="hljs-comment">//清空操作，清空之后读写指针都归零</span><br>    buf.clear();    <br>    System.out.println(<span class="hljs-string">&quot;清空之后：&quot;</span>+Arrays.toString(buf.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">初始状态：[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br>写入Int后：[<span class="hljs-string">-53</span>, 4, <span class="hljs-string">-95</span>, <span class="hljs-string">-56</span>, 0, 0, 0, 0, 0, 0]<br>读取Short后：[<span class="hljs-string">-53</span>, 4, <span class="hljs-string">-95</span>, <span class="hljs-string">-56</span>, 0, 0, 0, 0, 0, 0]<br>丢弃之后：[<span class="hljs-string">-95</span>, <span class="hljs-string">-56</span>, <span class="hljs-string">-95</span>, <span class="hljs-string">-56</span>, 0, 0, 0, 0, 0, 0]<br>清空之后：[<span class="hljs-string">-95</span>, <span class="hljs-string">-56</span>, <span class="hljs-string">-95</span>, <span class="hljs-string">-56</span>, 0, 0, 0, 0, 0, 0]<br></code></pre></td></tr></table></figure><p>通过结合断点调试，我们可以更加清楚地观察读写指针的移动情况，更加清楚的认识一下ByteBuf的底层操作。</p><p>我们再来看看划分操作是不是和之前一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//我们也可以将一个byte[]直接包装进缓冲区（和NIO是一样的）不过写指针的值一开始就跑到最后去了，但是这玩意不是只读的</span><br>    ByteBuf buf = Unpooled.wrappedBuffer(<span class="hljs-string">&quot;abcdefg&quot;</span>.getBytes());<br>  <span class="hljs-comment">//除了包装，也可以复制数据，copiedBuffer()会完完整整将数据拷贝到一个新的缓冲区中</span><br>    buf.readByte();   <span class="hljs-comment">//读取一个字节</span><br>    ByteBuf slice = buf.slice();   <span class="hljs-comment">//现在读指针位于1，然后进行划分</span><br><br>    <span class="hljs-comment">//得到划分出来的ByteBuf的偏移地址</span><br>    System.out.println(slice.arrayOffset());   <br>    System.out.println(Arrays.toString(slice.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，划分也是根据当前读取的位置来进行的，只不过底层数组还是同一个。</p><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">1</span><br>[<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>]<br></code></pre></td></tr></table></figure><p>我们继续来看看它的另一个特性，动态扩容，比如我们申请一个容量为10的缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//容量只有10字节</span><br>    ByteBuf buf = Unpooled.buffer(<span class="hljs-number">10</span>);    <br>    System.out.println(buf.capacity());<br>  <span class="hljs-comment">//直接写一个字符串，很明显这么多字已经超过10字节了</span><br>    buf.writeCharSequence(<span class="hljs-string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);<br>    System.out.println(buf.capacity());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">10<br>64<br></code></pre></td></tr></table></figure><p>通过结果我们发现，在写入一个超出当前容量的数据时，会进行动态扩容，扩容会从64开始，之后每次触发扩容都会x2，当然如果我们不希望它扩容，可以指定最大容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//在生成时指定maxCapacity也为10</span><br>    ByteBuf buf = Unpooled.buffer(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    System.out.println(buf.capacity());<br>    buf.writeCharSequence(<span class="hljs-string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);<br>    System.out.println(buf.capacity());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">10</span><br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IndexOutOfBoundsException: writer<span class="hljs-constructor">Index(0)</span> + min<span class="hljs-constructor">WritableBytes(18)</span> exceeds max<span class="hljs-constructor">Capacity(10)</span>: <span class="hljs-constructor">UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(<span class="hljs-params">ridx</span>: 0, <span class="hljs-params">widx</span>: 0, <span class="hljs-params">cap</span>: 10<span class="hljs-operator">/</span>10)</span><br>at io.netty.buffer.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractByteBuf</span>.</span></span>ensure<span class="hljs-constructor">Writable0(AbstractByteBuf.<span class="hljs-params">java</span>:294)</span><br>at io.netty.buffer.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractByteBuf</span>.</span></span>set<span class="hljs-constructor">CharSequence0(AbstractByteBuf.<span class="hljs-params">java</span>:702)</span><br>at io.netty.buffer.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractByteBuf</span>.</span></span>write<span class="hljs-constructor">CharSequence(AbstractByteBuf.<span class="hljs-params">java</span>:1187)</span><br>at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>java:<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure><p>可以看到现在无法再动态扩容了。</p><p>我们接着来看一下缓冲区的三种实现模式：堆缓冲区模式、直接缓冲区模式、复合缓冲区模式。</p><p>堆缓冲区（数组实现）和直接缓冲区（堆外内存实现）不用多说，前面我们在NIO中已经了解过了，我们要创建一个直接缓冲区也很简单，直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ByteBuf buf = Unpooled.directBuffer(<span class="hljs-number">10</span>);<br>    System.out.println(Arrays.toString(buf.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的不能直接拿到数组，因为底层压根不是数组实现的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.UnsupportedOperationException: direct buffer<br>at io.netty.buffer.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnpooledDirectByteBuf</span>.</span></span><span class="hljs-built_in">array</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnpooledDirectByteBuf</span>.</span></span>java:<span class="hljs-number">181</span>)<br>at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>java:<span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><p>我们来看看复合模式，复合模式可以任意地拼凑组合其他缓冲区，比如我们可以：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-8.png" alt></p><p>这样，如果我们想要对两个缓冲区组合的内容进行操作，我们就不用再单独创建一个新的缓冲区了，而是直接将其进行拼接操作，相当于是作为多个缓冲区组合的视图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个复合缓冲区</span><br>CompositeByteBuf buf = Unpooled.compositeBuffer();<br>buf.addComponent(Unpooled.copiedBuffer(<span class="hljs-string">&quot;abc&quot;</span>.getBytes()));<br>buf.addComponent(Unpooled.copiedBuffer(<span class="hljs-string">&quot;def&quot;</span>.getBytes()));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buf.capacity(); i++) &#123;<br>    System.out.println((<span class="hljs-keyword">char</span>) buf.getByte(i));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>c<br>d<br>e<br>f<br></code></pre></td></tr></table></figure><p>可以看到我们也可以正常操作组合后的缓冲区。</p><p>最后我们来看看，池化缓冲区和非池化缓冲区的区别。</p><p>我们研究一下Unpooled工具类中具体是如何创建buffer的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unpooled</span> </span>&#123;<br>    <span class="hljs-comment">//实际上内部是有一个ByteBufAllocator对象的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteBufAllocator ALLOC;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteOrder BIG_ENDIAN;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteOrder LITTLE_ENDIAN;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ByteBuf EMPTY_BUFFER;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuf <span class="hljs-title">buffer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//缓冲区的创建操作实际上是依靠ByteBufAllocator来进行的</span><br>        <span class="hljs-keyword">return</span> ALLOC.heapBuffer();   <br>    &#125;<br>  <br>  ...<br>      <br>    <span class="hljs-comment">//ALLOC在静态代码块中进行指定，实际上真正的实现类是UnpooledByteBufAllocator</span><br>    <span class="hljs-keyword">static</span> &#123;   <br>        ALLOC = UnpooledByteBufAllocator.DEFAULT;<br>        BIG_ENDIAN = ByteOrder.BIG_ENDIAN;<br>        LITTLE_ENDIAN = ByteOrder.LITTLE_ENDIAN;<br>        <span class="hljs-comment">//空缓冲区容量和最大容量都是0</span><br>        EMPTY_BUFFER = ALLOC.buffer(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);   <br>        <span class="hljs-keyword">assert</span> EMPTY_BUFFER <span class="hljs-keyword">instanceof</span> EmptyByteBuf : <span class="hljs-string">&quot;EMPTY_BUFFER must be an EmptyByteBuf.&quot;</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们来看看，这个ByteBufAllocator又是个啥，顾名思义，其实就是负责分配缓冲区的。</p><p>它有两个具体实现类：<code>UnpooledByteBufAllocator</code>和<code>PooledByteBufAllocator</code>，一个是非池化缓冲区生成器，还有一个是池化缓冲区生成器，那么池化和非池化有啥区别呢？</p><p>实际上池化缓冲区利用了池化思想，将缓冲区通过设置内存池来进行内存块复用，这样就不用频繁地进行内存的申请，尤其是在使用堆外内存的时候，避免多次重复通过底层<code>malloc()</code>函数系统调用申请内存造成的性能损失。Netty的内存管理机制主要是借鉴<code>Jemalloc</code>内存分配策略，感兴趣的小伙伴可以深入了解一下。</p><p>所以，由于<code>PooledByteBufAllocator</code>是复用内存空间的，我们来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ByteBufAllocator allocator = PooledByteBufAllocator.DEFAULT;<br>    <span class="hljs-comment">//申请一个容量为10的直接缓冲区</span><br>    ByteBuf buf = allocator.directBuffer(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//随便操作操作</span><br>    buf.writeChar(<span class="hljs-string">&#x27;T&#x27;</span>);    <br>    System.out.println(buf.readChar());<br>    <span class="hljs-comment">//释放此缓冲区</span><br>    buf.release();    <br>    <span class="hljs-comment">//重新再申请一个同样大小的直接缓冲区</span><br>    ByteBuf buf2 = allocator.directBuffer(<span class="hljs-number">10</span>);   <br>    System.out.println(buf2 == buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">T</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>可以看到，在我们使用完一个缓冲区之后，我们将其进行资源释放，当我们再次申请一个同样大小的缓冲区时，会直接得到之前已经申请好的缓冲区，所以，PooledByteBufAllocator实际上是将ByteBuf实例放入池中在进行复用。</p><h2 id="零拷贝简介"><a href="#零拷贝简介" class="headerlink" title="零拷贝简介"></a>零拷贝简介</h2><p><strong>注意：</strong>此小节作为选学内容，需要掌握<code>操作系统</code>和<code>计算机组成原理</code>才能学习。</p><p>零拷贝是一种I/O操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，首先第一个问题，什么是内核空间，什么又是用户空间呢？</p><p>其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，程序很容易不稳定，常常把系统搞崩溃，比如清除操作系统的内存数据。实际上让应用程序随便访问内存真的太危险了，于是就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0 ~ Ring3，Linux 下只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-9.png" alt></p><p>比如我们Java中创建一个新的线程，实际上最终是要交给操作系统来为我们进行分配的，而需要操作系统帮助我们完成任务则需要进行系统调用，是内核在进行处理，不是我们自己的程序在处理，这时就相当于我们的程序处于了内核态，而当操作系统底层分配完成，最后到我们Java代码中返回得到线程对象时，又继续由我们的程序进行操作，所以从内核态转换回了用户态。</p><p>而我们的文件操作也是这样，我们实际上也是需要让操作系统帮助我们从磁盘上读取文件数据或是向网络发送数据，比如使用传统IO的情况下，我们要从磁盘上读取文件然后发送到网络上，就会经历以下流程：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-10.png" alt></p><p>可以看到整个过程中是经历了2次CPU拷贝+2次DMA拷贝，一共四次拷贝，虽然逻辑比较清晰，但是数据老是这样来回进行复制，是不是太浪费时间了点？所以我们就需要寻找一种更好的方式，来实现零拷贝。</p><p>实现零拷贝我们这里演示三种方案：</p><ol><li><p>使用虚拟内存</p><p>现在的操作系统基本都是支持虚拟内存的，我们可以让内核空间和用户空间的虚拟地址指向同一个物理地址，这样就相当于是直接共用了这一块区域，也就谈不上拷贝操作了：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-11.png" alt></p></li><li><p>使用mmap/write内存映射</p><p>实际上这种方式就是将内核空间中的缓存直接映射到用户空间缓存，比如我们之前在学习NIO中使用的MappedByteBuffer，就是直接作为映射存在，当我们需要将数据发送到Socket缓冲区时，直接在内核空间中进行操作就行了：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-12.png" alt></p></li><li><p>使用sendfile方式</p><p>比如我们之前在NIO中使用的<code>transferTo()</code>方法，就是利用了这种机制来实现零拷贝的。</p><p>在Linux2.1开始，引入了sendfile方式来简化操作，我们可以直接告诉内核要把哪个文件数据拷贝到Socket上，直接在内核空间中一步到位：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-13.png" alt></p></li></ol><h2 id="Netty工作模型"><a href="#Netty工作模型" class="headerlink" title="Netty工作模型"></a>Netty工作模型</h2><p>前面我们了解了Netty为我们提供的更高级的缓冲区类，我们接着来看看Netty是如何工作的，上一章我们介绍了Reactor模式，而Netty正是以主从Reactor多线程模型为基础，构建出了一套高效的工作模型。</p><p>我们先来回顾之前介绍的主从Reactor多线程模型：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-14.png" alt></p><p>所有的客户端需要连接到主Reactor完成Accept操作后，其他的操作由从Reactor去完成，这里也是差不多的思想，但是它进行了一些改进，接着我们来看一下Netty的设计：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-15.png" alt></p><p>看一下它的设计：</p><ul><li><p>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接受客户端的连接, WorkerGroup专门负责读写，就像我们前面说的主从Reactor一样。</p></li><li><p>无论是BossGroup还是WorkerGroup，都是使用EventLoop（事件循环，很多系统都采用了事件循环机制，比如前端框架Node.js，事件循环顾名思义，就是一个循环，不断地进行事件通知）来进行事件监听的，整个Netty也是使用事件驱动来运作的，比如当客户端已经准备好读写、连接建立时，都会进行事件通知，说白了就像我们之前写NIO多路复用那样，只不过这里换成EventLoop了而已，它已经帮助我们封装好了一些常用操作，而且我们可以自己添加一些额外的任务，如果有多个EventLoop，会存放在EventLoopGroup中，EventLoopGroup就是BossGroup和WorkerGroup的具体实现。</p></li><li>在BossGroup之后，会正常将SocketChannel绑定到WorkerGroup中的其中一个EventLoop上，进行后续的读写操作监听。</li></ul><p>前面我们大致了解了一下Netty的工作模型，接着我们来尝试创建一个Netty服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//这里我们使用NioEventLoopGroup实现类即可，创建BossGroup和WorkerGroup</span><br>    <span class="hljs-comment">//当然还有EpollEventLoopGroup，但是仅支持Linux，这是Netty基于Linux底层Epoll单独编写的一套本地实现，没有使用NIO那套</span><br>    EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>    <span class="hljs-comment">//创建服务端启动引导类</span><br>    ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    <span class="hljs-comment">//可链式，就很棒</span><br>    bootstrap<br>        <span class="hljs-comment">//指定事件循环组</span><br>            .group(bossGroup, workerGroup)<br>        <span class="hljs-comment">//指定为NIO的ServerSocketChannel</span><br>            .channel(NioServerSocketChannel.class)  <br>        <span class="hljs-comment">//注意，这里的SocketChannel是Netty的，不是NIO里面的，</span><br>            .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>                    <span class="hljs-comment">//获取流水线，当我们需要处理客户端的数据时，实际上是像流水线一样在处理，这个流水线上可以有很多Handler</span><br>                    <span class="hljs-comment">//添加一个Handler，这里使用ChannelInboundHandlerAdapter</span><br>                    channel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <br>                        <span class="hljs-comment">//ctx是上下文，msg是收到的消息，默认以ByteBuf形式（也可以是其他形式，后面再说）</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;  <br>                            <span class="hljs-comment">//类型转换一下</span><br>                            ByteBuf buf = (ByteBuf) msg;   <br>                            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                            <span class="hljs-comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span><br>                            ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>    <span class="hljs-comment">//最后绑定端口，启动</span><br>    bootstrap.bind(<span class="hljs-number">8080</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到上面写了很多东西，你一定会懵逼，这些新来的东西，都是什么跟什么啊，怎么一个也没看明白？没关系，我们可以暂时先将代码写在这里，具体的各个部分，还请听后面细细道来。</p><p>我们接着编写一个客户端，客户端可以直接使用我们之前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个新的SocketChannel，一会通过通道进行通信</span><br>    <span class="hljs-keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;   <span class="hljs-comment">//咱给它套个无限循环，这样就能一直发消息了</span><br>            System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>            String text = scanner.nextLine();<br>            <span class="hljs-keyword">if</span>(text.isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//直接向通道中写入数据，真舒服</span><br>            channel.write(ByteBuffer.wrap(text.getBytes()));<br>            System.out.println(<span class="hljs-string">&quot;已发送！&quot;</span>);<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>            <span class="hljs-comment">//直接从通道中读取数据</span><br>            channel.read(buffer);   <br>            buffer.flip();<br>            System.out.println(<span class="hljs-string">&quot;收到服务器返回：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过通道正常收发数据即可，这样我们就成功搭建好了一个Netty服务器。</p><h2 id="Channel详解"><a href="#Channel详解" class="headerlink" title="Channel详解"></a>Channel详解</h2><p>在学习NIO时，我们就已经接触到Channel了，我们可以通过通道来进行数据的传输，并且通道支持双向传输。</p><p>而在Netty中，也有对应的Channel类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Channel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeMap</span>, <span class="hljs-title">ChannelOutboundInvoker</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//通道ID</span><br>    <span class="hljs-function">ChannelId <span class="hljs-title">id</span><span class="hljs-params">()</span></span>;  <br>    <span class="hljs-comment">//获取此通道所属的EventLoop，因为一个Channel在它的生命周期内只能注册到一个EventLoop中</span><br>    <span class="hljs-function">EventLoop <span class="hljs-title">eventLoop</span><span class="hljs-params">()</span></span>;  <br>    <span class="hljs-comment">//Channel是具有层级关系的，这里是返回父Channel</span><br>    <span class="hljs-function">Channel <span class="hljs-title">parent</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-function">ChannelConfig <span class="hljs-title">config</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//通道当前的相关状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRegistered</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//通道相关信息（元数据）</span><br>    <span class="hljs-function">ChannelMetadata <span class="hljs-title">metadata</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-function">SocketAddress <span class="hljs-title">localAddress</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-function">SocketAddress <span class="hljs-title">remoteAddress</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//关闭通道，但是会用到ChannelFuture，后面说</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">closeFuture</span><span class="hljs-params">()</span></span>;  <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isWritable</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">bytesBeforeUnwritable</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">bytesBeforeWritable</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Unsafe <span class="hljs-title">unsafe</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//流水线，之后也会说</span><br>    <span class="hljs-function">ChannelPipeline <span class="hljs-title">pipeline</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-comment">//可以直接从Channel拿到ByteBufAllocator的实例，来分配ByteBuf</span><br>    <span class="hljs-function">ByteBufAllocator <span class="hljs-title">alloc</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-function">Channel <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//刷新</span><br>    <span class="hljs-function">Channel <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Netty中的Channel相比NIO功能就多得多了。Netty中的Channel主要特点如下：</p><ul><li>所有的IO操作都是异步的，并不是在当前线程同步运行，无法立即得到结果，那怎么获取操作的结果呢？还记得我们在前面JUC篇教程中学习的Future吗，没错，这里的ChannelFuture也是干这事的。</li></ul><p>我们可以来看一下Channel接口的父接口ChannelOutboundInvoker接口，这里面定义了大量的I/O操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通道出站调用（包含大量的网络出站操作，比如写）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelOutboundInvoker</span> </span>&#123;  <br>    <span class="hljs-comment">//Socket绑定、连接、断开、关闭等操作</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress var1)</span></span>;  <br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress var1)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress var1, SocketAddress var2)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">deregister</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//下面这一系列还有附带ChannelPromise的，ChannelPromise我们后面再说，其实就是ChannelFuture的增强版</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress var1, ChannelPromise var2)</span></span>;    <br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress var1, ChannelPromise var2)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress var1, SocketAddress var2, ChannelPromise var3)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelPromise var1)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">close</span><span class="hljs-params">(ChannelPromise var1)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">deregister</span><span class="hljs-params">(ChannelPromise var1)</span></span>;<br>    <span class="hljs-function">ChannelOutboundInvoker <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br>  <br>    <span class="hljs-comment">//可以看到这些常见的写操作，都是返回的ChannelFuture，而不是直接给结果</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">write</span><span class="hljs-params">(Object var1)</span></span>;    <br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">write</span><span class="hljs-params">(Object var1, ChannelPromise var2)</span></span>;<br>    <span class="hljs-function">ChannelOutboundInvoker <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">writeAndFlush</span><span class="hljs-params">(Object var1, ChannelPromise var2)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">writeAndFlush</span><span class="hljs-params">(Object var1)</span></span>;<br>  <br>    <span class="hljs-function">ChannelPromise <span class="hljs-title">newPromise</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-function">ChannelProgressivePromise <span class="hljs-title">newProgressivePromise</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">newSucceededFuture</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">newFailedFuture</span><span class="hljs-params">(Throwable var1)</span></span>;<br>    <span class="hljs-function">ChannelPromise <span class="hljs-title">voidPromise</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然它还实现了AttributeMap接口，其实有点类似于Session那种感觉，我们可以添加一些属性之类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeMap</span> </span>&#123;<br>    &lt;T&gt; <span class="hljs-function">Attribute&lt;T&gt; <span class="hljs-title">attr</span><span class="hljs-params">(AttributeKey&lt;T&gt; var1)</span></span>;<br><br>    &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttr</span><span class="hljs-params">(AttributeKey&lt;T&gt; var1)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们了解了Netty底层的Channel之后，我们接着来看ChannelHandler，既然现在有了通道，那么怎么进行操作呢？我们可以将需要处理的事情放在ChannelHandler中，ChannelHandler充当了所有入站和出站数据的应用程序逻辑的容器，实际上就是我们之前Reactor模式中的Handler，全靠它来处理读写操作。</p><p>不过这里不仅仅是一个简单的ChannelHandler在进行处理，而是一整套流水线，我们之后会介绍ChannelPipeline。</p><p>比如我们上面就是使用了ChannelInboundHandlerAdapter抽象类，它是ChannelInboundHandler接口的实现，用于处理入站数据，可以看到我们实际上就是通过重写对应的方法来进行处理，这些方法会在合适的时间被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;  <br>      <span class="hljs-comment">//ctx是上下文，msg是收到的消息，类型转换一下为ByteBuf形式</span><br>        ByteBuf buf = (ByteBuf) msg;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>        <span class="hljs-comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span><br>        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们先从顶层接口开始看起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;<br>  <span class="hljs-comment">//当ChannelHandler被添加到流水线中时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//当ChannelHandler从流水线中移除时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> 已过时那咱就不管了 */</span><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-meta">@Inherited</span><br>    <span class="hljs-meta">@Documented</span><br>    <span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Sharable &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顶层接口的定义比较简单，就只有一些流水线相关的回调方法，我们接着来看下一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ChannelInboundHandler用于处理入站相关事件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;<br>  <span class="hljs-comment">//当Channel已经注册到自己的EventLoop上时调用</span><br>    <span class="hljs-comment">//前面我们说了，一个Channel只会注册到一个EventLoop上，注册到EventLoop后，这样才会在发生对应事件时被通知。</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//从EventLoop上取消注册时</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelUnregistered</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//当Channel已经处于活跃状态时被调用，此时Channel已经连接/绑定，并且已经就绪</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//跟上面相反，不再活跃了，并且不在连接它的远程节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//当从Channel读取数据时被调用，可以看到数据被自动包装成了一个Object（默认是ByteBuf）</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext var1, Object var2)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//上一个读取操作完成后调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//暂时不介绍</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext var1, Object var2)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//当Channel的可写状态发生改变时被调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelWritabilityChanged</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">//出现异常时被调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而我们上面用到的ChannelInboundHandlerAdapter实际上就是对这些方法实现的抽象类，相比直接用接口，我们可以只重写我们需要的方法，没有重写的方法会默认向流水线下一个ChannelHandler发送。</p><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;channelRegistered&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelUnregistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;channelUnregistered&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;channelActive&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;channelInactive&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = (ByteBuf) msg;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>        <span class="hljs-comment">//这次我们就直接使用ctx.alloc()来生成缓冲区</span><br>        ByteBuf back = ctx.alloc().buffer();<br>        back.writeCharSequence(<span class="hljs-string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);<br>        ctx.writeAndFlush(back);<br>        System.out.println(<span class="hljs-string">&quot;channelRead&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;channelReadComplete&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;userEventTriggered&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelWritabilityChanged</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;channelWritabilityChanged&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;exceptionCaught&quot;</span>+cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>    ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    bootstrap<br>            .group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>      <span class="hljs-comment">//ChannelInitializer是一个特殊的ChannelHandler</span><br>        <span class="hljs-comment">//它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span><br>            .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>                    <span class="hljs-comment">//将我们自定义的ChannelHandler添加到流水线</span><br>                    channel.pipeline().addLast(<span class="hljs-keyword">new</span> TestChannelHandler());<br>                &#125;<br>            &#125;);<br>    bootstrap.bind(<span class="hljs-number">8080</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们启动服务器，让客户端来连接并发送一下数据试试看：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-16.png" alt></p><p>可以看到ChannelInboundHandler的整个生命周期，首先是Channel注册成功，然后才会变成可用状态，接着就差不多可以等待客户端来数据了，当客户端主动断开连接时，会再次触发一次<code>channelReadComplete</code>，然后不可用，最后取消注册。</p><p>我们来测试一下出现异常的情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ByteBuf buf = (ByteBuf) msg;<br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>    ByteBuf back = ctx.alloc().buffer();<br>    back.writeCharSequence(<span class="hljs-string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);<br>    ctx.writeAndFlush(back);<br>    System.out.println(<span class="hljs-string">&quot;channelRead&quot;</span>);<br>    <span class="hljs-comment">//弄点异常上去</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;我是自定义异常1&quot;</span>);  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;channelReadComplete&quot;</span>);<br>    <span class="hljs-comment">//弄点异常上去</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;我是自定义异常2&quot;</span>);   <br>&#125;<br><br>...<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;exceptionCaught&quot;</span>+cause);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到发生异常时，会接着调用<code>exceptionCaught</code>方法：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-17.png" alt></p><p>与ChannelInboundHandler对应的还有ChannelOutboundHandler用于处理出站相关的操作，这里就不进行演示了。</p><p>我们接着来看看ChannelPipeline，每一个Channel都对应一个ChannelPipeline（在Channel初始化时就被创建了）</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-18.png" alt></p><p>它就像是一条流水线一样，整条流水线上可能会有很多个Handler（包括入站和出站），整条流水线上的两端还有两个默认的处理器（用于一些预置操作和后续操作，比如释放资源等），我们只需要关心如何安排这些自定义的Handler即可，比如我们现在希望创建两个入站ChannelHandler，一个用于接收请求并处理，还有一个用于处理当前接收请求过程中出现的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span><br>.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>        <span class="hljs-comment">//直接获取pipeline，然后添加两个Handler，注意顺序</span><br>        channel.pipeline()   <br>            <span class="hljs-comment">//第一个用于处理消息接收</span><br>                .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ByteBuf buf = (ByteBuf) msg;<br>                        System.out.println(<span class="hljs-string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;我是异常&quot;</span>);<br>                    &#125;<br>                &#125;)<br>            <span class="hljs-comment">//第二个用于处理异常</span><br>                .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        System.out.println(<span class="hljs-string">&quot;我是异常处理：&quot;</span>+cause);<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>那么它是如何运作的呢？实际上如果我们不在ChannelInboundHandlerAdapter中重写对应的方法，它会默认传播到流水线的下一个ChannelInboundHandlerAdapter进行处理，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//通过ChannelHandlerContext来向下传递，ChannelHandlerContext是在Handler添加进Pipeline中时就被自动创建的</span><br>    ctx.fireExceptionCaught(cause);   <br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们现在需要将一个消息在两个Handler中进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>    <span class="hljs-comment">//直接获取pipeline，然后添加两个Handler</span><br>    channel.pipeline()   <br>            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ByteBuf buf = (ByteBuf) msg;<br>                    System.out.println(<span class="hljs-string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                    <span class="hljs-comment">//通过ChannelHandlerContext</span><br>                    ctx.fireChannelRead(msg);   <br>                &#125;<br>            &#125;)<br>            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ByteBuf buf = (ByteBuf) msg;<br>                    System.out.println(<span class="hljs-string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看看出站相关操作，我们可以使用ChannelOutboundHandlerAdapter来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>    channel.pipeline()<br>        <span class="hljs-comment">//注意出栈站操作应该在入站操作的前面</span><br>        <span class="hljs-comment">//当我们使用ChannelHandlerContext的write方法时，是从流水线的当前位置的后面倒着往前找下一个ChannelOutboundHandlerAdapter</span><br>        <span class="hljs-comment">//而我们之前使用的ChannelInboundHandlerAdapter是从前往后找下一个</span><br>        <span class="hljs-comment">//但如果我们使用的是Channel的write方法，那么会从整个流水线的最后开始倒着往前找ChannelOutboundHandlerAdapter</span><br>            .addLast(<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;                 <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <br>                    <span class="hljs-comment">//write的是啥，这里就是是啥</span><br>                    System.out.println(msg);   <br>                  <span class="hljs-comment">//我们将其转换为ByteBuf，这样才能发送回客户端</span><br>                    ctx.writeAndFlush(Unpooled.wrappedBuffer(msg.toString().getBytes()));<br>                &#125;<br>            &#125;)<br>            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ByteBuf buf = (ByteBuf) msg;<br>                    System.out.println(<span class="hljs-string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                    ctx.fireChannelRead(msg);<br>                &#125;<br>            &#125;)<br>            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ByteBuf buf = (ByteBuf) msg;<br>                    System.out.println(<span class="hljs-string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                    <span class="hljs-comment">//这里可以write任何对象</span><br>                    ctx.writeAndFlush(<span class="hljs-string">&quot;不会吧不会吧，不会还有人都看到这里了还没三连吧&quot;</span>);   <br>                    <span class="hljs-comment">//或是通过Channel进行write也可以</span><br>                  <span class="hljs-comment">//ctx.channel().writeAndFlush(&quot;啊对对对&quot;); </span><br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来试试看，搞两个出站的Handler，验证一下是不是上面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>    <span class="hljs-comment">//直接获取pipeline，然后添加两个Handler</span><br>    channel.pipeline()   <br>            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ByteBuf buf = (ByteBuf) msg;<br>                    System.out.println(<span class="hljs-string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                    ctx.fireChannelRead(msg);<br>                &#125;<br>            &#125;)<br>            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ByteBuf buf = (ByteBuf) msg;<br>                    System.out.println(<span class="hljs-string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                    <span class="hljs-comment">//这里我们使用channel的write</span><br>                    ctx.channel().writeAndFlush(<span class="hljs-string">&quot;伞兵一号卢本伟&quot;</span>);  <br>                &#125;<br>            &#125;)<br>            .addLast(<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;1号出站：&quot;</span>+msg);<br>                &#125;<br>            &#125;)<br>            .addLast(<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;2号出站：&quot;</span>+msg);<br>                    <span class="hljs-comment">//继续write给其他的出站Handler，不然到这里就断了</span><br>                    ctx.write(msg);  <br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，出站操作在流水线上是反着来的，整个流水线操作大概流程如下:</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-19.png" alt></p><p>有关Channel及其处理相关操作，就先讲到这里。</p><h2 id="EventLoop和任务调度"><a href="#EventLoop和任务调度" class="headerlink" title="EventLoop和任务调度"></a>EventLoop和任务调度</h2><p>前面我们讲解了Channel，那么在EventLoop中具体是如何进行调度的呢？实际上我们之前在编写NIO的时候，就是一个while循环在源源不断地等待新的事件，而EventLoop也正是这种思想，它本质就是一个事件等待/处理线程。</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-20.png" alt></p><p>我们上面使用的就是EventLoopGroup，包含很多个EventLoop，我们每创建一个连接，就需要绑定到一个EventLoop上，之后EventLoop就会开始监听这个连接（只要连接不关闭，一直都是这个EventLoop负责此Channel），而一个EventLoop可以同时监听很多个Channel，实际上就是我们之前学习的Selector罢了。</p><p>当然，EventLoop并不只是用于网络操作的，我们前面所说的EventLoop其实都是NioEventLoop，它是专用于网络通信的，但是除了网络通信之外，我们也可以使用普通的EventLoop来处理一些其他的事件。</p><p>比如我们现在编写的服务端，虽然结构上和主从Reactor多线程模型差不多，但是我们发现，Handler似乎是和读写操作在一起进行的，而我们之前所说的模型中，Handler是在读写之外的单独线程中进行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//线程数先限制一下</span><br>    EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);  <br>    ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    bootstrap<br>        <span class="hljs-comment">//指定事件循环组</span><br>            .group(bossGroup, workerGroup)   <br>        <span class="hljs-comment">//指定为NIO的ServerSocketChannel</span><br>            .channel(NioServerSocketChannel.class)  <br>        <span class="hljs-comment">//注意，这里的SocketChannel是Netty的</span><br>            .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>                    channel.pipeline()<br>                            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                    ByteBuf buf = (ByteBuf) msg;<br>                                    System.out.println(<span class="hljs-string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                                    <span class="hljs-comment">//这里我们直接卡10秒假装在处理任务</span><br>                                    Thread.sleep(<span class="hljs-number">10000</span>);   <br>                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>                                &#125;<br>                            &#125;);<br>                &#125;<br>            &#125;);<br>    bootstrap.bind(<span class="hljs-number">8080</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，如果在这里卡住了，那么就没办法处理EventLoop绑定的其他Channel了，所以我们这里就创建一个普通的EventLoop来专门处理读写之外的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//线程数先限制一下</span><br>    EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//使用DefaultEventLoop来处理其他任务</span><br>    EventLoopGroup handlerGroup = <span class="hljs-keyword">new</span> DefaultEventLoopGroup();  <br>    ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    bootstrap<br>            .group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>            .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>                    channel.pipeline()<br>                            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                    ByteBuf buf = (ByteBuf) msg;<br>                                  System.out.println(<span class="hljs-string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                                    <span class="hljs-comment">//由于继承自ScheduledExecutorService，我们直接提交任务就行了，是不是感觉贼方便</span><br>                                    handlerGroup.submit(() -&gt; &#123;   <br>                                        <span class="hljs-keyword">try</span> &#123;<br>                                            Thread.sleep(<span class="hljs-number">10000</span>);<br>                                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                                        &#125;<br>                                        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>                                    &#125;);<br>                                &#125;<br>                            &#125;);<br>                &#125;<br>            &#125;);<br>    bootstrap.bind(<span class="hljs-number">8080</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然我们也可以写成一条流水线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//线程数先限制一下</span><br>    EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">//使用DefaultEventLoop来处理其他任务</span><br>    EventLoopGroup handlerGroup = <span class="hljs-keyword">new</span> DefaultEventLoopGroup();  <br>    ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    bootstrap<br>            .group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>            .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>                    channel.pipeline()<br>                            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                    ByteBuf buf = (ByteBuf) msg;<br>                                    System.out.println(<span class="hljs-string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                                    ctx.fireChannelRead(msg);<br>                                &#125;<br>                            &#125;)<br>                        <span class="hljs-comment">//在添加时，可以直接指定使用哪个EventLoopGroup</span><br>                        .addLast(handlerGroup, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;  <br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                    <span class="hljs-keyword">try</span> &#123;<br>                                        Thread.sleep(<span class="hljs-number">10000</span>);<br>                                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                                    &#125;<br>                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>                                &#125;<br>                            &#125;);<br>                &#125;<br>            &#125;);<br>    bootstrap.bind(<span class="hljs-number">8080</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就进一步地将EventLoop利用起来了。</p><p>按照前面服务端的方式，我们来把Netty版本的客户端也给写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//客户端也是使用Bootstrap来启动</span><br>    Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();   <br>    bootstrap<br>        <span class="hljs-comment">//客户端就没那么麻烦了，直接一个EventLoop就行，用于处理发回来的数据</span><br>            .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())   <br>        <span class="hljs-comment">//客户端肯定就是使用SocketChannel了</span><br>            .channel(NioSocketChannel.class)   <br>        <span class="hljs-comment">//这里的数据处理方式和服务端是一样的</span><br>            .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    channel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ByteBuf buf = (ByteBuf) msg;<br>                            System.out.println(<span class="hljs-string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>    <span class="hljs-comment">//连接后拿到对应的Channel对象</span><br>    Channel channel = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).channel();  <br>  <span class="hljs-comment">//注意上面连接操作是异步的，调用之后会继续往下走，下面我们就正式编写客户端的数据发送代码了</span><br>    <span class="hljs-comment">//还是和之前一样，扫了就发</span><br>    <span class="hljs-keyword">try</span>(Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;    <br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);<br>            String text = scanner.nextLine();<br>            <span class="hljs-keyword">if</span>(text.isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//通过Channel对象发送数据</span><br>            channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));  <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下吧：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-21.png" alt></p><h2 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h2><p>我们接着来看ChannelFuture，前面我们提到，Netty中Channel的相关操作都是异步进行的，并不是在当前线程同步执行，我们不能立即得到执行结果，如果需要得到结果，那么我们就必须要利用到Future。</p><p>我们先来看看ChannelFutuer接口怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelFuture</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//我们可以直接获取此任务的Channel</span><br>    <span class="hljs-function">Channel <span class="hljs-title">channel</span><span class="hljs-params">()</span></span>;    <br>    <span class="hljs-comment">//当任务完成时，会直接执行GenericFutureListener的任务，注意执行的位置也是在EventLoop中</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">addListener</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt; var1)</span></span>;  <br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">addListeners</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt;... var1)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">removeListener</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt; var1)</span></span>;<br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">removeListeners</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt;... var1)</span></span>;<br>    <span class="hljs-comment">//在当前线程同步等待异步任务完成，任务失败会抛出异常</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>; <br>    <span class="hljs-comment">//同上，但是无法响应中断</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">syncUninterruptibly</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-comment">//同上，但是任务中断不会抛出异常，需要手动判断</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>; <br>    <span class="hljs-comment">//不用我说了吧？</span><br>    <span class="hljs-function">ChannelFuture <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//返回类型是否为void</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isVoid</span><span class="hljs-params">()</span></span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>此接口是继承自Netty中的Future接口的（不是JDK的那个）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//再往上才是JDK的Future</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">concurrent</span>.<span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;   <br>    <span class="hljs-comment">//用于判断任务是否执行成功</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSuccess</span><span class="hljs-params">()</span></span>;    <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancellable</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//获取导致任务失败的异常</span><br>    <span class="hljs-function">Throwable <span class="hljs-title">cause</span><span class="hljs-params">()</span></span>;    <br>    <br>  ...<br>    <br>    <span class="hljs-comment">//立即获取结果，如果还未产生结果，得到null，不过ChannelFuture定义V为Void，就算完成了获取也是null</span><br>    <span class="hljs-function">V <span class="hljs-title">getNow</span><span class="hljs-params">()</span></span>;  <br>    <span class="hljs-comment">//取消任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1)</span></span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>Channel的很多操作都是异步完成的，直接返回一个ChannelFuture，比如Channel的write操作，返回的就是一个ChannelFuture对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">.addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));<br>        ChannelFuture future = ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>        <span class="hljs-comment">//通过ChannelFuture来获取相关信息</span><br>        System.out.println(<span class="hljs-string">&quot;任务完成状态：&quot;</span>+future.isDone());   <br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>包括我们的服务端启动也是返回的ChannelFuture：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>&#125;<br>            &#125;);<br>    ChannelFuture future = bootstrap.bind(<span class="hljs-number">8080</span>);<br>    System.out.println(<span class="hljs-string">&quot;服务端启动状态：&quot;</span>+future.isDone());<br>    System.out.println(<span class="hljs-string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，服务端的启动就比较慢了，所以在一开始直接获取状态会返回<code>false</code>，但是这个时候我们又需要等到服务端启动完成之后做一些事情，这个时候该怎么办呢？现在我们就有两种方案了。</p><p><strong>第一种方案：让当前线程同步等待任务完成</strong>，使用<code>sync()</code>方法，这样当前线程会一直阻塞直到任务结束</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">                &#125;<br>            &#125;);<br>    ChannelFuture future = bootstrap.<span class="hljs-built_in">bind</span>(<span class="hljs-number">8080</span>);<br>    future.<span class="hljs-built_in">sync</span>();   <span class="hljs-comment">//让当前线程同步等待任务完成</span><br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;服务端启动状态：&quot;</span>+future.<span class="hljs-built_in">isDone</span>());<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种方案：直接添加监听器</strong>，当任务完成时自动执行，但是注意执行也是异步的，不是在当前线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">                &#125;<br>            &#125;);<br>    ChannelFuture future = bootstrap.bind(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">//直接添加监听器，当任务完成时自动执行，但是注意执行也是异步的，不是在当前线程</span><br>    future.addListener(f -&gt; System.out.println(<span class="hljs-string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>包括客户端的关闭，也是异步进行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);<br>        String text = scanner.nextLine();<br>        <span class="hljs-keyword">if</span>(text.isEmpty()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//输入exit就退出</span><br>        <span class="hljs-keyword">if</span>(text.equals(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;   <br>            ChannelFuture future = channel.close();<br>            <span class="hljs-comment">//等待Channel完全关闭</span><br>            future.sync();    <br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//优雅退出EventLoop，其实就是把还没发送的数据之类的事情做完，当然也可以shutdownNow立即关闭</span><br>    group.shutdownGracefully();   <br>&#125;<br></code></pre></td></tr></table></figure><p>Promise<V>接口继续继承了Future<V>，并增加若干个设置状态并回调的方法，可见，Promise<V>作为一个特殊的Future<V>，只是增加了一些状态设置方法。所以它常用于传入I/O业务代码中，用于I/O结束后设置成功（或失败）状态，并回调方法。</V></V></V></V></p><p>我们接着来看看Promise接口，它支持手动设定成功和失败的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此接口也是继承自Netty中的Future接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//手动设定成功</span><br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">setSuccess</span><span class="hljs-params">(V var1)</span></span>;    <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">trySuccess</span><span class="hljs-params">(V var1)</span></span>;<br>    <span class="hljs-comment">//手动设定失败</span><br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">setFailure</span><span class="hljs-params">(Throwable var1)</span></span>;  <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryFailure</span><span class="hljs-params">(Throwable var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">setUncancellable</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//这些就和之前的Future是一样的了</span><br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">addListener</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt; var1)</span></span>;<br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">addListeners</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt;... var1)</span></span>;<br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">removeListener</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt; var1)</span></span>;<br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">removeListeners</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt;... var1)</span></span>;<br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function">Promise&lt;V&gt; <span class="hljs-title">syncUninterruptibly</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    Promise&lt;String&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(<span class="hljs-keyword">new</span> DefaultEventLoop());<br>    <span class="hljs-comment">//在一开始肯定不是成功的</span><br>    System.out.println(promise.isSuccess()); <br>    <span class="hljs-comment">//设定成功</span><br>    promise.setSuccess(<span class="hljs-string">&quot;lbwnb&quot;</span>);    <br>    <span class="hljs-comment">//再次获取，可以发现确实成功了</span><br>    System.out.println(promise.isSuccess());   <br>    <span class="hljs-comment">//获取结果，就是我们刚刚给进去的</span><br>    System.out.println(promise.get());    <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们可以手动指定成功状态，包括ChannelOutboundInvoker中的一些基本操作，都是支持ChannelPromise的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">.addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = (ByteBuf) msg;<br>        String text = buf.toString(StandardCharsets.UTF_8);<br>        System.out.println(<span class="hljs-string">&quot;接收到客户端发送的数据：&quot;</span>+text);<br>        ChannelPromise promise = <span class="hljs-keyword">new</span> DefaultChannelPromise(channel);<br>        System.out.println(promise.isSuccess());<br>        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()), promise);<br>        promise.sync();  <span class="hljs-comment">//同步等待一下</span><br>        System.out.println(promise.isSuccess());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后结果就是我们想要的了，当然我们也可以像Future那样添加监听器，当成功时自动通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    Promise&lt;String&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(<span class="hljs-keyword">new</span> DefaultEventLoop()); <br>    <span class="hljs-comment">//注意是在上面的DefaultEventLoop执行的</span><br>    promise.addListener(f -&gt; System.out.println(promise.get()));   <br>    System.out.println(promise.isSuccess());<br>    promise.setSuccess(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    System.out.println(promise.isSuccess());<br>&#125;<br></code></pre></td></tr></table></figure><p>有关Future和Promise就暂时讲解到这里。</p><h2 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h2><p>前面我们已经了解了Netty的大部分基础内容，我们接着来看看Netty内置的一些编码器和解码器。</p><p>在前面的学习中，我们的数据发送和接收都是需要以ByteBuf形式传输，但是这样是不是有点太不方便了，咱们能不能参考一下JavaWeb那种搞个Filter，在我们开始处理数据之前，过过滤一次，并在过滤的途中将数据转换成我们想要的类型，也可以将发出的数据进行转换，这就要用到编码解码器了。</p><p>我们先来看看最简的，字符串，如果我们要直接在客户端或是服务端处理字符串，可以直接添加一个字符串解码器到我们的流水线中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>    channel.pipeline()<br>            <span class="hljs-comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span><br>        <span class="hljs-comment">//当客户端发送来的数据只是简单的字符串转换的ByteBuf时，我们直接使用内置的StringDecoder即可转换</span><br>            .addLast(<span class="hljs-keyword">new</span> StringDecoder())   <br>            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-comment">//经过StringDecoder转换后，msg直接就是一个字符串，所以打印就行了</span><br>                    System.out.println(msg);<br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，使用起来还是非常方便的，我们只需要将其添加到流水线即可，实际上StringDecoder本质就是一个ChannelInboundHandlerAdapter：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-22.png" alt></p><p>我们看到它是继承自MessageToMessageDecoder，用于将传入的Message转换为另一种类型，我们也可以自行编写一个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 我们也来搞一个自定义的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;数据已收到，正在进行解码...&quot;</span>);<br>        <span class="hljs-comment">//直接转换为UTF8字符串</span><br>        String text = buf.toString(StandardCharsets.UTF_8);  <br>        <span class="hljs-comment">//解码后需要将解析后的数据丢进List中，如果丢进去多个数据，相当于数据被分成了多个，后面的Handler就需要每个都处理一次</span><br>        list.add(text);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行，可以看到：</p><p><img src alt><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-23.png" alt="image-23"></p><p>当然如果我们在List里面丢很多个数据的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;数据已收到，正在进行解码...&quot;</span>);<br>        <span class="hljs-comment">//直接转换为UTF8字符串</span><br>        String text = buf.toString(StandardCharsets.UTF_8);  <br>        <span class="hljs-comment">//一条消息被解码成三条消息</span><br>        list.add(text);<br>        list.add(text+<span class="hljs-string">&quot;2&quot;</span>);<br>        list.add(text+<span class="hljs-string">&#x27;3&#x27;</span>);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-24.png" alt></p><p>可以看到，后面的Handler会依次对三条数据都进行处理，当然，除了MessageToMessageDecoder之外，还有其他类型的解码器，比如ByteToMessageDecoder等，这里就不一一介绍了，Netty内置了很多的解码器实现来方便我们开发，比如HTTP（下一节介绍），SMTP、MQTT等，以及我们常用的Redis、Memcached、JSON等数据包。</p><p>当然，有了解码器处理发来的数据，那发出去的数据肯定也是需要被处理的，所以编码器就出现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        <span class="hljs-comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span><br>        .addLast(<span class="hljs-keyword">new</span> StringDecoder())<br>        .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;收到客户端的数据：&quot;</span>+msg);<br>                <span class="hljs-comment">//直接发字符串回去</span><br>                ctx.channel().writeAndFlush(<span class="hljs-string">&quot;可以，不跟你多BB&quot;</span>);  <br>            &#125;<br>        &#125;)<br>    <span class="hljs-comment">//使用内置的StringEncoder可以直接将出站的字符串数据编码成ByteBuf</span><br>        .addLast(<span class="hljs-keyword">new</span> StringEncoder());  <br></code></pre></td></tr></table></figure><p>和上面的StringDecoder一样，StringEncoder本质上就是一个ChannelOutboundHandlerAdapter：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-25.png" alt></p><p>是不是感觉前面学习的Handler和Pipeline突然就变得有用了，直接一条线把数据处理安排得明明白白啊。</p><p>现在我们把客户端也改成使用编码、解码器的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>    bootstrap<br>            .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>            .channel(NioSocketChannel.class)<br>            .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    channel.pipeline()<br>                        <span class="hljs-comment">//解码器安排</span><br>                            .addLast(<span class="hljs-keyword">new</span> StringDecoder())  <br>                            .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                    System.out.println(<span class="hljs-string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);  <span class="hljs-comment">//直接接收字符串</span><br>                                &#125;<br>                            &#125;)<br>                        <span class="hljs-comment">//编码器安排</span><br>                            .addLast(<span class="hljs-keyword">new</span> StringEncoder());  <br>                &#125;<br>            &#125;);<br>    Channel channel = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).channel();<br>    <span class="hljs-keyword">try</span>(Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);<br>            String text = scanner.nextLine();<br>            <span class="hljs-keyword">if</span>(text.isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//直接发送字符串就行</span><br>            channel.writeAndFlush(text);  <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的代码量又蹭蹭的减少了很多：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-26.png" alt></p><p>当然，除了编码器和解码器之外，还有编解码器。？？缝合怪？？</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-27.png" alt></p><p>可以看到它是既继承了ChannelInboundHandlerAdapter也实现了ChannelOutboundHandler接口，既能处理出站也能处理入站请求，实际上就是将之前的给组合到一起了，比如我们也可以实现一个缝合在一起的StringCodec类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需要指定两个泛型，第一个是入站的消息类型，还有一个是出站的消息类型，出站是String类型，我们要转成ByteBuf</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">ByteBuf</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String buf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;正在处理出站数据...&quot;</span>);<br>        <span class="hljs-comment">//同样的，添加的数量就是出站的消息数量</span><br>        list.add(Unpooled.wrappedBuffer(buf.getBytes()));   <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;正在处理入站数据...&quot;</span>);<br>        <span class="hljs-comment">//和之前一样，直接一行解决</span><br>        list.add(buf.toString(StandardCharsets.UTF_8));  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到实际上就是需要我们同时去实现编码和解码方法，继承MessageToMessageCodec类即可。</p><p>当然，如果整条流水线上有很多个解码器或是编码器，那么也可以多次进行编码或是解码，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringToStringEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是预处理编码器，就要皮这一下。&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;[已处理] &quot;</span>+s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        <span class="hljs-comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span><br>        .addLast(<span class="hljs-keyword">new</span> StringDecoder())<br>        .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;收到客户端的数据：&quot;</span>+msg);<br>                <span class="hljs-comment">//直接发字符串回去</span><br>                ctx.channel().writeAndFlush(<span class="hljs-string">&quot;可以，不跟你多BB&quot;</span>);  <br>            &#125;<br>        &#125;)<br>    <span class="hljs-comment">//最后再转成ByteBuf</span><br>        .addLast(<span class="hljs-keyword">new</span> StringEncoder())    <br>    <span class="hljs-comment">//先从我们自定义的开始</span><br>        .addLast(<span class="hljs-keyword">new</span> StringToStringEncoder());  <br></code></pre></td></tr></table></figure><p>可以看到，数据在流水线上一层一层处理最后再回到的客户端：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-28.png" alt></p><p>我们在一开始提到的粘包/拆包问题，也可以使用一个解码器解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        .addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">10</span>))  <br>        <span class="hljs-comment">//第一种解决方案，使用定长数据包，每个数据包都要是指定长度</span><br>  ...<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        .addLast(<span class="hljs-keyword">new</span> DelimiterBasedFrameDecoder(<span class="hljs-number">1024</span>, Unpooled.wrappedBuffer(<span class="hljs-string">&quot;!&quot;</span>.getBytes())))<br>        <span class="hljs-comment">//第二种，就是指定一个特定的分隔符，比如我们这里以感叹号为分隔符</span><br>  <span class="hljs-comment">//在收到分隔符之前的所有数据，都作为同一个数据包的内容</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        .addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>        <span class="hljs-comment">//第三种方案，就是在头部添加长度信息，来确定当前发送的数据包具体长度是多少</span><br>        <span class="hljs-comment">//offset是从哪里开始，length是长度信息占多少字节，这里是从0开始读4个字节表示数据包长度</span><br>        .addLast(<span class="hljs-keyword">new</span> StringDecoder())<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        .addLast(<span class="hljs-keyword">new</span> StringDecoder())<br>        .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);<br>            &#125;<br>        &#125;)<br>    <span class="hljs-comment">//客户端在发送时也需要将长度拼到前面去</span><br>        .addLast(<span class="hljs-keyword">new</span> LengthFieldPrepender(<span class="hljs-number">4</span>))   <br>        .addLast(<span class="hljs-keyword">new</span> StringEncoder());<br></code></pre></td></tr></table></figure><p>有关编码器和解码器的内容就先介绍到这里。</p><h2 id="实现HTTP协议通信"><a href="#实现HTTP协议通信" class="headerlink" title="实现HTTP协议通信"></a>实现HTTP协议通信</h2><p>前面我们介绍了Netty为我们提供的编码器和解码器，这里我们就来使用一下支持HTTP协议的编码器和解码器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>    <span class="hljs-comment">//Http请求解码器</span><br>        .addLast(<span class="hljs-keyword">new</span> HttpRequestDecoder())   <br>        .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-comment">//看看是个啥类型</span><br>                System.out.println(<span class="hljs-string">&quot;收到客户端的数据：&quot;</span>+msg.getClass());  <br>              <span class="hljs-comment">//收到浏览器请求后，我们需要给一个响应回去</span><br>                <span class="hljs-comment">//HTTP版本为1.1，状态码就OK（200）即可</span><br>                FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);  <br>              <span class="hljs-comment">//直接向响应内容中写入数据</span><br>                response.content().writeCharSequence(<span class="hljs-string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);<br>                <span class="hljs-comment">//发送响应</span><br>                ctx.channel().writeAndFlush(response);   <br>                <span class="hljs-comment">//HTTP请求是一次性的，所以记得关闭</span><br>                ctx.channel().close();   <br>            &#125;<br>        &#125;)<br>    <span class="hljs-comment">//响应记得也要编码后发送哦</span><br>        .addLast(<span class="hljs-keyword">new</span> HttpResponseEncoder());   <br></code></pre></td></tr></table></figure><p>现在我们用浏览器访问一下我们的服务器吧：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-29.png" alt></p><p>可以看到浏览器成功接收到服务器响应，然后控制台打印了以下类型：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-30.png" alt></p><p>可以看到一次请求是一个DefaultHttpRequest+LastHttpContent$1，这里有两组是因为浏览器请求了一个地址之后紧接着请求了我们网站的favicon图标。</p><p>这样把数据分开处理肯定是不行的，要是直接整合成一个多好，安排：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>    <span class="hljs-comment">//Http请求解码器</span><br>        .addLast(<span class="hljs-keyword">new</span> HttpRequestDecoder())  <br>    <span class="hljs-comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span><br>        .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))  <br>        .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                FullHttpRequest request = (FullHttpRequest) msg;<br>                <span class="hljs-comment">//直接获取请求相关信息</span><br>                System.out.println(<span class="hljs-string">&quot;浏览器请求路径：&quot;</span>+request.uri());  <br>                FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);<br>                response.content().writeCharSequence(<span class="hljs-string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);<br>                ctx.channel().writeAndFlush(response);<br>                ctx.channel().close();<br>            &#125;<br>        &#125;)<br>        .addLast(<span class="hljs-keyword">new</span> HttpResponseEncoder());<br></code></pre></td></tr></table></figure><p>再次访问，我们发现可以正常读取请求路径了：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-31.png" alt></p><p>我们来试试看搞个静态页面代理玩玩，拿出我们的陈年老模板：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-32.png" alt></p><p>全部放进Resource文件夹，一会根据浏览器的请求路径，我们就可以返回对应的页面了，先安排一个解析器，用于解析路径然后将静态页面的内容返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageResolver</span> </span>&#123;<br><span class="hljs-comment">//直接单例模式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PageResolver INSTANCE = <span class="hljs-keyword">new</span> PageResolver();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PageResolver</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageResolver <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>  <span class="hljs-comment">//请求路径给进来，接着我们需要将页面拿到，然后转换成响应数据包发回去</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FullHttpResponse <span class="hljs-title">resolveResource</span><span class="hljs-params">(String path)</span></span>&#123;<br>        <span class="hljs-comment">//判断一下是不是正常的路径请求</span><br>        <span class="hljs-keyword">if</span>(path.startsWith(<span class="hljs-string">&quot;/&quot;</span>))  &#123;  <br>            <span class="hljs-comment">//如果是直接请求根路径，那就默认返回index页面，否则就该返回什么路径的文件就返回什么</span><br>            path = path.equals(<span class="hljs-string">&quot;/&quot;</span>) ? <span class="hljs-string">&quot;index.html&quot;</span> : path.substring(<span class="hljs-number">1</span>);    <br>            <span class="hljs-keyword">try</span>(InputStream stream = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(path)) &#123;<br>                <span class="hljs-comment">//拿到文件输入流之后，才可以返回页面</span><br>                <span class="hljs-keyword">if</span>(stream != <span class="hljs-keyword">null</span>) &#123;   <br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[stream.available()];<br>                    stream.read(bytes);<br>                    <span class="hljs-comment">//数据先读出来，然后交给下面的方法打包</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.packet(HttpResponseStatus.OK, bytes);  <br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//其他情况一律返回404</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.packet(HttpResponseStatus.NOT_FOUND, <span class="hljs-string">&quot;404 Not Found!&quot;</span>.getBytes());<br>    &#125;<br><br>  <span class="hljs-comment">//包装成FullHttpResponse，把状态码和数据写进去</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> FullHttpResponse <span class="hljs-title">packet</span><span class="hljs-params">(HttpResponseStatus status, <span class="hljs-keyword">byte</span>[] data)</span></span>&#123;<br>        FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status);<br>        response.content().writeBytes(data);<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们的静态资源解析就写好了，接着：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>    <span class="hljs-comment">//Http请求解码器</span><br>        .addLast(<span class="hljs-keyword">new</span> HttpRequestDecoder())   <br>    <span class="hljs-comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span><br>        .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))  <br>        .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                FullHttpRequest request = (FullHttpRequest) msg;<br>              <span class="hljs-comment">//请求进来了直接走解析</span><br>                PageResolver resolver = PageResolver.getInstance();<br>                ctx.channel().writeAndFlush(resolver.resolveResource(request.uri()));<br>                ctx.channel().close();<br>            &#125;<br>        &#125;)<br>        .addLast(<span class="hljs-keyword">new</span> HttpResponseEncoder());<br></code></pre></td></tr></table></figure><p>现在我们启动服务器来试试看吧：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-33.png" alt></p><p>可以看到页面可以正常展示了，是不是有Tomcat那味了。</p><h2 id="其他内置Handler介绍"><a href="#其他内置Handler介绍" class="headerlink" title="其他内置Handler介绍"></a>其他内置Handler介绍</h2><p>Netty也为我们内置了一些其他比较好用的Handler，比如我们要打印日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        .addLast(<span class="hljs-keyword">new</span> HttpRequestDecoder())<br>        .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))<br>    <span class="hljs-comment">//添加一个日志Handler，在请求到来时会自动打印相关日志</span><br>        .addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))   <br>        ...<br></code></pre></td></tr></table></figure><p>日志级别我们选择INFO，现在我们用浏览器访问一下：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-34.png" alt></p><p>可以看到每次请求的内容和详细信息都会在日志中出现，包括详细的数据包解析过程，请求头信息都是完整地打印在控制台上的。</p><p>我们也可以使用Handler对IP地址进行过滤，比如我们不希望某些IP地址连接我们的服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        .addLast(<span class="hljs-keyword">new</span> HttpRequestDecoder())<br>        .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))<br>        .addLast(<span class="hljs-keyword">new</span> RuleBasedIpFilter(<span class="hljs-keyword">new</span> IpFilterRule() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> !inetSocketAddress.getHostName().equals(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);  <br>              <span class="hljs-comment">//进行匹配，返回false表示匹配失败</span><br>              <span class="hljs-comment">//如果匹配失败，那么会根据下面的类型决定该干什么，比如我们这里判断是不是本地访问的，如果是那就拒绝</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> IpFilterRuleType <span class="hljs-title">ruleType</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> IpFilterRuleType.REJECT;   <span class="hljs-comment">//类型，REJECT表示拒绝连接，ACCEPT表示允许连接</span><br>            &#125;<br>        &#125;))<br></code></pre></td></tr></table></figure><p>现在我们浏览器访问一下看看：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-35.png" alt></p><p>我们也可以对那些长期处于空闲的进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline()<br>        .addLast(<span class="hljs-keyword">new</span> StringDecoder())<br>    <span class="hljs-comment">//IdleStateHandler能够侦测连接空闲状态</span><br>    <span class="hljs-comment">//第一个参数表示连接多少秒没有读操作时触发事件，第二个是写操作，第三个是读写操作都算，0表示禁用</span><br>        .addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>))  <br>        <span class="hljs-comment">//事件需要在ChannelInboundHandlerAdapter中进行监听处理</span><br>        .addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;收到客户端数据：&quot;</span>+msg);<br>                ctx.channel().writeAndFlush(<span class="hljs-string">&quot;已收到！&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-comment">//没想到吧，这个方法原来是在这个时候用的</span><br>                <span class="hljs-keyword">if</span>(evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;<br>                    IdleStateEvent event = (IdleStateEvent) evt;<br>                    <span class="hljs-keyword">if</span>(event.state() == IdleState.WRITER_IDLE) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;好久都没写了，看视频的你真的有认真在跟着敲吗&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.state() == IdleState.READER_IDLE) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;已经很久很久没有读事件发生了，好寂寞&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br>        .addLast(<span class="hljs-keyword">new</span> StringEncoder());<br></code></pre></td></tr></table></figure><p>可以看到，当我们超过一段时间不发送数据时，就会这样：</p><p><img src="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/image-36.png" alt></p><p>通过这种机制，我们就可以直接关掉那些占着茅坑不拉屎的连接。</p><h2 id="启动流程源码解读"><a href="#启动流程源码解读" class="headerlink" title="启动流程源码解读"></a>启动流程源码解读</h2><p>前面我们完成了对Netty基本功能的讲解，我们最后就来看一下，Netty到底是如何启动以及进行数据处理的。</p><p>首先我们知道，整个服务端是在bind之后启动的，那么我们就从这里开始下手，不多BB直接上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inetPort)</span> </span>&#123;<br>    <span class="hljs-comment">//转换成InetSocketAddress对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bind(<span class="hljs-keyword">new</span> InetSocketAddress(inetPort));   <br>&#125;<br></code></pre></td></tr></table></figure><p>进来之后发现是调用的其他绑定方法，继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;<br>    <span class="hljs-comment">//再次验证一下，看看EventLoopGroup和Channel指定了没</span><br>    <span class="hljs-keyword">this</span>.validate();   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.doBind((SocketAddress)ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;<br>    <span class="hljs-comment">//上来第一句初始化然后注册</span><br>    <span class="hljs-keyword">final</span> ChannelFuture regFuture = <span class="hljs-keyword">this</span>.initAndRegister();   <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看看是怎么注册的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;<br>    Channel channel = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过channelFactory创建新的Channel，实际上就是我们在一开始设定的NioServerSocketChannel</span><br>        channel = <span class="hljs-keyword">this</span>.channelFactory.newChannel();  <br>        <span class="hljs-comment">//接着对创建好的NioServerSocketChannel进行初始化</span><br>        <span class="hljs-keyword">this</span>.init(channel);    <br>    ...<br><br>    <span class="hljs-comment">//将通道注册到bossGroup中的一个EventLoop中</span><br>    ChannelFuture regFuture = <span class="hljs-keyword">this</span>.config().group().register(channel); <br>    ...<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看是如何对创建好的ServerSocketChannel进行初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    setChannelOptions(channel, <span class="hljs-keyword">this</span>.newOptionsArray(), logger);<br>    setAttributes(channel, <span class="hljs-keyword">this</span>.newAttributesArray());<br>    ChannelPipeline p = channel.pipeline();<br>    ...<br>    <span class="hljs-comment">//在流水线上添加一个Handler，在Handler初始化的时候向EventLoop中提交一个任务，</span><br>    <span class="hljs-comment">//将ServerBootstrapAcceptor添加到流水线上，这样我们的ServerSocketChannel在客户端连接时就能Accept了</span><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelHandler[]&#123;<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            ChannelHandler handler = ServerBootstrap.<span class="hljs-keyword">this</span>.config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(<span class="hljs-keyword">new</span> ChannelHandler[]&#123;handler&#125;);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                  <span class="hljs-comment">//这里提交一个任务，将ServerBootstrapAcceptor添加到ServerSocketChannel的pipeline中</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ChannelHandler[]&#123;<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看一下，ServerBootstrapAcceptor怎么处理的，直接看到它的<code>channelRead</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当底层NIO的ServerSocketChannel的Selector有OP_ACCEPT事件到达时，NioEventLoop会接收客户端连接，创建SocketChannel，并触发channelRead回调</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>  <span class="hljs-comment">//此时msg就是Accept连接创建之后的Channel对象</span><br>    <span class="hljs-keyword">final</span> Channel child = (Channel)msg;<br>  <span class="hljs-comment">//这里直接将我们之前编写的childHandler添加到新创建的客户端连接的流水线中（是不是感觉突然就通了）</span><br>    child.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelHandler[]&#123;<span class="hljs-keyword">this</span>.childHandler&#125;);<br>    AbstractBootstrap.setChannelOptions(child, <span class="hljs-keyword">this</span>.childOptions, ServerBootstrap.logger);<br>    AbstractBootstrap.setAttributes(child, <span class="hljs-keyword">this</span>.childAttrs);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//直接向workGroup中的一个EventLoop注册新创建好的客户端连接Channel，等待读写事件</span><br>        <span class="hljs-keyword">this</span>.childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>          <span class="hljs-comment">//异步操作完成后，如果没有注册成功，就强制关闭这个Channel</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());<br>                ...<br></code></pre></td></tr></table></figure><p>所以，实际上就是我们之前讲解的主从Reactor多线程模型，只要前面理解了，这里其实很好推断。</p><p>初始化完成之后，我们来看看注册，在之前NIO阶段我们也是需要将Channel注册到对应的Selector才可以开始选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">register</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    <span class="hljs-comment">//转换成ChannelPromise继续</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.register((ChannelPromise)(<span class="hljs-keyword">new</span> DefaultChannelPromise(channel, <span class="hljs-keyword">this</span>)));  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">register</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(promise, <span class="hljs-string">&quot;promise&quot;</span>);<br>    <span class="hljs-comment">//调用Channel的Unsafe接口实现进行注册</span><br>    promise.channel().unsafe().register(<span class="hljs-keyword">this</span>, promise);   <br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续向下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ...<br>        AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br>        <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>            <span class="hljs-comment">//这里是继续调用register0方法在进行注册</span><br>            <span class="hljs-keyword">this</span>.register0(promise);    <br>        &#125;<br>  ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br><br>        <span class="hljs-keyword">boolean</span> firstRegistration = <span class="hljs-keyword">this</span>.neverRegistered;<br>        <span class="hljs-comment">//这里开始执行AbstractNioChannel中的doRegister方法进行注册</span><br>        AbstractChannel.<span class="hljs-keyword">this</span>.doRegister();    <br>      AbstractChannel.<span class="hljs-keyword">this</span>.registered = <span class="hljs-keyword">true</span>;<br>        AbstractChannel.<span class="hljs-keyword">this</span>.pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-keyword">this</span>.safeSetSuccess(promise);<br>      <span class="hljs-keyword">if</span> (AbstractChannel.<span class="hljs-keyword">this</span>.isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">//这里是关键</span><br>                AbstractChannel.<span class="hljs-keyword">this</span>.pipeline.fireChannelActive();   <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (AbstractChannel.<span class="hljs-keyword">this</span>.config().isAutoRead()) &#123;<br>                <span class="hljs-keyword">this</span>.beginRead();<br>            &#125;<br>        &#125;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>来到最后一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//可以看到在这里终于是真正的进行了注册，javaChannel()得到NIO的Channel对象，然后调用register方法</span><br>          <span class="hljs-comment">//这里就和我们之前NIO一样了，将Channel注册到Selector中，可以看到Selector也是EventLoop中的</span><br>          <span class="hljs-comment">//但是注意，这里的ops参数是0，也就是不监听任何事件</span><br>            <span class="hljs-keyword">this</span>.selectionKey = <span class="hljs-keyword">this</span>.javaChannel().register(<span class="hljs-keyword">this</span>.eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们回到上一级，在doRegister完成之后，会拿到selectionKey，但是注意这时还没有监听任何事件，我们接着看到下面的fireChannelActive方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//传的是流水线上的默认头结点</span><br>    AbstractChannelHandlerContext.invokeChannelActive(<span class="hljs-keyword">this</span>.head);   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelActive</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;<br>    EventExecutor executor = next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-comment">//继续向下</span><br>        next.invokeChannelActive();   <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeChannelActive();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelActive</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//依然是调用的头结点的channelActive方法进行处理</span><br>            ((ChannelInboundHandler)<span class="hljs-keyword">this</span>.handler()).channelActive(<span class="hljs-keyword">this</span>);   <br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var2) &#123;<br>            <span class="hljs-keyword">this</span>.invokeExceptionCaught(var2);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.fireChannelActive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里是头结点的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;   <br>    ctx.fireChannelActive();   <br>    <span class="hljs-comment">//继续向下</span><br>    <span class="hljs-keyword">this</span>.readIfIsAutoRead();   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readIfIsAutoRead</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DefaultChannelPipeline.<span class="hljs-keyword">this</span>.channel.config().isAutoRead()) &#123;<br>        <span class="hljs-comment">//继续不断向下</span><br>        DefaultChannelPipeline.<span class="hljs-keyword">this</span>.channel.read();    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    <span class="hljs-comment">//最后这里会调用beginRead方法</span><br>    <span class="hljs-keyword">this</span>.unsafe.beginRead();   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beginRead</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.assertEventLoop();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//这里就是调用AbstractNioChannel的doBeginRead方法了</span><br>        AbstractChannel.<span class="hljs-keyword">this</span>.doBeginRead();    <br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Exception var2) &#123;<br>        <span class="hljs-keyword">this</span>.invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                AbstractChannel.<span class="hljs-keyword">this</span>.pipeline.fireExceptionCaught(var2);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">this</span>.close(<span class="hljs-keyword">this</span>.voidPromise());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//先拿到之前注册好的selectionKey</span><br>    SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;    <br>    <span class="hljs-keyword">if</span> (selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">this</span>.readPending = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//把监听的操作取出来</span><br>        <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();  <br>        <span class="hljs-comment">//如果没有监听任何操作</span><br>        <span class="hljs-keyword">if</span> ((interestOps &amp; <span class="hljs-keyword">this</span>.readInterestOp) == <span class="hljs-number">0</span>) &#123;   <br>            <span class="hljs-comment">//那就把readInterestOp事件进行监听，这里的readInterestOp实际上就是OP_ACCEPT</span><br>            selectionKey.interestOps(interestOps | <span class="hljs-keyword">this</span>.readInterestOp);   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，Channel在初始化完成之后也完成了底层的注册，已经可以开始等待事件了。</p><p>我们现在回到之前的<code>doBind</code>方法的注册位置，现在注册完成之后，基本上整个主从Reactor结构就已经出来了，我们来看看还要做些什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;<br>    <span class="hljs-comment">//目前初始化和注册都已经成功了</span><br>    <span class="hljs-keyword">final</span> ChannelFuture regFuture = <span class="hljs-keyword">this</span>.initAndRegister();  <br>    <span class="hljs-comment">//由于是异步操作，我们通过ChannelFuture拿到对应的ServerSocketChannel对象</span><br>    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();    <br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;   <br>        <span class="hljs-comment">//如果说初始化已经完成了</span><br>        ChannelPromise promise = channel.newPromise();<br>        <span class="hljs-comment">//直接开始进行进一步的绑定</span><br>        doBind0(regFuture, channel, localAddress, promise);   <br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果还没搞完，那就创Promis继续等待任务完成</span><br>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);<br>        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Throwable cause = future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    promise.registered();<br>                    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br><br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最后都会走到<code>doBind0</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>  <span class="hljs-comment">//最后会向Channel已经注册到的EventLoop中提交一个新的任务</span><br>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;<br>              <span class="hljs-comment">//这里才是真正调用Channel底层进行绑定操作</span><br>                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                promise.setFailure(regFuture.cause());<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，服务端的启动流程结束。我们前面还提到了NIO的空轮询问题，这里我们来看看Netty是如何解决的，我们直接定位到NioEventLoop中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于代码太多，这里省略大部分代码</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">boolean</span> var34;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasTasks()) &#123;<br>                                <span class="hljs-comment">//首先会在这里进行Selector.select()操作，跟NIO是一样的</span><br>                                strategy = <span class="hljs-keyword">this</span>.select(curDeadlineNanos);   <br>                            &#125;<br>           ...<br>               <br><span class="hljs-comment">//每次唤醒都会让selectCnt自增</span><br>            ++selectCnt;    <br>            <span class="hljs-keyword">this</span>.cancelledKeys = <span class="hljs-number">0</span>;<br>            <br>          ...<br><br>            <span class="hljs-keyword">if</span> (!ranTasks &amp;&amp; strategy &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//这里会进行判断是否出现空轮询BUG</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.unexpectedSelectorWakeup(selectCnt)) &#123;   <br>           ...<br></code></pre></td></tr></table></figure><p>我们来看看是怎么进行判断的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unexpectedSelectorWakeup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> selectCnt)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely because Thread.currentThread().interrupt() was called. Use NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//如果selectCnt大于等于SELECTOR_AUTO_REBUILD_THRESHOLD（默认为512）那么会直接重建Selector</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, <span class="hljs-keyword">this</span>.selector);<br>        <span class="hljs-comment">//当前的Selector出现BUG了，得重建一个Selector</span><br>        <span class="hljs-keyword">this</span>.rebuildSelector();   <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，当每次空轮询发生时会有专门的计数器+1，如果空轮询的次数超过了512次，就认为其触发了空轮询bug，触发bug后，Netty直接重建一个Selector，将原来的Channel重新注册到新的 Selector上，将旧的 Selector关掉，这样就防止了无限循环。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO笔记（一）基础内容</title>
    <link href="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>在JavaSE的学习中，我们了解了如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。</p><p>Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作。</p><p>NIO框架是在JDK1.4推出的，它的出现就是为了解决传统IO的不足。</p><h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><p>一切的一切还要从缓冲区开始讲起，包括源码在内，其实这个不是很难，只是需要理清思路。</p><h2 id="Buffer类及其实现"><a href="#Buffer类及其实现" class="headerlink" title="Buffer类及其实现"></a>Buffer类及其实现</h2><p>Buffer类是缓冲区的实现，类似于Java中的数组，也是用于存放和获取数据的。但是Buffer相比Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作。</p><p>Buffer是一个抽象类，它的核心内容：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buffer</span> </span>&#123;<br>    <span class="hljs-comment">// 这四个变量的关系: mark &lt;= position &lt;= limit &lt;= capacity</span><br>  <span class="hljs-comment">// 这些变量就是Buffer操作的核心了，之后我们学习的过程中可以看源码是如何操作这些变量的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-comment">// 直接缓冲区实现子类的数据内存地址（之后会讲解）</span><br>    <span class="hljs-keyword">long</span> address;<br></code></pre></td></tr></table></figure><p>我们来看看Buffer类的子类，包括我们认识到的所有基本类型（除了<code>boolean</code>类型之外）：</p><ul><li><p>IntBuffer  -  int类型的缓冲区。</p></li><li><p>ShortBuffer  -  short类型的缓冲区。</p></li><li><p>LongBuffer  -  long类型的缓冲区。</p></li><li><p>FloatBuffer  -  float类型的缓冲区。</p></li><li><p>DoubleBuffer  -  double类型的缓冲区。</p></li><li><p>ByteBuffer  -  byte类型的缓冲区。</p></li><li><p>CharBuffer  -  char类型的缓冲区。</p></li></ul><p>（注意我们之前在JavaSE中学习过的StringBuffer虽然也是这种命名方式，但是不属于Buffer体系，这里不会进行介绍）</p><p>这里我们以IntBuffer为例，我们来看看如何创建一个Buffer类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式：</span><br>    <span class="hljs-comment">//1. 申请一个容量为10的int缓冲区</span><br>    IntBuffer buffer = IntBuffer.allocate(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//2. 可以将现有的数组直接转换为缓冲区（包括数组中的数据）</span><br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    IntBuffer buffer = IntBuffer.wrap(arr);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么它的内部是本质上如何进行操作的呢？我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntBuffer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//如果申请的容量小于0，那还有啥意思</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-comment">//可以看到这里会直接创建一个新的IntBuffer实现类</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapIntBuffer(capacity, capacity);   <br>  <span class="hljs-comment">//HeapIntBuffer是在堆内存中存放数据，本质上就数组，一会我们可以在深入看一下</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntBuffer <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>    <span class="hljs-comment">//调用的是下面的wrap方法</span><br>    <span class="hljs-keyword">return</span> wrap(array, <span class="hljs-number">0</span>, array.length);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntBuffer <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//可以看到这个也是创建了一个新的HeapIntBuffer对象，并且给了初始数组以及截取的起始位置和长度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapIntBuffer(array, offset, length);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException x) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个HeapIntBuffer又是如何实现的呢，我们接着来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这个构造方法不是public，是默认的访问权限</span><br>HeapIntBuffer(<span class="hljs-keyword">int</span>[] buf, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len) &#123; <br>    <span class="hljs-comment">//结果发现HeapIntBuffer居然是调父类IntBuffer的构造方法</span><br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, off, off + len, buf.length, buf, <span class="hljs-number">0</span>); <br>  <span class="hljs-comment">//mark是标记，off是当前起始下标位置，off+len是最大下标位置，buf.length是底层维护的数组真正长度，buf就是数组，最后一个0是起始偏移位置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们又来看看IntBuffer中的构造方法是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] hb;                  <span class="hljs-comment">//只有在堆缓冲区实现时才会使用</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset;<br><span class="hljs-keyword">boolean</span> isReadOnly;                 <span class="hljs-comment">//只有在堆缓冲区实现时才会使用</span><br><br><span class="hljs-comment">//注意这个构造方法不是public，是默认的访问权限</span><br>IntBuffer(<span class="hljs-keyword">int</span> mark, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> lim, <span class="hljs-keyword">int</span> cap,   <br>             <span class="hljs-keyword">int</span>[] hb, <span class="hljs-keyword">int</span> offset)<br>&#123;<br>    <span class="hljs-comment">//结果发现IntBuffer居然是调用父类Buffer的构造方法</span><br>    <span class="hljs-keyword">super</span>(mark, pos, lim, cap);  <br>    <span class="hljs-comment">//hb就是真正我们要存放数据的数组，堆缓冲区底层其实就是这么一个数组</span><br>    <span class="hljs-keyword">this</span>.hb = hb;   <br>    <span class="hljs-comment">//起始偏移位置</span><br>    <span class="hljs-keyword">this</span>.offset = offset;   <br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们来看看Buffer中的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这个构造方法不是public，是默认的访问权限</span><br>Buffer(<span class="hljs-keyword">int</span> mark, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> lim, <span class="hljs-keyword">int</span> cap) &#123;   <br>    <span class="hljs-comment">//容量不能小于0，小于0还玩个锤子</span><br>    <span class="hljs-keyword">if</span> (cap &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Negative capacity: &quot;</span> + cap);<br>    <span class="hljs-comment">//设定缓冲区容量</span><br>    <span class="hljs-keyword">this</span>.capacity = cap;  <br>    <span class="hljs-comment">//设定最大限制</span><br>    limit(lim); <br>    <span class="hljs-comment">//设定起始位置</span><br>    position(pos);  <br>    <span class="hljs-comment">//如果起始标记大于等于0</span><br>    <span class="hljs-keyword">if</span> (mark &gt;= <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">//并且标记位置大于起始位置，那么就抛异常（至于为啥不能大于我们后面再说）</span><br>        <span class="hljs-keyword">if</span> (mark &gt; pos)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;mark &gt; position: (&quot;</span><br>                                               + mark + <span class="hljs-string">&quot; &gt; &quot;</span> + pos + <span class="hljs-string">&quot;)&quot;</span>);<br>        <span class="hljs-comment">//否则设定mark位置（mark默认为-1）</span><br>        <span class="hljs-keyword">this</span>.mark = mark;   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对源码的观察，我们大致可以得到以下结构了：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-1.png" alt></p><p>现在我们来总结一下上面这些结构的各自职责划分：</p><ul><li><p>Buffer：缓冲区的一些基本变量定义，比如当前的位置（position）、容量 (capacity)、最大限制 (limit)、标记 (mark)等，你肯定会疑惑这些变量有啥用，别着急，这些变量会在后面的操作中用到，我们逐步讲解。</p></li><li><p>IntBuffer等子类：定义了存放数据的数组（只有堆缓冲区实现子类才会用到）、是否只读等，也就是说数据的存放位置、以及对于底层数组的相关操作都在这里已经定义好了，并且已经实现了Comparable接口。</p></li><li><p>HeapIntBuffer堆缓冲区实现子类：数据存放在堆中，实际上就是用的父类的数组在保存数据，并且将父类定义的所有底层操作全部实现了。</p></li></ul><p>这样，我们对于Buffer类的基本结构就有了一个大致的认识。</p><h2 id="缓冲区写操作"><a href="#缓冲区写操作" class="headerlink" title="缓冲区写操作"></a>缓冲区写操作</h2><p>前面我们了解了Buffer类的基本操作，现在我们来看一下如何向缓冲区中存放数据以及获取数据，数据的存放包括以下5个方法：</p><ul><li><p>public abstract IntBuffer put(int i);  -  在当前position位置插入数据，由具体子类实现</p></li><li><p>public abstract IntBuffer put(int index, int i);  -  在指定位置存放数据，也是由具体子类实现</p></li><li>public final IntBuffer put(int[] src);  -  直接存放所有数组中的内容（数组长度不能超出缓冲区大小）</li><li><p>public IntBuffer put(int[] src, int offset, int length);  -  直接存放数组中的内容，同上，但是可以指定存放一段范围</p></li><li><p>public IntBuffer put(IntBuffer src);  -  直接存放另一个缓冲区中的内容</p></li></ul><p>第一个<code>public abstract IntBuffer put(int i);</code>方法开始，在当前位置插入一个数据，那么这个当前位置是怎么定义的呢，我们来看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">//这个ix和nextPutIndex()很灵性，我们来看看具体实现</span><br>    hb[ix(nextPutIndex())] = x;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span><br>    <span class="hljs-keyword">return</span> i + offset;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextPutIndex</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//位置肯定不能超过底层数组最大长度，否则越界</span><br>    <span class="hljs-keyword">if</span> (position &gt;= limit)    <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BufferOverflowException();<br>    <span class="hljs-comment">//返回position的值（一开始也是0）并自增</span><br>    <span class="hljs-keyword">return</span> position++; <br>&#125;<br></code></pre></td></tr></table></figure><p>所以put操作实际上是将底层数组<code>hb</code>在position位置上的数据进行设定。</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-2.png" alt></p><p>设定完成后，position自动后移：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-3.png" alt></p><p>我们可以编写代码来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.allocate(<span class="hljs-number">10</span>);<br>    buffer<br>            .put(<span class="hljs-number">1</span>)<br>            .put(<span class="hljs-number">2</span>)<br>            .put(<span class="hljs-number">3</span>);   <span class="hljs-comment">//我们依次存放三个数据试试看</span><br>    System.out.println(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过断点调试，我们来看看实际的操作情况：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-4.png" alt></p><p>可以看到我们不断地put操作，position会一直向后移动，当然如果超出最大长度，那么会直接抛出异常：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-5.png" alt></p><p>第二个<code>public abstract IntBuffer put(int index, int i);</code>方法操作是如何进行，它能够在指定位置插入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">//这里依然会使用ix，但是会用checkIndex检查位置是否合法</span><br>    hb[ix(checkIndex(i))] = x;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span><br>    <span class="hljs-keyword">return</span> i + offset;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">//插入的位置不能小于0并且不能大于等于底层数组最大长度</span><br>    <span class="hljs-keyword">if</span> ((i &lt; <span class="hljs-number">0</span>) || (i &gt;= limit))    <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();<br>    <span class="hljs-comment">//没有问题就把i返回</span><br>    <span class="hljs-keyword">return</span> i;   <br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这个比我们之前的要好理解一些，注意全程不会操作position的值，这里需要注意一下。</p><p>第三个<code>public final IntBuffer put(int[] src);</code>方法，它是直接在IntBuffer中实现的，是基于前两个put方法的子类实现来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;<br>    <span class="hljs-comment">//因为不需要指定范围，所以直接0和length，然后调用下面的put方法</span><br>    <span class="hljs-keyword">return</span> put(src, <span class="hljs-number">0</span>, src.length);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">//检查截取范围是否合法，给offset、调用者指定长度、数组实际长度</span><br>    checkBounds(offset, length, src.length);   <br>    <span class="hljs-comment">//接着判断要插入的数据量在缓冲区是否装得下</span><br>    <span class="hljs-keyword">if</span> (length &gt; remaining())   <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BufferOverflowException();<br>    <span class="hljs-comment">//计算出最终读取位置，下面开始for循环</span><br>    <span class="hljs-keyword">int</span> end = offset + length;   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = offset; i &lt; end; i++)<br>        <span class="hljs-keyword">this</span>.put(src[i]);   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//计算并获取当前缓冲区的剩余空间</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">remaining</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-comment">//最大容量减去当前位置，就是剩余空间</span><br>    <span class="hljs-keyword">int</span> rem = limit - position;  <br>    <span class="hljs-comment">//没容量就返回0</span><br>    <span class="hljs-keyword">return</span> rem &gt; <span class="hljs-number">0</span> ? rem : <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkBounds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> size)</span> </span>&#123; <span class="hljs-comment">// package-private</span><br>    <span class="hljs-keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">//让我猜猜，看不懂了是吧</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();<br>  <span class="hljs-comment">//实际上就是看给定的数组能不能截取出指定的这段数据，如果都不够了那肯定不行啊</span><br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程如下，首先来了一个数组要取一段数据丢进缓冲区：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-6.png" alt></p><p>在检查没有什么问题并且缓冲区有容量时，就可以开始插入了：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-7.png" alt></p><p>我们通过代码来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.allocate(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    buffer.put(arr, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">//从下标3开始，截取4个元素</span><br><br>    System.out.println(Arrays.toString(buffer.array()));  <span class="hljs-comment">//array方法可以直接获取到数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最后结果为：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[4, 5, 6, 7, 0, 0, 0, 0, 0, 0]</span><br><br>进程已结束,退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>第四个<code>public IntBuffer put(int[] src, int offset, int length);</code>方法，就是第三个put方法的具体实现，可以传入offset和length参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">//检查截取范围是否合法，给offset、调用者指定长度、数组实际长度</span><br>    checkBounds(offset, length, src.length);   <br>    <span class="hljs-comment">//接着判断要插入的数据量在缓冲区是否装得下</span><br>    <span class="hljs-keyword">if</span> (length &gt; remaining())   <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BufferOverflowException();<br>    <span class="hljs-comment">//计算出最终读取位置，下面开始for循环</span><br>    <span class="hljs-keyword">int</span> end = offset + length;   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = offset; i &lt; end; i++)<br>        <span class="hljs-keyword">this</span>.put(src[i]);   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第五个<code>public IntBuffer put(IntBuffer src);</code> 方法，将一个缓冲区的内容保存到另一个缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(IntBuffer src)</span> </span>&#123;<br>    <span class="hljs-comment">//不会吧不会吧，不会有人保存自己吧</span><br>    <span class="hljs-keyword">if</span> (src == <span class="hljs-keyword">this</span>)   <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-comment">//如果是只读的话，那么也是不允许插入操作的（我猜你们肯定会问为啥就这里会判断只读，前面四个呢）</span><br>    <span class="hljs-keyword">if</span> (isReadOnly())   <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadOnlyBufferException();<br>    <span class="hljs-comment">//给src看看容量（注意这里remaining的结果不是剩余容量，是转换后的，之后会说）</span><br>    <span class="hljs-keyword">int</span> n = src.remaining(); <br>    <span class="hljs-comment">//这里判断当前剩余容量是否小于src容量</span><br>    <span class="hljs-keyword">if</span> (n &gt; remaining())    <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BufferOverflowException();<br>    <span class="hljs-comment">//也是从position位置开始继续写入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)   <br>        <span class="hljs-comment">//通过get方法一个一个读取数据出来，具体过程后面讲解</span><br>        put(src.get());   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来通过代码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer src = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    IntBuffer buffer = IntBuffer.allocate(<span class="hljs-number">10</span>);<br>    buffer.put(src);<br>    System.out.println(Arrays.toString(buffer.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>但是如果是这样的话，会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer src = IntBuffer.allocate(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>        src.put(i);   <span class="hljs-comment">//手动插入数据</span><br>    &#125; <br>    IntBuffer buffer = IntBuffer.allocate(<span class="hljs-number">10</span>);<br>    buffer.put(src);<br>    System.out.println(Arrays.toString(buffer.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>我们发现，结果和上面的不一样，并没有成功地将数据填到下面的IntBuffer中，这是为什么呢？实际上就是因为<code>remaining()</code>的计算问题，因为这个方法是直接计算postion的位置，但是由于我们在写操作完成之后，position跑到后面去了，也就导致<code>remaining()</code>结果最后算出来为0。</p><p>因为这里不是写操作，而是需要从头开始进行<code>读操作</code>，所以我们得想个办法把position给退回到一开始的位置，这样才可以从头开始读取，那么怎么做呢？一般我们在写入完成后需要进行读操作时（后面都是这样，不只是这里），会使用<code>flip()</code>方法进行翻转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title">flip</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//修改limit值，当前写到哪里，下次读的最终位置就是哪里，limit的作用开始慢慢体现了</span><br>    limit = position;<br>    <span class="hljs-comment">//position归零</span><br>    position = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//标记还原为-1，但是现在我们还没用到</span><br>    mark = -<span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，再次计算<code>remaining()</code>的结果就是我们需要读取的数量了，这也是为什么put方法中要用<code>remaining()</code>来计算的原因，我们再来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer src = IntBuffer.allocate(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>       src.put(i);    <span class="hljs-comment">//手动插入数据</span><br>    &#125; <br>    IntBuffer buffer = IntBuffer.allocate(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//我们可以通过flip来翻转缓冲区</span><br>    src.flip();   <br>    buffer.put(src);<br>    System.out.println(Arrays.toString(buffer.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>翻转之后再次进行转移，就正常了。</p><h2 id="缓冲区读操作"><a href="#缓冲区读操作" class="headerlink" title="缓冲区读操作"></a>缓冲区读操作</h2><p>前面我们看完了写操作，现在我们接着来看看读操作。读操作有四个方法：</p><ul><li><p>public abstract int get(); - 直接获取当前position位置的数据，由子类实现</p></li><li><p>public abstract int get(int index); - 获取指定位置的数据，也是子类实现</p></li><li><p>public IntBuffer get(int[] dst); - 将数据读取到给定的数组中</p></li><li><p>public IntBuffer get(int[] dst, int offset, int length); - 同上，加了个范围</p></li></ul><p>第一个<code>public abstract int get();</code>方法,直接获取当前position位置的数据，由子类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//直接从数组中取就完事</span><br>    <span class="hljs-keyword">return</span> hb[ix(nextGetIndex())];    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span><br>    <span class="hljs-keyword">return</span> i + offset;   <br>&#125;<br><br><span class="hljs-comment">// 好家伙，这不跟前面那个nextPutIndex一模一样吗</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextGetIndex</span><span class="hljs-params">()</span> </span>&#123;                          <br>  <span class="hljs-keyword">if</span> (position &gt;= limit)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BufferUnderflowException();<br>  <span class="hljs-keyword">return</span> position++;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每次读取操作之后，也会将postion++，直到最后一个位置，如果还要继续读，那么就直接抛出异常。</p><p>第二个<code>public abstract int get(int index);</code>方法，获取指定位置的数据，也是子类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> hb[ix(checkIndex(i))];   <span class="hljs-comment">//这里依然是使用checkIndex来检查位置是否非法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第三个<code>public IntBuffer get(int[] dst);</code>方法，将数据读取到给定的数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] dst)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> get(dst, <span class="hljs-number">0</span>, dst.length);   <span class="hljs-comment">//不需要指定offset和length，具体实现由下面的get方法完成</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] dst, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    checkBounds(offset, length, dst.length);   <span class="hljs-comment">//跟put操作一样，也是需要检查是否越界</span><br>    <span class="hljs-keyword">if</span> (length &gt; remaining())   <span class="hljs-comment">//如果读取的长度比可以读的长度大，那肯定是不行的</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BufferUnderflowException();<br>    <span class="hljs-keyword">int</span> end = offset + length;    <span class="hljs-comment">//计算出最终读取位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = offset; i &lt; end; i++)<br>        dst[i] = get();   <span class="hljs-comment">//开始从position把数据读到数组中，注意是在数组的offset位置开始</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四个<code>public IntBuffer get(int[] dst, int offset, int length);</code>方法，是第三个get方法的具体实现，加了个范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] dst, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    checkBounds(offset, length, dst.length);   <span class="hljs-comment">//跟put操作一样，也是需要检查是否越界</span><br>    <span class="hljs-keyword">if</span> (length &gt; remaining())   <span class="hljs-comment">//如果读取的长度比可以读的长度大，那肯定是不行的</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BufferUnderflowException();<br>    <span class="hljs-keyword">int</span> end = offset + length;    <span class="hljs-comment">//计算出最终读取位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = offset; i &lt; end; i++)<br>        dst[i] = get();   <span class="hljs-comment">//开始从position把数据读到数组中，注意是在数组的offset位置开始</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码来看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    <span class="hljs-comment">//将buffer缓冲区的数据读取到arr数组中</span><br>    buffer.get(arr, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>可以看到成功地将数据读取到了数组中。</p><p>当然如果我们需要直接获取已采用缓冲区的数组，也可以使用<code>array()</code>方法，用于返回已采用缓冲区的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] array() &#123;<br>    <span class="hljs-keyword">if</span> (hb == <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//为空那说明底层不是数组实现的，肯定就没法转换了</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    <span class="hljs-keyword">if</span> (isReadOnly)   <span class="hljs-comment">//只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadOnlyBufferException();<br>    <span class="hljs-keyword">return</span> hb;   <span class="hljs-comment">//直接返回hb</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    System.out.println(Arrays.toString(buffer.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>当然，既然都已经拿到了底层的<code>hb</code>数组了，我们来看看如果直接修改之后是不是读取到的就是我们的修改之后的结果了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    <span class="hljs-keyword">int</span>[] arr = buffer.array();<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>;   <span class="hljs-comment">//对到底层数组对象直接修改</span><br>    System.out.println(buffer.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">99999<br></code></pre></td></tr></table></figure><p>可以看到由于这种方式是直接拿到的底层数组，因此所有修改会直接生效在缓冲区中。</p><p>当然除了常规的读取方式之外，我们也可以通过<code>mark()</code>来实现跳转读取，这里需要介绍一下几个操作：</p><ul><li><p><code>public final Buffer mark()</code>  -  标记当前位置</p></li><li><p><code>public final Buffer reset()</code>  -  让当前的position位置跳转到mark当时标记的位置</p></li></ul><p>我们首先来看mark()标记方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title">mark</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//直接标记到当前位置，mark变量终于派上用场了，当然这里仅仅是标记</span><br>    mark = position;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看看reset()重置方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//存一下当前的mark位置</span><br>    <span class="hljs-keyword">int</span> m = mark; <br>    <span class="hljs-comment">//因为mark默认是-1，要是没有进行过任何标记操作，那reset个锤子</span><br>    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>)    <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidMarkException();<br>    <span class="hljs-comment">//直接让position变成mark位置</span><br>    position = m;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>, <span class="hljs-number">444</span>, <span class="hljs-number">555</span>&#125;);<br>    System.out.println(buffer.get());<span class="hljs-comment">//position默认是0，读取一位后，position就变成1了</span><br>    buffer.mark();   <span class="hljs-comment">//这时标记，那么 mark = position = 1</span><br>    System.out.println(buffer.get());   <span class="hljs-comment">//又读取一位，那么position就变成2了</span><br>    buffer.reset();    <span class="hljs-comment">//直接将 position = mark = 1 ，也就是变回1</span><br>    System.out.println(buffer.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">111<br>222<br>222<br></code></pre></td></tr></table></figure><p>可以看到，读取的位置根据我们的标记和重置操作进行了变化，有关缓冲区的读操作，就暂时讲到这里。</p><h2 id="缓冲区其他操作"><a href="#缓冲区其他操作" class="headerlink" title="缓冲区其他操作"></a>缓冲区其他操作</h2><p>前面我们大致了解了一下缓冲区的读写操作，那么我们接着来看看，除了常规的读写操作之外，还有哪些其他的操作：</p><ul><li><p><code>public abstract IntBuffer compact()</code>  -  压缩缓冲区，由具体实现类实现</p></li><li><p><code>public IntBuffer duplicate()</code>  -  复制缓冲区，会直接创建一个新的数据相同的缓冲区</p></li><li><p><code>public abstract IntBuffer slice()</code>  -   划分缓冲区，会将原本的容量大小的缓冲区划分为更小的出来进行操作</p></li><li><p><code>public final Buffer rewind()</code>  -  倒带缓冲区，其实就是把position归零，然后mark变回-1</p></li><li><p><code>public final Buffer clear()</code>  -  将缓冲区清空，所有的变量变回最初的状态</p></li></ul><p>我们先从压缩缓冲区开始看起，它会将整个缓冲区的大小和数据内容变成position位置到limit之间的数据，并移动到数组头部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">compact</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//获取当前位置</span><br>    <span class="hljs-keyword">int</span> pos = position();<br>    <span class="hljs-comment">//获取当前最大position位置</span><br>    <span class="hljs-keyword">int</span> lim = limit();  <br>    <span class="hljs-comment">//断言表达式，position必须小于最大位置</span><br>    <span class="hljs-keyword">assert</span> (pos &lt;= lim);   <br>    <span class="hljs-comment">//计算pos距离最大位置的长度</span><br>    <span class="hljs-keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="hljs-number">0</span>); <br>    <span class="hljs-comment">//直接将hb数组当前position位置的数据拷贝到头部去，然后长度改成刚刚计算出来的空间</span><br>    System.arraycopy(hb, ix(pos), hb, ix(<span class="hljs-number">0</span>), rem);  <br>    <span class="hljs-comment">//直接将position移动到rem位置</span><br>    position(rem);   <br>    <span class="hljs-comment">//pos最大位置修改为最大容量</span><br>    limit(capacity());  <br>    <span class="hljs-comment">//mark变回-1</span><br>    discardMark();   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在的状态是：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-8.png" alt></p><p>那么我们在执行<code>compact()</code>方法之后，会进行截取，此时<code>limit - position = 6</code>，那么就会截取第<code>4、5、6、7、8、9</code>这6个数据然后丢到最前面，接着position跑到第<code>6</code>个位置表示这是下一个继续的位置：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-9.png" alt></p><p>现在我们通过代码来检验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        buffer.get();   <span class="hljs-comment">//先正常读4个</span><br>    &#125;<br>    buffer.compact();   <span class="hljs-comment">//压缩缓冲区</span><br><br>    System.out.println(<span class="hljs-string">&quot;压缩之后的情况：&quot;</span>+Arrays.toString(buffer.array()));<br>    System.out.println(<span class="hljs-string">&quot;当前position位置：&quot;</span>+buffer.position());<br>    System.out.println(<span class="hljs-string">&quot;当前limit位置：&quot;</span>+buffer.limit());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">压缩之后的情况：<span class="hljs-selector-attr">[5, 6, 7, 8, 9, 0, 7, 8, 9, 0]</span><br>当前<span class="hljs-attribute">position</span>位置：<span class="hljs-number">6</span><br>当前limit位置：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>我们接着来看第二个方法，那么如果我们现在需要复制一个内容一模一样的的缓冲区，该怎么做？直接使用<code>duplicate()</code>方法就可以复制了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">duplicate</span><span class="hljs-params">()</span> </span>&#123;   <br>    <span class="hljs-comment">//直接new一个新的，但是是把hb给丢进去了，而不是拷贝一个新的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapIntBuffer(hb,<br>                                    <span class="hljs-keyword">this</span>.markValue(),<br>                                    <span class="hljs-keyword">this</span>.position(),<br>                                    <span class="hljs-keyword">this</span>.limit(),<br>                                    <span class="hljs-keyword">this</span>.capacity(),<br>                                    offset);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么各位猜想一下，如果通过这种方式创了一个新的IntBuffer，那么下面的例子会出现什么结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    IntBuffer duplicate = buffer.duplicate();<br><br>    System.out.println(buffer == duplicate);<br>    System.out.println(buffer.array() == duplicate.array());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>由于是重新new的对象，所以第一个为false；而底层的数组由于在构造的时候没有进行任何的拷贝而是直接传递，因此实际上两个缓冲区的底层数组是同一个对象，所以第二个为true，并且，一个发生修改，那么另一个就跟着变了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    IntBuffer duplicate = buffer.duplicate();<br><br>    buffer.put(<span class="hljs-number">0</span>, <span class="hljs-number">66666</span>);<br>    System.out.println(duplicate.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">66666<br></code></pre></td></tr></table></figure><p>现在我们接着来看下一个方法，<code>slice()</code>方法会将缓冲区进行划分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">slice</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//获取当前position</span><br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-keyword">this</span>.position();  <br>    <span class="hljs-comment">//获取position最大位置</span><br>    <span class="hljs-keyword">int</span> lim = <span class="hljs-keyword">this</span>.limit();     <br>    <span class="hljs-comment">//求得剩余空间</span><br>    <span class="hljs-keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="hljs-number">0</span>);   <br>    <span class="hljs-comment">//返回一个新划分出的缓冲区，但是底层的数组用的还是同一个</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapIntBuffer(hb,    <br>                                    -<span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0</span>,<br>                                    rem,    <span class="hljs-comment">//新的容量变成了剩余空间的大小</span><br>                                    rem,<br>                                    pos + offset);   <span class="hljs-comment">//可以看到offset的地址不再是0了，而是当前的position加上原有的offset值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然现在底层依然使用的是之前的数组，但是由于设定了offset值，我们之前的操作似乎变得不太一样了：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-10.png" alt></p><p>回顾前面我们所讲解的内容，在读取和存放时，会被<code>ix</code>方法进行调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">//上图的数据来看，现在offset为4，那么也就是说逻辑上的i是0但是得到真实位置却是4</span><br>    <span class="hljs-keyword">return</span> i + offset;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//最后会经过ix方法转换为真正在数组中的位置</span><br>    <span class="hljs-keyword">return</span> hb[ix(nextGetIndex())];   <br>&#125;<br></code></pre></td></tr></table></figure><p>当然，在逻辑上我们可以认为是这样的：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-11.png" alt></p><p>现在我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        buffer.get();<br>    &#125;<br>    IntBuffer slice = buffer.slice();<br><br>    System.out.println(<span class="hljs-string">&quot;划分之后的情况：&quot;</span>+Arrays.toString(slice.array()));<br>    System.out.println(<span class="hljs-string">&quot;划分之后的偏移地址：&quot;</span>+slice.arrayOffset());<br>    System.out.println(<span class="hljs-string">&quot;当前position位置：&quot;</span>+slice.position());<br>    System.out.println(<span class="hljs-string">&quot;当前limit位置：&quot;</span>+slice.limit());<br><br>    <span class="hljs-keyword">while</span> (slice.hasRemaining()) &#123;   <span class="hljs-comment">//将所有的数据全部挨着打印出来</span><br>        System.out.print(slice.get()+<span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">划分之后的情况：<span class="hljs-selector-attr">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span><br>划分之后的偏移地址：<span class="hljs-number">4</span><br>当前<span class="hljs-attribute">position</span>位置：<span class="hljs-number">0</span><br>当前limit位置：<span class="hljs-number">6</span><br><span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>,<br></code></pre></td></tr></table></figure><p>最后两个方法就比较简单了，我们先来看<code>rewind()</code>，它相当于是对position和mark进行了一次重置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title">rewind</span><span class="hljs-params">()</span> </span>&#123;<br>    position = <span class="hljs-number">0</span>;<br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是<code>clear()</code>，它相当于是将整个缓冲区回归到最初的状态了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    position = <span class="hljs-number">0</span>;    <span class="hljs-comment">//同上</span><br>    limit = capacity;   <span class="hljs-comment">//limit变回capacity</span><br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，关于缓冲区的一些其他操作，我们就讲解到此。</p><h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><p>缓冲区之间是可以进行比较的，我们可以看到<code>equals</code>方法和<code>compareTo</code>方法都是被重写了的。</p><p>我们首先来看看<code>equals</code>方法，注意，它是判断两个缓冲区剩余的内容是否一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object ob)</span> </span>&#123;<br>    <span class="hljs-comment">//要是两个缓冲区是同一个对象，肯定一样</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == ob)   <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//类型不是IntBuffer那也不用比了</span><br>    <span class="hljs-keyword">if</span> (!(ob <span class="hljs-keyword">instanceof</span> IntBuffer))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//安全地转换为IntBuffer</span><br>    IntBuffer that = (IntBuffer)ob;  <br>    <span class="hljs-comment">//获取当前缓冲区的相关信息</span><br>    <span class="hljs-keyword">int</span> thisPos = <span class="hljs-keyword">this</span>.position();  <br>    <span class="hljs-keyword">int</span> thisLim = <span class="hljs-keyword">this</span>.limit();<br>    <span class="hljs-comment">//获取另一个缓冲区的相关信息</span><br>    <span class="hljs-keyword">int</span> thatPos = that.position();  <br>    <span class="hljs-keyword">int</span> thatLim = that.limit();<br>    <span class="hljs-keyword">int</span> thisRem = thisLim - thisPos; <br>    <span class="hljs-keyword">int</span> thatRem = thatLim - thatPos;<br>    <span class="hljs-comment">//如果剩余容量小于0或者两个缓冲区的剩余容量不一样，也不行</span><br>    <span class="hljs-keyword">if</span> (thisRem &lt; <span class="hljs-number">0</span> || thisRem != thatRem)   <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//注意比较的是剩余的内容</span><br>    <span class="hljs-comment">//从最后一个开始倒着往回比较剩余的区域</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = thisLim - <span class="hljs-number">1</span>, j = thatLim - <span class="hljs-number">1</span>; i &gt;= thisPos; i--, j--) <br>        <span class="hljs-comment">//只要发现不一样的就不用继续了，直接false</span><br>        <span class="hljs-keyword">if</span> (!equals(<span class="hljs-keyword">this</span>.get(i), that.get(j)))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//上面的比较都没问题，那么就true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x == y;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们按照它的思路来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer1 = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;);<br>    IntBuffer buffer2 = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;);<br>    System.out.println(buffer1.equals(buffer2));   <span class="hljs-comment">//直接比较</span><br>    <br>    buffer1.position(<span class="hljs-number">6</span>);<br>    buffer2.position(<span class="hljs-number">6</span>);<br>    System.out.println(buffer1.equals(buffer2));   <span class="hljs-comment">//比较从下标6开始的剩余内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>那么我们接着来看比较，<code>compareTo</code>方法，它实际上是<code>Comparable</code>接口提供的方法，它实际上比较的也是pos开始剩余的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(IntBuffer that)</span> </span>&#123;<br>    <span class="hljs-comment">//获取并计算两个缓冲区的pos和remain</span><br>    <span class="hljs-keyword">int</span> thisPos = <span class="hljs-keyword">this</span>.position();    <br>    <span class="hljs-keyword">int</span> thisRem = <span class="hljs-keyword">this</span>.limit() - thisPos;<br>    <span class="hljs-keyword">int</span> thatPos = that.position();<br>    <span class="hljs-keyword">int</span> thatRem = that.limit() - thatPos;<br>    <span class="hljs-comment">//选取一个剩余空间最小的出来</span><br>    <span class="hljs-keyword">int</span> length = Math.min(thisRem, thatRem);  <br>    <span class="hljs-comment">//如果最小的小于0，那就返回-1</span><br>    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">0</span>)   <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//计算n的值，当前的pos加上最小的剩余空间</span><br>    <span class="hljs-keyword">int</span> n = thisPos + Math.min(thisRem, thatRem);  <br>    <span class="hljs-comment">//从两个缓冲区当前的pos位置开始，一直到n结束</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = thisPos, j = thatPos; i &lt; n; i++, j++) &#123;  <br>        <span class="hljs-comment">//采用compare进行比较</span><br>        <span class="hljs-keyword">int</span> cmp = compare(<span class="hljs-keyword">this</span>.get(i), that.get(j)); <br>        <span class="hljs-comment">//只要出现不相同的，那么就返回比较出来的值</span><br>        <span class="hljs-keyword">if</span> (cmp != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> cmp;   <br>    &#125;<br>    <span class="hljs-comment">//如果内容都相同，则比较长度</span><br>    <span class="hljs-keyword">return</span> thisRem - thatRem; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Integer.compare(x, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们就不多做介绍了。</p><h2 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h2><p>接着我们来看看只读缓冲区，只读缓冲区就像其名称一样，它只能进行读操作，而不允许进行写操作。</p><p>那么我们怎么创建只读缓冲区呢？</p><ul><li><code>public abstract IntBuffer asReadOnlyBuffer();</code>  -  基于当前缓冲区生成一个只读的缓冲区。</li></ul><p>我们来看看此方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">asReadOnlyBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapIntBufferR(hb,    <br>                                 <span class="hljs-keyword">this</span>.markValue(),<br>                                 <span class="hljs-keyword">this</span>.position(),<br>                                 <span class="hljs-keyword">this</span>.limit(),<br>                                 <span class="hljs-keyword">this</span>.capacity(),<br>                                 offset);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个HeapIntBufferR类跟我们普通的HeapIntBuffer有什么关系呢？</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-12.png" alt></p><p>可以看到它是继承自HeapIntBuffer的，那么我们来看看它的实现有什么不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">HeapIntBufferR</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] buf,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">int</span> mark, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> lim, <span class="hljs-keyword">int</span> cap,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">int</span> off)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">super</span>(buf, mark, pos, lim, cap, off);<br>    <span class="hljs-keyword">this</span>.isReadOnly = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在其构造方法中，除了直接调用父类的构造方法外，还会将<code>isReadOnly</code>标记修改为true，我们接着来看put操作有什么不同之处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadOnly</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadOnlyBufferException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadOnlyBufferException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadOnlyBufferException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title">put</span><span class="hljs-params">(IntBuffer src)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadOnlyBufferException();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到所有的put方法全部凉凉，只要调用就会直接抛出ReadOnlyBufferException异常。但是其他get方法依然没有进行重写，也就是说get操作还是可以正常使用的，但是只要是写操作就都不行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;);<br>    IntBuffer readBuffer = buffer.asReadOnlyBuffer();<br><br>    System.out.println(readBuffer.isReadOnly());<br>    System.out.println(readBuffer.get());<br>    readBuffer.put(<span class="hljs-number">0</span>, <span class="hljs-number">666</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">true<br><span class="hljs-number">1</span><br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ReadOnlyBufferException</span><br>at java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.HeapIntBufferR</span><span class="hljs-selector-class">.put</span>(HeapIntBufferR<span class="hljs-selector-class">.java</span>:<span class="hljs-number">181</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><span class="hljs-selector-class">.main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p>同样的，也无法通过array方法获取到底层数组，因为如果获取到了，那岂不是就能对内容进行修改了？还谈什么只读呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    IntBuffer buffer = IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;);<br>    IntBuffer readBuffer = buffer.asReadOnlyBuffer();<br><br>    readBuffer.array();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ReadOnlyBufferException</span><br>at java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.IntBuffer</span><span class="hljs-selector-class">.array</span>(IntBuffer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">996</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><span class="hljs-selector-class">.main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>这就是只读状态下的缓冲区。</p><h2 id="ByteBuffer和CharBuffer"><a href="#ByteBuffer和CharBuffer" class="headerlink" title="ByteBuffer和CharBuffer"></a>ByteBuffer和CharBuffer</h2><p>通过前面的学习，我们基本上已经了解了缓冲区的使用，但是都是基于IntBuffer进行讲解，现在我们来看看另外两种基本类型的缓冲区ByteBuffer和CharBuffer，因为ByteBuffer底层存放的是很多单个byte字节，所以会有更多的玩法，同样CharBuffer是一系列字节，所以也有很多便捷操作。</p><p><strong>我们先来看看ByteBuffer，我们可以直接点进去看：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBuffer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Buffer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">ByteBuffer</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] hb;                  <span class="hljs-comment">// Non-null only for heap buffers</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset;<br>    <span class="hljs-keyword">boolean</span> isReadOnly;                 <span class="hljs-comment">// Valid only for heap buffers</span><br>  ....<br></code></pre></td></tr></table></figure><p>可以看到如果也是使用堆缓冲区子类实现，那么依然是一个<code>byte[]</code>的形式保存数据。我们来尝试使用一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//除了直接丢byte进去之外，我们也可以丢其他的基本类型（注意容量消耗）</span><br>    <span class="hljs-comment">//丢个int的最大值进去，注意一个int占4字节</span><br>    buffer.putInt(Integer.MAX_VALUE);  <br>    System.out.println(<span class="hljs-string">&quot;当前缓冲区剩余字节数：&quot;</span>+buffer.remaining());  <span class="hljs-comment">//只剩6个字节了</span><br><br>    <span class="hljs-comment">//我们来尝试读取一下，记得先翻转</span><br>    buffer.flip();<br>    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>        System.out.println(buffer.get());   <span class="hljs-comment">//以字节的形式获取，一共四个字节</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">当前缓冲区剩余字节数：6<br>127<br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p>可以看到第一个byte为127、然后三个都是-1，我们来分析一下：</p><ul><li><code>127</code> 转换为二进制补码形式就是 <code>01111111</code>，而<code>-1</code>转换为二进制补码形式为<code>11111111</code></li></ul><p>那也就是说，第一个字节是01111111，而后续字节就是11111111，把它们拼接在一起：</p><ul><li>二进制补码表示<code>01111111 11111111 11111111 11111111</code> 转换为十进制就是<code>2147483647</code>，也就是int的最大值。</li></ul><p>那么根据我们上面的推导，各位能否计算得到下面的结果呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>    buffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    buffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    buffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">1</span>);<br>    buffer.put((<span class="hljs-keyword">byte</span>) -<span class="hljs-number">1</span>);<br><br>    buffer.flip();   <span class="hljs-comment">//翻转一下</span><br>    System.out.println(buffer.getInt());  <span class="hljs-comment">//以int形式获取，那么就是一次性获取4个字节</span><br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面的计算，得到的结果就是：</p><ul><li>上面的数据以二进制补码的形式表示为：<code>00000000 00000000 00000001 11111111</code></li><li>将其转换为十进制那么就是：256 + 255 = 511</li></ul><p><strong>我们接着来看看CharBuffer，这种缓冲区实际上也是保存一大堆char类型的数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    CharBuffer buffer = CharBuffer.allocate(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//除了可以直接丢char之外，字符串也可以一次性丢进入</span><br>    buffer.put(<span class="hljs-string">&quot;lbwnb&quot;</span>);  <br>    System.out.println(Arrays.toString(buffer.array()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[l, b, w, n, b,  ,  ,  ,  ,  ]<br></code></pre></td></tr></table></figure><p>但是正是得益于char数组，它包含了很多的字符串操作，可以一次性存放一整个字符串。我们甚至还可以将其当做一个String来进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    CharBuffer buffer = CharBuffer.allocate(<span class="hljs-number">10</span>);<br>    buffer.put(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    <span class="hljs-comment">//可以像StringBuilder一样使用append来继续添加数据</span><br>    buffer.append(<span class="hljs-string">&quot;!&quot;</span>);   <br>  <br>    <span class="hljs-comment">//已经用了6个字符了</span><br>  System.out.println(<span class="hljs-string">&quot;剩余容量：&quot;</span>+buffer.remaining());  <br><br>    buffer.flip();<br>    <span class="hljs-comment">//直接将内容转换为字符串</span><br>    System.out.println(<span class="hljs-string">&quot;整个字符串为：&quot;</span>+buffer);   <br>    <span class="hljs-comment">//直接像String一样charAt</span><br>    System.out.println(<span class="hljs-string">&quot;第3个字符是：&quot;</span>+buffer.charAt(<span class="hljs-number">2</span>));  <br><br>    <span class="hljs-comment">//也可以转换为IntStream进行操作</span><br>    buffer   <br>            .chars()<br>            .filter(i -&gt; i &lt; <span class="hljs-string">&#x27;l&#x27;</span>)<br>            .forEach(i -&gt; System.out.print((<span class="hljs-keyword">char</span>) i));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">剩余容量：<span class="hljs-number">4</span><br>整个字符串为：lbwnb!<br>第<span class="hljs-number">3</span>个字符是：w<br>bb!<br></code></pre></td></tr></table></figure><p>当然除了一些常规操作之外，我们还可以直接将一个字符串作为参数创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//可以直接使用wrap包装一个字符串，但是注意，包装出来之后是只读的</span><br>    CharBuffer buffer = CharBuffer.wrap(<span class="hljs-string">&quot;收藏等于学会~&quot;</span>);<br>    System.out.println(buffer);<br><br>    <span class="hljs-comment">//这里尝试进行一下写操作</span><br>    buffer.put(<span class="hljs-string">&quot;111&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">收藏等于学会~<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ReadOnlyBufferException</span><br>at java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.CharBuffer</span><span class="hljs-selector-class">.put</span>(CharBuffer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">920</span>)<br>at java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.CharBuffer</span><span class="hljs-selector-class">.put</span>(CharBuffer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">950</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><span class="hljs-selector-class">.main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure><p>对于这两个比较特殊的缓冲区，我们就暂时讲解到这里。</p><h2 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h2><p>最后我们来看一下直接缓冲区，我们前面一直使用的都是堆缓冲区，也就是说实际上数据是保存在一个数组中的，如果你已经完成了JVM篇的学习，一定知道实际上占用的是堆内存，而我们也可以创建一个直接缓冲区，也就是申请堆外内存进行数据保存，采用操作系统本地的IO，相比堆缓冲区会快一些。</p><p>那么怎么使用直接缓冲区呢？我们可以通过<code>allocateDirect</code>方法来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//这里我们申请一个直接缓冲区</span><br>    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="hljs-number">10</span>);<br>  <span class="hljs-comment">//使用方式基本和之前是一样的</span><br>    buffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">66</span>);<br>    buffer.flip();<br>    System.out.println(buffer.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看这个<code>allocateDirect</code>方法是如何创建一个直接缓冲区的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法直接创建了一个新的DirectByteBuffer对象，那么这个类又是怎么进行创建的呢？</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-13.png" alt></p><p>可以看到它并不是直接继承自ByteBuffer，而是继承了MappedByteBuffer，并且实现了接口DirectBuffer。</p><p>我们先来看看DirectBuffer接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DirectBuffer</span> </span>&#123;<br>    <span class="hljs-comment">//获取内存地址</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">address</span><span class="hljs-params">()</span></span>;   <br>    <span class="hljs-comment">//附加对象，这是为了保证某些情况下内存不被释放，我们后面细谈</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">attachment</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-comment">//内存清理类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cleaner <span class="hljs-title">cleaner</span><span class="hljs-params">()</span></span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>接着来看看MappedByteBuffer类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBuffer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteBuffer</span> </span>&#123;<br>  <span class="hljs-comment">//这三个方法目前暂时用不到，后面到文件部分再说</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MappedByteBuffer <span class="hljs-title">load</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoaded</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MappedByteBuffer <span class="hljs-title">force</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看allocateDirect方法中直接新建的DirectByteBuffer类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把Unsafe类取出来</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Bits.unsafe();<br><br><span class="hljs-comment">// 在内存中直接创建的内存空间地址</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> arrayBaseOffset = (<span class="hljs-keyword">long</span>)unsafe.arrayBaseOffset(<span class="hljs-keyword">byte</span>[].class);<br><br><span class="hljs-comment">// 是否具有非对齐访问能力，根据CPU架构而定，intel、AMD、AppleSilicon 都是支持的</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> unaligned = Bits.unaligned();<br><br><span class="hljs-comment">// 直接缓冲区的内存地址，为了提升速度就放到Buffer类中去了</span><br><span class="hljs-comment">//    protected long address;</span><br><br><span class="hljs-comment">// 附加对象，一会有大作用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object att;<br></code></pre></td></tr></table></figure><p>接着我们来看看构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><span class="hljs-comment">// package-private</span><br>DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;                   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-comment">//是否直接内存分页对齐，需要额外计算</span><br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();  <br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-comment">//计算出最终需要申请的大小</span><br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));   <br>  <span class="hljs-comment">//判断堆外内存是否足够，够的话就作为保留内存</span><br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//通过Unsafe申请内存空间，并得到内存地址</span><br>        base = unsafe.allocateMemory(size);<br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>      <span class="hljs-comment">//申请失败就取消一开始的保留内存</span><br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>  <span class="hljs-comment">//批量将申请到的这一段内存每个字节都设定为0</span><br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//将address变量（在Buffer中定义）设定为base的地址</span><br>        address = base;<br>    &#125;<br>  <span class="hljs-comment">//创建一个针对于此缓冲区的Cleaner，由于是堆外内存，所以现在由它来进行内存清理</span><br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap));<br>    att = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在构造方法中，是直接通过Unsafe类来申请足够的堆外内存保存数据，那么当我们不使用此缓冲区时，内存会被如何清理呢？我们来看看这个Cleaner：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承自虚引用（鬼引用），也就是说此对象会存放一个没有任何引用的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cleaner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PhantomReference</span>&lt;<span class="hljs-title">Object</span>&gt;</span>&#123; <br><br>    <span class="hljs-comment">//引用队列，PhantomReference构造方法需要</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br>  <br>  <span class="hljs-comment">//执行清理的具体流程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable thunk;<br>  <br>    <span class="hljs-comment">//Cleaner双向链表，每创建一个Cleaner对象都会添加一个结点</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> Cleaner first = <span class="hljs-keyword">null</span>;  <br><br>    <span class="hljs-keyword">private</span> Cleaner<br>        next = <span class="hljs-keyword">null</span>,<br>        prev = <span class="hljs-keyword">null</span>;<br>  <br>    <span class="hljs-comment">//添加操作会让新来的变成新的头结点</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Cleaner <span class="hljs-title">add</span><span class="hljs-params">(Cleaner cl)</span> </span>&#123;   <br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>) &#123;<br>            cl.next = first;<br>            first.prev = cl;<br>        &#125;<br>        first = cl;<br>        <span class="hljs-keyword">return</span> cl;<br>    &#125;<br><br>  <span class="hljs-comment">//可以看到创建鬼引用的对象就是传进的缓冲区对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Cleaner</span><span class="hljs-params">(Object referent, Runnable thunk)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, dummyQueue);<br>      <span class="hljs-comment">//清理流程实际上是外面的Deallocator</span><br>        <span class="hljs-keyword">this</span>.thunk = thunk;<br>    &#125;<br><br>   <span class="hljs-comment">//通过此方法创建一个新的Cleaner</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cleaner <span class="hljs-title">create</span><span class="hljs-params">(Object ob, Runnable thunk)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (thunk == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> add(<span class="hljs-keyword">new</span> Cleaner(ob, thunk));   <span class="hljs-comment">//调用add方法将Cleaner添加到队列</span><br>    &#125;<br>  <br>  <span class="hljs-comment">//清理操作</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!remove(<span class="hljs-keyword">this</span>))<br>            <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//进行清理操作时会从双向队列中移除当前Cleaner，false说明已经移除过了，直接return</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            thunk.run();   <span class="hljs-comment">//这里就是直接执行具体清理流程</span><br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable x) &#123;<br>            ...<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>那么我们先来看看具体的清理程序在做些什么，Deallocator是在直接缓冲区中声明的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deallocator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();<br><br>    <span class="hljs-comment">//内存地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> address; <br>    <span class="hljs-comment">//大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> size;    <br>    <span class="hljs-comment">//申请的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Deallocator</span><span class="hljs-params">(<span class="hljs-keyword">long</span> address, <span class="hljs-keyword">long</span> size, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> (address != <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>.address = address;<br>        <span class="hljs-keyword">this</span>.size = size;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//具体的清理操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   <br>        <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Paranoia</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里是直接调用了Unsafe进行内存释放操作</span><br>        unsafe.freeMemory(address);  <br>        <span class="hljs-comment">//内存地址改为0，NULL</span><br>        address = <span class="hljs-number">0</span>;   <br>        <span class="hljs-comment">//取消一开始的保留内存</span><br>        Bits.unreserveMemory(size, capacity);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，现在我们可以明确在清理的时候实际上也是调用Unsafe类进行内存释放操作，那么，这个清理操作具体是在什么时候进行的呢？首先我们要明确，如果是普通的堆缓冲区，由于使用的数组，那么一旦此对象没有任何引用时，就随时都会被GC给回收掉，但是现在是堆外内存，只能我们手动进行内存回收，那么当DirectByteBuffer也失去引用时，会不会触发内存回收呢？</p><p>答案是可以的，还记得我们刚刚看到Cleaner是PhantomReference的子类吗，而DirectByteBuffer是被鬼引用的对象，而具体的清理操作是Cleaner类的clean方法，莫非这两者有什么联系吗？</p><p>你别说，还真有，我们直接看到PhantomReference的父类Reference中的内部类、成员变量、静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Reference类的内部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  ...<br><span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// 预加载并初始化 InterruptedException 和 Cleaner 类</span><br>      <span class="hljs-comment">// 以避免出现在循环运行过程中时由于内存不足而无法加载</span><br>            ensureClassInitialized(InterruptedException.class);<br>            ensureClassInitialized(Cleaner.class);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">//这里是一个无限循环调用tryHandlePending方法</span><br>            tryHandlePending(<span class="hljs-keyword">true</span>);   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Reference类的成员变量</span><br><span class="hljs-comment">//会被GC回收的对象，也就是我们给过来被引用的对象</span><br><span class="hljs-keyword">private</span> T referent;         <br><br><span class="hljs-comment">//引用队列，可以和下面的next搭配使用，形成链表</span><br><span class="hljs-keyword">volatile</span> ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue;  <br><br><span class="hljs-comment">//Reference对象也是一个一个连起来的节点，这样才能放到ReferenceQueue中形成链表</span><br><span class="hljs-keyword">volatile</span> Reference next;<br><br><span class="hljs-comment">//即将被GC的引用链表，由虚拟机操作</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">private</span> Reference&lt;T&gt; discovered;<br><br><span class="hljs-comment">//pending与discovered一起构成了一个pending单向链表，标记为static类所有，</span><br><span class="hljs-comment">//pending为链表的头节点，discovered为链表当前Reference节点指向下一个节点的引用，这个队列是由JVM构建的，</span><br><span class="hljs-comment">//当对象除了被reference引用之外没有其它强引用了，JVM就会将指向需要回收的对象的Reference对象都放入到这个队列里面，</span><br><span class="hljs-comment">//这个队列会由下面的 Reference Hander 线程来处理。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Reference&lt;Object&gt; pending = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Reference类的静态代码块</span><br><span class="hljs-keyword">static</span> &#123;    <br>    ThreadGroup tg = Thread.currentThread().getThreadGroup();<br>    <span class="hljs-keyword">for</span> (ThreadGroup tgn = tg;<br>         tgn != <span class="hljs-keyword">null</span>;<br>         tg = tgn, tgn = tg.getParent());<br>    <span class="hljs-comment">//在一开始的时候就会创建</span><br>    Thread handler = <span class="hljs-keyword">new</span> ReferenceHandler(tg, <span class="hljs-string">&quot;Reference Handler&quot;</span>); <br>    <span class="hljs-comment">//以最高优先级启动</span><br>    handler.setPriority(Thread.MAX_PRIORITY);   <br>    <span class="hljs-comment">//此线程直接作为一个守护线程</span><br>    handler.setDaemon(<span class="hljs-keyword">true</span>);   <br>    <span class="hljs-comment">//也就是说在一开始的时候这个守护线程就会启动</span><br>    handler.start();    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>那么也就是说Reference Handler线程是在一开始就启动了，那么我们的关注点可以放在<code>tryHandlePending</code>方法上，看看这玩意到底在做个啥：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryHandlePending</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> waitForNotify)</span> </span>&#123;<br>    Reference&lt;Object&gt; r;<br>    Cleaner c;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//加锁办事</span><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;   <br>          <span class="hljs-comment">//当Cleaner引用的DirectByteBuffer对象即将被回收时，pending会变成此Cleaner对象</span><br>          <span class="hljs-comment">//这里判断到pending不为null时就需要处理一下对象销毁了</span><br>            <span class="hljs-keyword">if</span> (pending != <span class="hljs-keyword">null</span>) &#123;<br>                r = pending;<br>                <span class="hljs-comment">// &#x27;instanceof&#x27; 有时会导致内存溢出，所以在r从链表中移除之前就进行类型判断</span><br>                <span class="hljs-comment">// 如果是Cleaner类型就给到c</span><br>                c = r <span class="hljs-keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// 将pending更新为链表下一个待回收元素</span><br>                pending = r.discovered;<br>                <span class="hljs-comment">//r不再引用下一个节点</span><br>                r.discovered = <span class="hljs-keyword">null</span>;   <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//否则就进入等待</span><br>                <span class="hljs-keyword">if</span> (waitForNotify) &#123;<br>                    lock.wait();<br>                &#125;<br>                <span class="hljs-keyword">return</span> waitForNotify;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Thread.yield();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果元素是Cleaner类型，c在上面就会被赋值，这里就会执行其clean方法（破案了）</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>        c.clean();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    ReferenceQueue&lt;? <span class="hljs-keyword">super</span> Object&gt; q = r.queue;<br>    <span class="hljs-comment">//这个是引用队列，实际上就是我们之前在JVM篇中讲解的入队机制</span><br>    <span class="hljs-keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对源码的解读，我们就了解了直接缓冲区的内存加载释放整个流程。和堆缓冲区一样，当直接缓冲区没有任何强引用时，就有机会被GC正常回收掉并自动释放申请的内存。</p><p>我们接着来看看直接缓冲区的读写操作是如何进行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//直接通过Unsafe类读取对应地址上的byte数据</span><br>    <span class="hljs-keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">//ix现在是内存地址再加上i</span><br>    <span class="hljs-keyword">return</span> address + ((<span class="hljs-keyword">long</span>)i &lt;&lt; <span class="hljs-number">0</span>);   <br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看看写操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> x)</span> </span>&#123;<br>    unsafe.putByte(ix(nextPutIndex()), ((x)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到无论是读取还是写入操作都是通过Unsafe类操作对应的内存地址完成的。</p><p>那么它的复制操作是如何实现的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title">duplicate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(<span class="hljs-keyword">this</span>,<br>                                          <span class="hljs-keyword">this</span>.markValue(),<br>                                          <span class="hljs-keyword">this</span>.position(),<br>                                          <span class="hljs-keyword">this</span>.limit(),<br>                                          <span class="hljs-keyword">this</span>.capacity(),<br>                                          <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里给的db是进行复制操作的DirectByteBuffer对象</span><br>DirectByteBuffer(DirectBuffer db,         <br>                           <span class="hljs-keyword">int</span> mark, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> lim, <span class="hljs-keyword">int</span> cap,<br>                           <span class="hljs-keyword">int</span> off) &#123;<br>    <span class="hljs-keyword">super</span>(mark, pos, lim, cap);<br>    <span class="hljs-comment">//直接继续使用之前申请的内存空间</span><br>    address = db.address() + off;  <br>    <span class="hljs-comment">//因为用的是之前的内存空间，已经有对应的Cleaner了，这里不需要再搞一个</span><br>    cleaner = <span class="hljs-keyword">null</span>;  <br>    <span class="hljs-comment">//将att设定为此对象</span><br>    att = db;   <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，如果是进行复制操作，那么会直接继续使用执行复制操作的DirectByteBuffer申请的内存空间。不知道各位是否能够马上联想到一个问题，我们知道，如果执行复制操作的DirectByteBuffer对象失去了强引用被回收，那么就会触发Cleaner并进行内存释放，但是有个问题就是，这段内存空间可能复制出来的DirectByteBuffer对象还需要继续使用，这时肯定是不能进行回收的，所以说这里使用了att变量将之前的DirectByteBuffer对象进行引用，以防止其失去强引用被垃圾回收，所以只要不是原来的DirectByteBuffer对象和复制出来的DirectByteBuffer对象都失去强引用，就不会导致这段内存空间被回收。</p><p>这样，我们之前的未解之谜为啥有个<code>att</code>也就得到答案了，有关直接缓冲区的介绍，就到这里为止。</p><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>前面我们学习了NIO的基石——缓冲区，那么缓冲区具体用在什么地方呢，在本板块我们学习通道之后，相信各位就能知道了。那么，什么是通道呢？</p><p>在传统IO中，我们都是通过流进行传输，数据会源源不断从流中传出；而在NIO中，数据是放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地。</p><h2 id="通道接口层次"><a href="#通道接口层次" class="headerlink" title="通道接口层次"></a>通道接口层次</h2><p>通道的根基接口是<code>Channel</code>，所有的派生接口和类都是从这里开始的，我们来看看它定义了哪些基本功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Channel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Closeable</span> </span>&#123;<br>    <span class="hljs-comment">//通道是否处于开启状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//因为通道开启也需要关闭，所以实现了Closeable接口，所以这个方法懂的都懂</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看看它的一些子接口，首先是最基本的读写操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadableByteChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span> </span>&#123;<br>    <span class="hljs-comment">//将通道中的数据读取到给定的缓冲区中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer dst)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WritableByteChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span> </span>&#123;<br>  <span class="hljs-comment">//将给定缓冲区中的数据写入到通道中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer src)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了读写功能后，最后整合为了一个ByteChannel接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ByteChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReadableByteChannel</span>, <span class="hljs-title">WritableByteChannel</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-14.png" alt></p><p>在ByteChannel之下，还有更多的派生接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//允许保留position和更改position的通道，以及对通道连接实体的相关操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SeekableByteChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteChannel</span> </span>&#123;<br>   ...<br><br>    <span class="hljs-comment">//获取当前的position</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">position</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">//修改当前的position</span><br>    <span class="hljs-function">SeekableByteChannel <span class="hljs-title">position</span><span class="hljs-params">(<span class="hljs-keyword">long</span> newPosition)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">//返回此通道连接到的实体（比如文件）的当前大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">//将此通道连接到的实体截断（比如文件，截断之后，文件后面一半就没了）为给定大小</span><br>    <span class="hljs-function">SeekableByteChannel <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> size)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看，除了读写之外，Channel还可以具有响应中断的能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterruptibleChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span> </span>&#123;<br>  <span class="hljs-comment">//当其他线程调用此方法时，在此通道上处于阻塞状态的线程会直接抛出 AsynchronousCloseException 异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是InterruptibleChannel的抽象实现，完成了一部分功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractInterruptibleChannel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Channel</span>, <span class="hljs-title">InterruptibleChannel</span> </span>&#123;<br>    <span class="hljs-comment">//加锁关闭操作用到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object closeLock = <span class="hljs-keyword">new</span> Object();<br>  <span class="hljs-comment">//当前Channel的开启状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> open = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractInterruptibleChannel</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-comment">//关闭操作实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//同时只能有一个线程进行此操作，加锁</span><br>        <span class="hljs-keyword">synchronized</span> (closeLock) &#123;   <br>            <span class="hljs-comment">//如果已经关闭了，那么就不用继续了</span><br>            <span class="hljs-keyword">if</span> (!open)   <br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-comment">//设置开启状态为false</span><br>            open = <span class="hljs-keyword">false</span>;   <br>            <span class="hljs-comment">//开始关闭通道</span><br>            implCloseChannel();   <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//该方法由 close 方法调用，以执行关闭通道的具体操作，仅当通道尚未关闭时才调用此方法，不会多次调用。</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">implCloseChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> open;<br>    &#125;<br><br>    <span class="hljs-comment">//开始阻塞（有可能一直阻塞下去）操作之前，需要调用此方法进行标记，</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br><br>  <span class="hljs-comment">//阻塞操作结束之后，也需要需要调用此方法，为了防止异常情况导致此方法没有被调用，建议放在finally中</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">end</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> completed)</span></span><br><span class="hljs-function">...</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">...</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>而之后的一些实现类，都是基于这些接口定义的方法去进行实现的，比如FileChannel：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-15.png" alt></p><p>这样，我们就大致了解了一下通道相关的接口定义，那么我来看看具体是如何如何使用的。</p><p>比如现在我们要实现从输入流中读取数据然后打印出来，那么之前传统IO的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-comment">//数组创建好，一会用来存放从流中读取到的数据</span><br>  <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];<br>  <span class="hljs-comment">//直接使用输入流</span><br>    InputStream in = System.in;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-comment">//将输入流中的数据一次性读取到数组中</span><br>        <span class="hljs-keyword">while</span> ((len = in.read(data)) &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//读取了多少打印多少</span><br>            System.out.print(<span class="hljs-string">&quot;读取到一批数据：&quot;</span> + <span class="hljs-keyword">new</span> String(data, <span class="hljs-number">0</span>, len) + <span class="hljs-string">&quot;\n&quot;</span>);  <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而现在我们可以使用通道来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-comment">//创建一次能装10个字节的缓冲区</span><br>    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//将System.in作为输入源，一会Channel就可以从这里读取数据，然后通过缓冲区装载一次性传递数据</span><br>    ReadableByteChannel readChannel = Channels.newChannel(System.in);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-comment">//将通道中的数据写到缓冲区中，缓冲区最多一次装10个</span><br>        readChannel.read(buffer);<br>        <span class="hljs-comment">//写入操作结束之后，需要进行翻转，以便接下来的读取操作</span><br>        buffer.flip();<br>        <span class="hljs-comment">//最后转换成String打印出来</span><br>        System.out.println(<span class="hljs-string">&quot;读取到一批数据：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>        <span class="hljs-comment">//回到最开始的状态</span><br>        buffer.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看，好像感觉也没啥区别，不就是把数组换成缓冲区了吗，效果都是一样的，数据也是从Channel中读取得到，并且通过缓冲区进行数据装载然后得到结果，但是，<strong>流是单向的，Channel是双向的。</strong></p><h2 id="文件传输FileChannel"><a href="#文件传输FileChannel" class="headerlink" title="文件传输FileChannel"></a>文件传输FileChannel</h2><p>前面我们介绍了通道的基本情况，这里我们就来尝试实现一下文件的读取和写入，在传统IO中，文件的写入和输出都是依靠FileInputStream和FileOutputStream来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>        FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>        String data = <span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>;<br>        <span class="hljs-comment">//向文件的输出流中写入数据，也就是把数据写到文件中</span><br>        out.write(data.getBytes());   <br>        out.flush();<br><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[in.available()];<br>        <span class="hljs-comment">//从文件的输入流中读取文件的信息</span><br>        in.read(bytes);    <br>        System.out.println(<span class="hljs-keyword">new</span> String(bytes));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而现在，我们只需要通过一个FileChannel就可以完成这两者的操作，获取文件通道的方式有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//1. 直接通过输入或输出流获取对应的通道</span><br>    FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    <span class="hljs-comment">//但是这里的通道只支持读取或是写入操作</span><br>    FileChannel channel = in.getChannel();<br>    <span class="hljs-comment">//创建一个容量为128的缓冲区</span><br>    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>    <span class="hljs-comment">//从通道中将数据读取到缓冲区中</span><br>    channel.read(buffer);<br>    <span class="hljs-comment">//翻转一下，接下来要读取了</span><br>    buffer.flip();<br><br>    System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">伞兵一号卢本伟准备就绪！<br></code></pre></td></tr></table></figure><p>可以看到通过输入流获取的文件通道读取是没有任何问题的，但是写入操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//1. 直接通过输入或输出流获取对应的通道</span><br>    FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    <span class="hljs-comment">//但是这里的通道只支持读取或是写入操作</span><br>    FileChannel channel = in.getChannel();<br>    <span class="hljs-comment">//尝试写入一下</span><br>    channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.channels</span><span class="hljs-selector-class">.NonWritableChannelException</span><br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ch</span><span class="hljs-selector-class">.FileChannelImpl</span><span class="hljs-selector-class">.write</span>(FileChannelImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">201</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><span class="hljs-selector-class">.main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><p>直接报错，说明只支持读取操作.</p><p>那我们来看看输出流呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//1. 直接通过输入或输出流获取对应的通道</span><br>    FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    <span class="hljs-comment">//但是这里的通道只支持读取或是写入操作</span><br>    FileChannel channel = out.getChannel();<br>    <span class="hljs-comment">//尝试写入一下</span><br>    channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">进程已结束,退出代码0<br></code></pre></td></tr></table></figure><p>可以看到能够正常进行写入，但是通过输出流获取的文件通道读取呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//1. 直接通过输入或输出流获取对应的通道</span><br>    FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    <span class="hljs-comment">//但是这里的通道只支持读取或是写入操作</span><br>    FileChannel channel = out.getChannel();<br><br>    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>    <span class="hljs-comment">//从通道中将数据读取到缓冲区中</span><br>    channel.read(buffer);<br>    <span class="hljs-comment">//翻转一下，接下来要读取了</span><br>    buffer.flip();<br><br>    System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.channels</span><span class="hljs-selector-class">.NonReadableChannelException</span><br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ch</span><span class="hljs-selector-class">.FileChannelImpl</span><span class="hljs-selector-class">.read</span>(FileChannelImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">149</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><span class="hljs-selector-class">.main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p>可以看到输出流生成的Channel又不支持读取，所以说本质上还是保持着输入输出流的特性，但是之前不是说Channel又可以输入又可以输出吗？这里我们来看看第二种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//RandomAccessFile能够支持文件的随机访问，并且实现了数据流</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DataOutput</span>, <span class="hljs-title">DataInput</span>, <span class="hljs-title">Closeable</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>我们可以通过RandomAccessFile来创建通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      通过RandomAccessFile进行创建，注意第二个参数的mode有几种：</span><br><span class="hljs-comment">      r        以只读的方式使用</span><br><span class="hljs-comment">      rw   读操作和写操作都可以</span><br><span class="hljs-comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span><br><span class="hljs-comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">try</span>(RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来测试一下它的读写操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span><br><span class="hljs-comment">      r        以只读的方式使用</span><br><span class="hljs-comment">      rw   读操作和写操作都可以</span><br><span class="hljs-comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span><br><span class="hljs-comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//这里设定为支持读写，这样创建的通道才能具有这些功能</span><br>    <span class="hljs-keyword">try</span>(RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>); <br>        <span class="hljs-comment">//通过RandomAccessFile创建一个通道</span><br>        FileChannel channel = f.getChannel())&#123;   <br>        channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;伞兵二号马飞飞准备就绪！&quot;</span>.getBytes()));<br><br>        <span class="hljs-comment">//注意读取也是从现在的位置开始</span><br>        <span class="hljs-comment">//需要将位置变回到最前面，这样下面才能从文件的最开始进行读取</span><br>        System.out.println(<span class="hljs-string">&quot;写操作完成之后文件访问位置：&quot;</span>+channel.position()); <br>        channel.position(<span class="hljs-number">0</span>);  <br><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>        channel.read(buffer);<br>        buffer.flip();<br><br>        System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">写操作完成之后文件访问位置：36<br>伞兵二号马飞飞准备就绪！<br></code></pre></td></tr></table></figure><p>可以看到，一个FileChannel既可以完成文件读取，也可以完成文件的写入。</p><p>除了基本的读写操作，我们也可以直接对文件进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//test.txt原文件的内容为lbwnb!</span><br>    <span class="hljs-keyword">try</span>(RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>        FileChannel channel = f.getChannel())&#123;<br>        <span class="hljs-comment">//截断文件，只留前4个字节</span><br>        channel.truncate(<span class="hljs-number">4</span>);<br><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>        channel.read(buffer);<br>        buffer.flip();<br>        System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lbwn</span><br></code></pre></td></tr></table></figure><p>当然，如果我们要进行文件的拷贝，也是很方便的，只需要使用通道就可以，比如我们现在需要将一个通道的数据写入到另一个通道，就可以直接使用transferTo方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test2.txt&quot;</span>);<br>        FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br><br>        <span class="hljs-comment">//获取到test文件的通道</span><br>        FileChannel inChannel = in.getChannel();   <br>        <span class="hljs-comment">//直接将test文件通道中的数据转到test2文件的通道中</span><br>        inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), out.getChannel());   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行后可以看到，文件的内容全部被复制到另一个文件了。</p><p>当然，使用transferFrom反向操作也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test2.txt&quot;</span>);<br>        FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br><br>        <span class="hljs-comment">//获取到test文件的通道</span><br>        FileChannel inChannel = in.getChannel();   <br>        <span class="hljs-comment">//直接将从test文件通道中传来的数据转给test2文件的通道</span><br>        out.getChannel().transferFrom(inChannel, <span class="hljs-number">0</span>, inChannel.size());   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们要编辑某个文件时，通过使用MappedByteBuffer类，可以将其映射到内存中进行编辑，编辑的内容会同步更新到文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意一定要是可写的，不然无法进行修改操作</span><br><span class="hljs-keyword">try</span>(RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>    FileChannel channel = f.getChannel())&#123;<br><br>    <span class="hljs-comment">//通过map方法映射文件的某一段内容，创建MappedByteBuffer对象</span><br>    <span class="hljs-comment">//比如这里就是从第3个字节开始，映射10字节内容到内存中</span><br>  <span class="hljs-comment">//注意这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件</span><br>    MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">//我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容</span><br>  <span class="hljs-comment">//注意这里写入也是从pos位置开始的，默认是从0开始，相对于上面的文件就是从第3个字节开始写</span><br>  <span class="hljs-comment">//注意我们只映射了10个字节，也就是写的内容不能超出10字节了</span><br>    buffer.put(<span class="hljs-string">&quot;yyds&quot;</span>.getBytes());<br><br>    <span class="hljs-comment">//编辑完成后，通过force方法将数据写回文件的映射区域</span><br>    buffer.force();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，文件的某一个区域已经被我们修改了，并且这里实际上使用的就是DirectByteBuffer直接缓冲区，效率还是很高的。</p><blockquote><p>FileChannel.MapMode.READ_WRITE 对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的（无处不在的 <strong>“一致性问题”</strong> 又出现了）有坑，需要深入去了解才行。</p></blockquote><h2 id="文件锁FileLock"><a href="#文件锁FileLock" class="headerlink" title="文件锁FileLock"></a>文件锁FileLock</h2><p>我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。</p><p>那么我们来看看如何使用文件锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>  <span class="hljs-comment">//创建RandomAccessFile对象，并拿到Channel</span><br>    RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>    FileChannel channel = f.getChannel();<br>    System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 正在尝试获取文件锁...&quot;</span>);<br>  <span class="hljs-comment">//接着我们直接使用lock方法进行加锁操作（如果其他进程已经加锁，那么会一直阻塞在这里）</span><br>  <span class="hljs-comment">//加锁操作支持对文件的某一段进行加锁，比如这里就是从0开始后的6个字节加锁，false代表这是一把独占锁</span><br>  <span class="hljs-comment">//范围锁甚至可以提前加到一个还未写入的位置上</span><br>    FileLock lock = channel.lock(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">false</span>);<br>    System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 已获取到文件锁！&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">5000</span>);   <span class="hljs-comment">//假设要处理5秒钟</span><br>    System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 操作完毕，释放文件锁！&quot;</span>);<br>  <br>  <span class="hljs-comment">//操作完成之后使用release方法进行锁释放</span><br>    lock.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>有关独占锁和共享锁：</p><ul><li><p>进程对文件加独占锁后，<strong>当前进程对文件可读可写，独占此文件，其它进程是不能对该文件进行读写操作的</strong>。</p></li><li><p>进程对文件加共享锁后，<strong>进程可以对文件进行读操作，但是无法进行写操作，共享锁可以被多个进程添加</strong>，但是只要存在共享锁，就不能添加独占锁。</p></li></ul><p>我们来启动两个进程试试看：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-16.png" alt></p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-17.png" alt></p><p>可以看到确实是两个进程同一时间只能有一个进行访问，而另一个需要等待锁释放。</p><p>那么如果我们申请的是文件的不同部分呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//其中一个进程锁 0 - 5</span><br>FileLock lock = channel.lock(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">false</span>);<br><span class="hljs-comment">//另一个进程锁 6 - 11</span><br>FileLock lock = channel.lock(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-18.png" alt></p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-19.png" alt></p><p>可以看到，两个进程这时就可以同时进行加锁操作了，因为它们锁的是不同的段落。</p><p>那么要是范围交叉呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//其中一个进程锁 0 - 5</span><br>FileLock lock = channel.lock(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">false</span>);<br><span class="hljs-comment">//另一个进程锁 3 - 8</span><br>FileLock lock = channel.lock(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-20.png" alt></p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-21.png" alt></p><p>可以看到交叉的情况下也是会出现阻塞的。</p><p>接着我们来看看共享锁，共享锁允许多个进程同时加锁，但是不能进行写操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>        FileChannel channel = f.getChannel();<br>        System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 正在尝试获取文件锁...&quot;</span>);<br>        <span class="hljs-comment">//现在使用共享锁</span><br>        FileLock lock = channel.lock(<span class="hljs-number">0</span>, Long.MAX_VALUE, <span class="hljs-keyword">true</span>);<br>        System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 已获取到文件锁！&quot;</span>);<br>  <span class="hljs-comment">//进行写操作</span><br>        channel.write(ByteBuffer.wrap(<span class="hljs-keyword">new</span> Date().toString().getBytes()));<br>       <br>        System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 操作完毕，释放文件锁！&quot;</span>);<br>        <span class="hljs-comment">//操作完成之后使用release方法进行锁释放</span><br>        lock.release();<br>    &#125;<br></code></pre></td></tr></table></figure><p>当我们进行写操作时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Wed Aug <span class="hljs-number">10</span> <span class="hljs-number">14</span>:<span class="hljs-number">29</span>:<span class="hljs-number">14</span> CST <span class="hljs-number">2022</span> 正在尝试获取文件锁...<br>Wed Aug <span class="hljs-number">10</span> <span class="hljs-number">14</span>:<span class="hljs-number">29</span>:<span class="hljs-number">14</span> CST <span class="hljs-number">2022</span> 已获取到文件锁！<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.IOException</span>: 另一个程序已锁定文件的一部分，进程无法访问。<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ch</span><span class="hljs-selector-class">.FileDispatcherImpl</span><span class="hljs-selector-class">.write0</span>(Native Method)<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ch</span><span class="hljs-selector-class">.FileDispatcherImpl</span><span class="hljs-selector-class">.write</span>(FileDispatcherImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">75</span>)<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ch</span><span class="hljs-selector-class">.IOUtil</span><span class="hljs-selector-class">.writeFromNativeBuffer</span>(IOUtil<span class="hljs-selector-class">.java</span>:<span class="hljs-number">93</span>)<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ch</span><span class="hljs-selector-class">.IOUtil</span><span class="hljs-selector-class">.write</span>(IOUtil<span class="hljs-selector-class">.java</span>:<span class="hljs-number">65</span>)<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ch</span><span class="hljs-selector-class">.FileChannelImpl</span><span class="hljs-selector-class">.write</span>(FileChannelImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">211</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><span class="hljs-selector-class">.main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">19</span>)<br></code></pre></td></tr></table></figure><p>可以看到直接抛出异常，说另一个程序已锁定文件的一部分，进程无法访问。</p><p>当然，我们也可以测试一下多个进行同时加共享锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>    RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>    FileChannel channel = f.getChannel();<br>    System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 正在尝试获取文件锁...&quot;</span>);<br><br>    FileLock lock = channel.lock(<span class="hljs-number">0</span>, Long.MAX_VALUE, <span class="hljs-keyword">true</span>);<br>    System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 已获取到文件锁！&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">5000</span>);   <span class="hljs-comment">//假设要处理5秒钟</span><br>    System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 操作完毕，释放文件锁！&quot;</span>);<br>    <br>    lock.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到结果是多个进程都能加共享锁：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-22.png" alt></p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-23.png" alt></p><p>当然，除了直接使用<code>lock()</code>方法进行加锁之外，我们也可以使用<code>tryLock()</code>方法以非阻塞方式获取文件锁，但是如果获取锁失败会得到null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>    RandomAccessFile f = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>    FileChannel channel = f.getChannel();<br>    System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; 正在尝试获取文件锁...&quot;</span>);<br><br>    FileLock lock = channel.tryLock(<span class="hljs-number">0</span>, Long.MAX_VALUE, <span class="hljs-keyword">false</span>);<br>    System.out.println(lock);<br>    Thread.sleep(<span class="hljs-number">5000</span>);   <span class="hljs-comment">//假设要处理5秒钟</span><br><br>    lock.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，两个进程都去尝试获取独占锁：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-24.png" alt></p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-25.png" alt></p><p>第一个成功加锁的进程获得了对应的锁对象，而第二个进程直接得到的是<code>null</code></p><p>到这里，有关文件锁的相关内容就差不多了。</p><h1 id="多路复用网络通信"><a href="#多路复用网络通信" class="headerlink" title="多路复用网络通信"></a>多路复用网络通信</h1><p>前面我们已经介绍了NIO框架的两大核心：Buffer和Channel，我们接着来看看最后一个内容。</p><h2 id="传统阻塞I-O网络通信"><a href="#传统阻塞I-O网络通信" class="headerlink" title="传统阻塞I/O网络通信"></a>传统阻塞I/O网络通信</h2><p>说起网络通信，相信各位并不陌生，正是因为网络的存在我们才能走进现代化的社会，在JavaWeb阶段，我们学习了如何使用Socket建立TCP连接进行网络通信：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        <span class="hljs-comment">//通过BufferedReader来读取数据</span><br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        System.out.println(reader.readLine());<br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">&quot;已收到！&quot;</span>);<br>        writer.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>        OutputStream stream = socket.getOutputStream();<br>        <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(stream);  <br>        System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>        String text = scanner.nextLine();<br>        <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>        writer.write(text+<span class="hljs-string">&#x27;\n&#x27;</span>);   <br>        writer.flush();<br>        System.out.println(<span class="hljs-string">&quot;数据已发送：&quot;</span>+text);<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        System.out.println(<span class="hljs-string">&quot;收到服务器返回：&quot;</span> + reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端断开连接！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们也可以使用前面讲解的通道来进行通信：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个新的ServerSocketChannel，一会直接使用SocketChannel进行网络IO操作</span><br>    <span class="hljs-keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open())&#123;<br>        <span class="hljs-comment">//依然是将其绑定到8080端口</span><br>        serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">//同样是调用accept()方法，阻塞等待新的连接到来</span><br>        SocketChannel socket = serverChannel.accept();<br>        <span class="hljs-comment">//因为是通道，两端的信息都是可以明确的，这里获取远端地址，当然也可以获取本地地址</span><br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getRemoteAddress());<br><br>        <span class="hljs-comment">//使用缓冲区进行数据接收</span><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>        socket.read(buffer);   <span class="hljs-comment">//SocketChannel同时实现了读写通道接口，所以可以直接进行双向操作</span><br>        buffer.flip();<br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br><br>        <span class="hljs-comment">//直接向通道中写入数据就行</span><br>        socket.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br><br>        <span class="hljs-comment">//记得关</span><br>        socket.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个新的SocketChannel，一会通过通道进行通信</span><br>    <span class="hljs-keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>        String text = scanner.nextLine();<br>        <span class="hljs-comment">//直接向通道中写入数据，真舒服</span><br>        channel.write(ByteBuffer.wrap(text.getBytes()));<br><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>        channel.read(buffer);   <span class="hljs-comment">//直接从通道中读取数据</span><br>        buffer.flip();<br>        System.out.println(<span class="hljs-string">&quot;收到服务器返回：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然可以通过传统的Socket进行网络通信，但是我们发现，如果要进行IO操作，我们需要单独创建一个线程来进行处理，比如现在有很多个客户端，服务端需要同时进行处理，那么如果我们要处理这些客户端的请求，那么我们就只能单独为其创建一个线程来进行处理：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-26.png" alt></p><p>虽然这样看起来比较合理，但是随着客户端数量的增加，如果要保持持续通信，那么就不能摧毁这些线程，而是需要一直保留（但是实际上很多时候只是保持连接，一直在阻塞等待客户端的读写操作，IO操作的频率很低，这样就白白占用了一条线程，很多时候都是站着茅坑不拉屎），但是我们的线程不可能无限制的进行创建，总有一天会耗尽服务端的资源，那么现在怎么办呢，关键是现在又有很多客户端源源不断地连接并进行操作，这时，我们就可以利用NIO为我们提供的多路复用编程模型。</p><p>我们来看看NIO为我们提供的模型：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-27.png" alt></p><p>服务端不再是一个单纯通过<code>accept()</code>方法来创建连接的机制了，而是根据客户端不同的状态，Selector会不断轮询，只有客户端在对应的状态时，比如真正开始读写操作时，才会创建线程或进行处理（这样就不会一直阻塞等待某个客户端的IO操作了），而不是创建之后需要一直保持连接，即使没有任何的读写操作。这样就不会因为占着茅坑不拉屎导致线程无限制地创建下去了。</p><p>通过这种方式，甚至单线程都能做到高效的复用，最典型的例子就是Redis了，因为内存的速度非常快，多线程上下文的开销就会显得有些拖后腿，还不如直接单线程简单高效，这也是为什么Redis单线程也能这么快的原因。</p><p>因此，我们就从NIO框架的第三个核心内容：Selector，开始讲起。</p><h2 id="选择器与I-O多路复用"><a href="#选择器与I-O多路复用" class="headerlink" title="选择器与I/O多路复用"></a>选择器与I/O多路复用</h2><p>前面我们大概了解了一下选择器，我们知道，选择器是当具体有某一个状态（比如读、写、请求）已经就绪时，才会进行处理，而不是让我们的程序主动地进行等待。</p><p>既然我们现在需要实现IO多路复用，那么我们来看看常见的IO多路复用模型，也就是Selector的实现方案，比如现在有很多个用户连接到我们的服务器：</p><ul><li><p><strong>select</strong>：当这些连接出现具体的某个状态时，只是知道已经就绪了，但是不知道详具体是哪一个连接已经就绪，每次调用都进行线性遍历所有连接，时间复杂度为<code>O(n)</code>，并且存在最大连接数限制。</p></li><li><p><strong>poll</strong>：同上，但是由于底层采用链表，所以没有最大连接数限制。</p></li><li><strong>epoll</strong>：采用事件通知方式，当某个连接就绪，能够直接进行精准通知（这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的，只要就绪就会直接回调callback函数，实现精准通知，但是只有Linux支持这种方式），时间复杂度<code>O(1)</code>，Java在Linux环境下正是采用的这种模式进行实现的。</li></ul><p>好了，既然多路复用模型了解完毕了，那么我们就来看看如何让我们的网络通信实现多路复用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open();<br>         <span class="hljs-comment">//开启一个新的Selector，这玩意也是要关闭释放资源的</span><br>         Selector selector = Selector.open())&#123;   <br>        serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">//要使用选择器进行操作，必须使用非阻塞的方式，这样才不会像阻塞IO那样卡在accept()，而是直接通过，让选择器去进行下一步操作</span><br>        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">//将选择器注册到ServerSocketChannel中，后面是选择需要监听的时间，只有发生对应事件时才会进行选择，多个事件用 | 连接</span><br>        <span class="hljs-comment">//注意，并不是所有的Channel都支持以下全部四个事件，可能只支持部分</span><br>        <span class="hljs-comment">//因为是ServerSocketChannel这里我们就监听accept就可以了，等待客户端连接</span><br>        <span class="hljs-comment">//SelectionKey.OP_CONNECT --- 连接就绪事件，表示客户端与服务器的连接已经建立成功</span><br>        <span class="hljs-comment">//SelectionKey.OP_ACCEPT --- 接收连接事件，表示服务器监听到了客户连接，服务器可以接收这个连接了</span><br>        <span class="hljs-comment">//SelectionKey.OP_READ --- 读 就绪事件，表示通道中已经有了可读的数据，可以执行读操作了</span><br>        <span class="hljs-comment">//SelectionKey.OP_WRITE --- 写 就绪事件，表示已经可以向通道写数据了（这玩意比较特殊，一般情况下因为都是可以写入的，所以可能会无限循环）</span><br>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        <span class="hljs-comment">//无限循环等待新的用户网络操作</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;   <br>            <span class="hljs-comment">//每次选择都可能会选出多个已经就绪的网络操作，没有操作时会暂时阻塞</span><br>            <span class="hljs-keyword">int</span> count = selector.select();<br>            System.out.println(<span class="hljs-string">&quot;监听到 &quot;</span>+count+<span class="hljs-string">&quot; 个事件&quot;</span>);<br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                SelectionKey key = iterator.next();<br>                <span class="hljs-comment">//根据不同的事件类型，执行不同的操作即可</span><br>                <span class="hljs-comment">//如果当前ServerSocketChannel已经做好准备处理Accept</span><br>                <span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;  <br>                    SocketChannel channel = serverChannel.accept();<br>                    System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());<br>                    <span class="hljs-comment">//现在连接就建立好了，接着我们需要将连接也注册选择器，比如我们需要当这个连接有内容可读时就进行处理</span><br>                    channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                    <span class="hljs-comment">//这样就在连接建立时完成了注册</span><br>                    channel.register(selector, SelectionKey.OP_READ);<br>                    <span class="hljs-comment">//如果当前连接有可读的数据并且可以写，那么就开始处理</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isReadable()) &#123;    <br>                    SocketChannel channel = (SocketChannel) key.channel();<br>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                    channel.read(buffer);<br>                    buffer.flip();<br>                    System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>                    <span class="hljs-comment">//直接向通道中写入数据就行</span><br>                    channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>                    <span class="hljs-comment">//别关，说不定用户还要继续通信呢</span><br>                &#125;<br>                <span class="hljs-comment">//处理完成后，一定记得移出迭代器，不然下次还有</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个新的SocketChannel，一会通过通道进行通信</span><br>    <span class="hljs-keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>        <span class="hljs-comment">//咱给它套个无限循环，这样就能一直发消息了</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;   <br>            System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>            String text = scanner.nextLine();<br>            <span class="hljs-comment">//直接向通道中写入数据，真舒服</span><br>            channel.write(ByteBuffer.wrap(text.getBytes()));<br>            System.out.println(<span class="hljs-string">&quot;已发送！&quot;</span>);<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>            <span class="hljs-comment">//直接从通道中读取数据</span><br>            channel.read(buffer);   <br>            buffer.flip();<br>            System.out.println(<span class="hljs-string">&quot;收到服务器返回：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看效果：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-28.png" alt></p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-29.png" alt></p><p>可以看到成功实现了，当然各位也可以跟自己的室友一起开客户端进行测试，现在，我们只用了一个线程，就能够同时处理多个请求，可见多路复用是多么重要。</p><h2 id="实现Reactor模式"><a href="#实现Reactor模式" class="headerlink" title="实现Reactor模式"></a>实现Reactor模式</h2><p>前面我们简单实现了多路复用网络通信，我们接着来了解一下Reactor模式，对我们的服务端进行优化。</p><p>现在我们来看看如何进行优化，我们首先抽象出两个组件，Reactor线程和Handler处理器：</p><ul><li><p>Reactor线程：负责响应IO事件，并分发到Handler处理器。新的事件包含连接建立就绪、读就绪、写就绪等。</p></li><li><p>Handler处理器：执行非阻塞的操作。</p></li></ul><p>实际上我们之前编写的算是一种单线程Reactor的朴素模型（面向过程的写法），我们来看看标准的写法：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-30.png" alt></p><p>客户端还是按照我们上面的方式连接到Reactor，并通过选择器走到Acceptor或是Handler，Acceptor主要负责客户端连接的建立，Handler负责读写操作，代码如下，首先是Handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handler负责读写操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannel channel;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.channel = channel;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>            channel.read(buffer);<br>            buffer.flip();<br>            System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>            channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是Acceptor，实际上就是把上面的业务代码搬个位置罢了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acceptor主要用于处理连接操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Acceptor</span><span class="hljs-params">(ServerSocketChannel serverChannel, Selector selector)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serverChannel = serverChannel;<br>        <span class="hljs-keyword">this</span>.selector = selector;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            SocketChannel channel = serverChannel.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());<br>            channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">//这里在注册时，创建好对应的Handler，这样在Reactor中分发的时候就可以直接调用Handler了</span><br>            channel.register(selector, SelectionKey.OP_READ, <span class="hljs-keyword">new</span> Handler(channel));<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们在注册时丢了一个附加对象进去，这个附加对象会在选择器选择到此通道上时，可以通过<code>attachment()</code>方法进行获取，对于我们简化代码有大作用，一会展示，我们接着来看看Reactor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span>, <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Reactor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        serverChannel = ServerSocketChannel.open();<br>        selector = Selector.open();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">//注册时，将Acceptor作为附加对象存放，当选择器选择后也可以获取到</span><br>            serverChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="hljs-keyword">new</span> Acceptor(serverChannel, selector));<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> count = selector.select();<br>                System.out.println(<span class="hljs-string">&quot;监听到 &quot;</span>+count+<span class="hljs-string">&quot; 个事件&quot;</span>);<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-comment">//通过dispatch方法进行分发</span><br>                    <span class="hljs-keyword">this</span>.dispatch(iterator.next());   <br>                    iterator.remove();<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//通过此方法进行分发</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(SelectionKey key)</span></span>&#123;<br>        <span class="hljs-comment">//获取attachment，ServerSocketChannel和对应的客户端Channel都添加了的</span><br>        Object att = key.attachment();   <br>        <span class="hljs-keyword">if</span>(att <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>            <span class="hljs-comment">//由于Handler和Acceptor都实现自Runnable接口，这里就统一调用一下</span><br>            <span class="hljs-comment">//这样就实现了对应的时候调用对应的Handler或是Acceptor了</span><br>            ((Runnable) att).run();   <br>        &#125;   <br>    &#125;<br><br>    <span class="hljs-comment">//用了记得关，保持好习惯</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        serverChannel.close();<br>        selector.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们编写一下主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建Reactor对象，启动，完事</span><br>    <span class="hljs-keyword">try</span> (Reactor reactor = <span class="hljs-keyword">new</span> Reactor())&#123;<br>        reactor.run();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就实现了单线程Reactor模式，注意全程使用到的都只是一个线程，没有创建新的线程来处理任何事情。</p><p>但是单线程始终没办法应对大量的请求，如果请求量上去了，单线程还是很不够用，接着我们来看看多线程Reactor模式，它创建了多个线程处理，我们可以将数据读取完成之后的操作交给线程池来执行：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-31.png" alt></p><p>其实我们只需要稍微修改一下Handler就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">//把线程池给安排了，10个线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService POOL = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannel channel;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(SocketChannel channel)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.channel = channel;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            channel.read(buffer);<br>            buffer.flip();<br>            POOL.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>+<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.remaining()));<br>                    channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到！&quot;</span>.getBytes()));<br>                &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在数据读出之后，就可以将数据处理交给线程池执行。</p><p>但是这样感觉还是划分的不够，一个Reactor需要同时处理来自客户端的所有操作请求，显得有些乏力，那么不妨我们将Reactor做成一主多从的模式，让主Reactor只负责Accept操作，而其他的Reactor进行各自的其他操作：</p><p><img src="/2022/08/07/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/image-32.png" alt></p><p>现在我们来重新设计一下我们的代码，Reactor类就作为主节点，不进行任何修改，我们来修改一下其他的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SubReactor作为从Reactor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubReactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Closeable</span> </span>&#123;<br><span class="hljs-comment">//每个从Reactor也有一个Selector</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br><br>  <span class="hljs-comment">//创建一个4线程的线程池，也就是四个从Reactor工作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService POOL = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SubReactor[] reactors = <span class="hljs-keyword">new</span> SubReactor[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> selectedIndex = <span class="hljs-number">0</span>;  <span class="hljs-comment">//采用轮询机制，每接受一个新的连接，就轮询分配给四个从Reactor</span><br>    <span class="hljs-keyword">static</span> &#123;   <span class="hljs-comment">//在一开始的时候就让4个从Reactor跑起来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                reactors[i] = <span class="hljs-keyword">new</span> SubReactor();<br>                POOL.submit(reactors[i]);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//轮询获取下一个Selector（Acceptor用）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Selector <span class="hljs-title">nextSelector</span><span class="hljs-params">()</span></span>&#123;<br>        Selector selector = reactors[selectedIndex].selector;<br>        selectedIndex = (selectedIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> selector;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SubReactor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        selector = Selector.open();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">//启动后直接等待selector监听到对应的事件即可，其他的操作逻辑和Reactor一致</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> count = selector.select();<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &gt;&gt; 监听到 &quot;</span>+count+<span class="hljs-string">&quot; 个事件&quot;</span>);<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-keyword">this</span>.dispatch(iterator.next());<br>                    iterator.remove();<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(SelectionKey key)</span></span>&#123;<br>        Object att = key.attachment();<br>        <span class="hljs-keyword">if</span>(att <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>            ((Runnable) att).run();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        selector.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来修改一下Acceptor类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverChannel;   <span class="hljs-comment">//只需要一个ServerSocketChannel就行了</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Acceptor</span><span class="hljs-params">(ServerSocketChannel serverChannel)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serverChannel = serverChannel;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            SocketChannel channel = serverChannel.accept();   <span class="hljs-comment">//还是正常进行Accept操作，得到SocketChannel</span><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &gt;&gt; 客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());<br>            channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            Selector selector = SubReactor.nextSelector();   <span class="hljs-comment">//选取下一个从Reactor的Selector</span><br>            selector.wakeup();    <span class="hljs-comment">//在注册之前唤醒一下防止卡死</span><br>            channel.register(selector, SelectionKey.OP_READ, <span class="hljs-keyword">new</span> Handler(channel));  <span class="hljs-comment">//注意现在注册的是从Reactor的Selector</span><br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，SocketChannel相关的操作就由从Reactor进行处理了，而不是一律交给主Reactor进行操作。</p><p>至此，我们已经了解了NIO的三大组件：<em>Buffer、Channel、Selector</em>，有关NIO基础相关的内容，就讲解到这里。下一章我们将继续讲解基于NIO实现的高性能网络通信框架Netty。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JUC笔记（三）并发编程进</title>
    <link href="/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>在我们的程序中，多多少少都会用到多线程技术，而我们以往都是使用Thread类来创建一个新的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>));<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>利用多线程，我们的程序可以更加合理地使用CPU多核心资源，在同一时间完成更多的工作。但是，如果我们的程序频繁地创建线程，由于线程的创建和销毁也需要占用系统资源，因此这样会降低我们整个程序的性能，那么怎么做，才能更高效地使用多线程呢？</p><p>我们其实可以将已创建的线程复用，利用池化技术，就像数据库连接池一样，我们也可以创建很多个线程，然后反复地使用这些线程，而不对它们进行销毁。</p><p>虽然听起来这个想法比较新颖，但是实际上线程池早已利用到各个地方，比如我们的Tomcat服务器，要在同一时间接受和处理大量的请求，那么就必须要在短时间内创建大量的线程，结束后又进行销毁，这显然会导致很大的开销，因此这种情况下使用线程池显然是更好的解决方案。</p><p>由于线程池可以反复利用已有线程执行多线程操作，所以它一般是有容量限制的，当所有的线程都处于工作状态时，那么新的多线程请求会被阻塞，直到有一个线程空闲出来为止，实际上这里就会用到我们之前讲解的阻塞队列。</p><p>所以我们可以暂时得到下面这样一个简单的例子：</p><p><img src="/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/image-1.png" alt></p><p>当然，JUC提供的线程池肯定没有这么简单，接下来就让我们深入进行了解。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>我们可以直接创建一个新的线程池对象，它已经提前帮助我们实现好了线程的调度机制，我们先来看它的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?<br>            <span class="hljs-keyword">null</span> :<br>            AccessController.getContext();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数稍微有一点多，这里我们依次进行讲解：</p><ul><li>corePoolSize：<strong>核心线程池大小</strong>，我们每向线程池提交一个多线程任务时，都会创建一个新的<code>核心线程</code>，无论是否存在其他空闲线程，直到到达核心线程池大小为止，之后会尝试复用线程资源。当然也可以在一开始就全部初始化好，调用<code>prestartAllCoreThreads()</code>即可。</li><li>maximumPoolSize：<strong>最大线程池大小</strong>，当目前线程池中所有的线程都处于运行状态，并且等待队列已满，那么就会直接尝试继续创建新的<code>非核心线程</code>运行，但是不能超过最大线程池大小。</li><li>keepAliveTime：<strong>线程最大空闲时间</strong>，当一个<code>非核心线程</code>空闲超过一定时间，会自动销毁。</li><li>unit：<strong>线程最大空闲时间的时间单位</strong>。</li><li>workQueue：<strong>线程等待队列</strong>，当线程池中核心线程数已满时，就会将任务暂时存到等待队列中，直到有线程资源可用为止，这里可以使用我们上一章学到的阻塞队列。</li><li>threadFactory：<strong>线程创建工厂</strong>，我们可以干涉线程池中线程的创建过程，进行自定义。</li><li>handler：<strong>拒绝策略</strong>，当等待队列和线程池都没有空间了，真的不能再来新的任务时，来了个新的多线程任务，那么只能拒绝了，这时就会根据当前设定的拒绝策略进行处理。</li></ul><p>最为重要的就是线程池大小的限定了，这个也是很有学问的，合理地分配大小会使得线程池的执行效率事半功倍：</p><ul><li>首先我们可以分析一下，线程池执行任务的特性，是CPU 密集型还是 IO 密集型 <ul><li><strong>CPU密集型：</strong>主要是执行计算任务，响应时间很快，CPU一直在运行，这种任务CPU的利用率很高，那么线程数应该是根据 CPU 核心数来决定，CPU 核心数 = 最大同时执行线程数。</li><li><strong>IO密集型：</strong>主要是进行 IO 操作，因为执行 IO 操作的时间比较较长，比如从硬盘读取数据之类的，CPU就得等着IO操作，很容易出现空闲状态，导致 CPU 的利用率不高，这种情况下可以适当增加线程池的大小，让更多的线程可以一起进行IO操作，一般可以配置为CPU核心数的2倍。</li></ul></li></ul><p>这里我们手动创建一个新的线程池看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadPoolExecutor executor =<br>            <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>,   <span class="hljs-comment">//2个核心线程，最大线程数为4个</span><br>                    <span class="hljs-number">3</span>, TimeUnit.SECONDS,        <span class="hljs-comment">//最大空闲时间为3秒钟</span><br>                    <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">2</span>));     <span class="hljs-comment">//这里使用容量为2的ArrayBlockingQueue队列</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;   <span class="hljs-comment">//开始6个任务</span><br>        <span class="hljs-keyword">int</span> finalI = i;<br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 开始执行！（&quot;</span>+ finalI);<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 已结束！（&quot;</span>+finalI);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);    <span class="hljs-comment">//看看当前线程池中的线程数量</span><br>    System.out.println(<span class="hljs-string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);     <span class="hljs-comment">//等到超过空闲时间</span><br>    System.out.println(<span class="hljs-string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());<br><br>    executor.shutdownNow();    <span class="hljs-comment">//使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝</span><br>  <span class="hljs-comment">//executor.shutdown();     同样可以关闭，但是会执行完等待队列中的任务再关闭</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 开始执行！（<span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 开始执行！（<span class="hljs-number">5</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 开始执行！（<span class="hljs-number">4</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 开始执行！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 已结束！（<span class="hljs-number">4</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 已结束！（<span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 已结束！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 已结束！（<span class="hljs-number">5</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 开始执行！（<span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 开始执行！（<span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 已结束！（<span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 已结束！（<span class="hljs-number">3</span><br>线程池中线程数量：<span class="hljs-number">4</span><br>线程池中线程数量：<span class="hljs-number">2</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里我们创建了一个核心容量为2，最大容量为4，等待队列长度为2，空闲时间为3秒的线程池，现在我们向其中执行6个任务，每个任务都会进行1秒钟休眠，那么当线程池中2个核心线程都被占用时，还有4个线程就只能进入到等待队列中了，但是等待队列中只有2个容量，这时紧接着的2个任务，线程池将直接尝试创建线程，由于不大于最大容量，因此可以成功创建。最后所有线程完成之后，在等待5秒后，超过了线程池的最大空闲时间，<code>非核心线程</code>被回收了，所以线程池中只有2个线程存在。</p><p>那么要是等待队列设定为没有容量的SynchronousQueue呢，这个时候会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadPoolExecutor executor =<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>,   <span class="hljs-comment">//2个核心线程，最大线程数为4个</span><br>                        <span class="hljs-number">3</span>, TimeUnit.SECONDS,        <span class="hljs-comment">//最大空闲时间为3秒钟</span><br>                        <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;());     <span class="hljs-comment">//这里使用没有容量的SynchronousQueue队列</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 开始执行！（<span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 开始执行！（<span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 开始执行！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 开始执行！（<span class="hljs-number">2</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task com.test.Main$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1831932724</span>@7699a589 rejected from java.util.concurrent.ThreadPoolExecutor@58372a00[Running, pool size = <span class="hljs-number">4</span>, active threads = <span class="hljs-number">4</span>, queued tasks = <span class="hljs-number">0</span>, completed tasks = <span class="hljs-number">0</span>]<br>at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">2063</span>)<br>at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">830</span>)<br>at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1379</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number">23</span>)<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 已结束！（<span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 已结束！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 已结束！（<span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 已结束！（<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到，前4个任务都可以正常执行，但是到第五个任务时，直接抛出了异常，这其实就是因为等待队列的容量为0，相当于没有容量，那么这个时候，就只能拒绝任务了，拒绝的操作会根据拒绝策略决定。</p><p>线程池的拒绝策略默认有以下几个：</p><ul><li>AbortPolicy(默认)：像上面一样，直接抛异常。</li><li>CallerRunsPolicy：直接让提交任务的线程运行这个任务，比如在主线程向线程池提交了任务，那么就直接由主线程执行。</li><li>DiscardOldestPolicy：抛弃最老任务策略，也就是通过poll()方法取出任务队列队头的任务抛弃，然后执行当前提交的任务。</li><li>DiscardPolicy：什么也不用做。</li></ul><p>这里我们进行一下<code>CallerRunsPolicy</code>策略测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadPoolExecutor executor =<br>            <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>,<br>                    <span class="hljs-number">3</span>, TimeUnit.SECONDS,<br>                    <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(),<br>                    <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());   <span class="hljs-comment">//使用另一个构造方法，最后一个参数传入策略，比如这里我们使用了CallerRunsPolicy策略</span><br></code></pre></td></tr></table></figure><p>CallerRunsPolicy策略是谁提交的就让谁自己执行，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 开始执行！（<span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 开始执行！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 开始执行！（<span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 开始执行！（<span class="hljs-number">0</span><br>main 开始执行！（<span class="hljs-number">4</span><br>main 已结束！（<span class="hljs-number">4</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 已结束！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 已结束！（<span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 已结束！（<span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 已结束！（<span class="hljs-number">2</span><br>main 开始执行！（<span class="hljs-number">5</span><br>main 已结束！（<span class="hljs-number">5</span><br>线程池中线程数量：<span class="hljs-number">2</span><br>线程池中线程数量：<span class="hljs-number">2</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，当队列塞不下时，直接在主线程运行任务，运行完之后再继续向下执行。</p><p>这里把策略修改为<code>DiscardOldestPolicy</code>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadPoolExecutor executor =<br>            <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>,<br>                    <span class="hljs-number">3</span>, TimeUnit.SECONDS,<br>                    <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">1</span>),    <span class="hljs-comment">//这里设置为ArrayBlockingQueue，长度为1</span><br>                    <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs subunit">pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-3</span> 开始执行！（3<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-4</span> 开始执行！（4<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 开始执行！（0<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-2</span> 开始执行！（1<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-4</span> 已结束！（4<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-2</span> 已结束！（1<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-3</span> 已结束！（3<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 已结束！（0<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-4</span> 开始执行！（5<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-4</span> 已结束！（5<br>线程池中线程数量：4<br>线程池中线程数量：2<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>可以看到它会移除等待队列中的最近的一个任务，所以有一个任务实际上是被抛弃了的</p><p>比较有意思的是，如果在<code>DiscardOldestPolicy</code>策略下选择没有容量的SynchronousQueue作为等待队列会爆栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadPoolExecutor executor =<br>            <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>,<br>                    <span class="hljs-number">3</span>, TimeUnit.SECONDS,<br>                    <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(),<br>                    <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 开始执行！（<span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 开始执行！（<span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 开始执行！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 开始执行！（<span class="hljs-number">3</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at java.util.concurrent.SynchronousQueue.offer(SynchronousQueue.java:<span class="hljs-number">912</span>)<br>at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1371</span>)<br>...<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 已结束！（<span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 已结束！（<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 已结束！（<span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 已结束！（<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>这是为什么呢？我们来看看这个拒绝策略的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardOldestPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();   <span class="hljs-comment">//会先执行一次出队操作，但是这对于SynchronousQueue来说毫无意义</span><br>            e.execute(r);     <span class="hljs-comment">//这里会再次调用execute方法</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它会先对等待队列进行出队操作，但是由于SynchronousQueue压根没容量，所有这个操作毫无意义，然后就会递归执行<code>execute</code>方法，而进入之后，又发现没有容量不能插入，于是又重复上面的操作，这样就会无限的递归下去，最后就爆栈了。</p><p>当然，除了使用官方提供的4种策略之外，我们还可以使用自定义的策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadPoolExecutor executor =<br>            <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>,<br>                    <span class="hljs-number">3</span>, TimeUnit.SECONDS,<br>                    <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(),<br>                    (r, executor1) -&gt; &#123;   <span class="hljs-comment">//比如这里我们也来实现一个就在当前线程执行的策略</span><br>                        System.out.println(<span class="hljs-string">&quot;哎呀，线程池和等待队列都满了，你自己耗子尾汁吧&quot;</span>);<br>                        r.run();   <span class="hljs-comment">//直接运行</span><br>                    &#125;);<br></code></pre></td></tr></table></figure><p>接着我们来看线程创建工厂，我们可以自己决定如何创建新的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadPoolExecutor executor =<br>            <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>,<br>                    <span class="hljs-number">3</span>, TimeUnit.SECONDS,<br>                    <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(),<br>                    <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>                        <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;我的自定义线程-&quot;</span>+counter++);<br>                        &#125;<br>                    &#125;);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        executor.execute(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 开始执行！&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里传入的Runnable对象就是我们提交的任务，可以看到需要我们返回一个Thread对象，其实就是线程池创建线程的过程，而如何创建这个对象，以及它的一些属性，就都由我们来决定。</p><p>各位有没有想过这样一个情况，如果我们的任务在运行过程中出现异常了，那么是不是会导致线程池中的线程被销毁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,   <span class="hljs-comment">//最大容量和核心容量锁定为1</span><br>            <span class="hljs-number">0</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;());<br>    executor.execute(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;我是异常！&quot;</span>);<br>    &#125;);<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    executor.execute(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>Exception in thread <span class="hljs-string">&quot;pool-1-thread-1&quot;</span> java.lang.RuntimeException: 我是异常！<br>at com.test.Main.lambda$main$<span class="hljs-number">0</span>(Main.java:<span class="hljs-number">20</span>)<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到，出现异常之后，再次提交新的任务，执行的线程是一个新的线程了。</p><p><strong>除了我们自己创建线程池之外，官方也提供了很多的线程池定义，我们可以使用<code>Executors</code>工具类来快速创建线程池。</strong></p><p>使用<code>newFixedThreadPool</code>直接创建一个固定容量的线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);   <span class="hljs-comment">//直接创建一个固定容量的线程池</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它的内部实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里直接将最大线程和核心线程数量设定为一样的，并且等待时间为0，因为压根不需要，并且采用的是一个无界的LinkedBlockingQueue作为等待队列。</p><p>使用<code>newSingleThreadExecutor</code>来创建只有一个线程的线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ExecutorService executor = Executors.newSingleThreadExecutor();<br>    <span class="hljs-comment">//创建一个只有一个线程的线程池</span><br>&#125;<br></code></pre></td></tr></table></figure><p>原理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里并不是直接创建的一个ThreadPoolExecutor对象，而是套了一层FinalizableDelegatedExecutorService，那么这个又是什么东西呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalizableDelegatedExecutorService</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatedExecutorService</span> </span>&#123;<br>    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;<br>        <span class="hljs-keyword">super</span>(executor);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//在GC时，会执行finalize方法，此方法中会关闭掉线程池，释放资源</span><br>        <span class="hljs-keyword">super</span>.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatedExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService e;    <span class="hljs-comment">//被委派对象</span><br>    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;   <span class="hljs-comment">//实际上所有的操作都是让委派对象执行的，有点像代理</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123; e.shutdown(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> e.shutdownNow(); &#125;<br></code></pre></td></tr></table></figure><p>所以，下面两种写法的区别在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ExecutorService executor1 = Executors.newSingleThreadExecutor();<br>    ExecutorService executor2 = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>前者实际上是被代理了，我们没办法直接修改前者的相关属性，显然使用前者创建只有一个线程的线程池更加专业和安全一些（可以防止属性被修改）。</p><p>最后我们来看使用<code>newCachedThreadPool</code>创建一个会根据需要无限制创建新线程的线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ExecutorService executor = Executors.newCachedThreadPool();<br>    <span class="hljs-comment">//它是一个会根据需要无限制创建新线程的线程池</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，核心线程数为0，那么也就是说所有的线程都是<code>非核心线程</code>，也就是说线程空闲时间超过60秒钟，一律销毁。但是它的最大容量是<code>Integer.MAX_VALUE</code>，也就是说，它可以无限制地增长下去，所以这玩意一定要慎用。</p><h2 id="执行带有返回值的任务"><a href="#执行带有返回值的任务" class="headerlink" title="执行带有返回值的任务"></a>执行带有返回值的任务</h2><p>一个多线程任务不仅仅可以是void无返回值任务，比如我们现在需要执行一个任务，但是我们需要在任务执行之后得到一个结果，这个时候怎么办呢？</p><p>这里我们就可以使用到Future了，它可以返回任务的计算结果，我们可以通过它来获取任务的结果以及任务当前是否完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;<br>    ExecutorService executor = Executors.newSingleThreadExecutor();   <span class="hljs-comment">//直接用Executors创建，方便就完事了</span><br>    Future&lt;String&gt; future = executor.submit(() -&gt; <span class="hljs-string">&quot;我是字符串!&quot;</span>);     <span class="hljs-comment">//使用submit提交任务，会返回一个Future对象，注意提交的对象可以是Runable也可以是Callable，这里使用的是Callable能够自定义返回值</span><br>    System.out.println(future.get());    <span class="hljs-comment">//如果任务未完成，get会被阻塞，任务完成返回Callable执行结果返回值</span><br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然结果也可以一开始就定义好，然后等待Runnable执行完之后再返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;<br>    ExecutorService executor = Executors.newSingleThreadExecutor();<br>    Future&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;我是字符串！&quot;</span>);<br>    System.out.println(future.get());<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以通过传入FutureTask对象的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    ExecutorService executor = Executors.newSingleThreadExecutor();<br>    FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(() -&gt; <span class="hljs-string">&quot;我是字符串！&quot;</span>);<br>    executor.submit(task);<br>    System.out.println(task.get());<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以还通过Future对象获取当前任务的一些状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    ExecutorService executor = Executors.newSingleThreadExecutor();<br>    Future&lt;String&gt; future = executor.submit(() -&gt; <span class="hljs-string">&quot;都看到这里了，不赏UP主一个一键三连吗？&quot;</span>);<br>    System.out.println(future.get());<br>    System.out.println(<span class="hljs-string">&quot;任务是否执行完成：&quot;</span>+future.isDone());<br>    System.out.println(<span class="hljs-string">&quot;任务是否被取消：&quot;</span>+future.isCancelled());<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来试试看在任务执行途中取消任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    ExecutorService executor = Executors.newSingleThreadExecutor();<br>    Future&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这次一定！&quot;</span>;<br>    &#125;);<br>    System.out.println(future.cancel(<span class="hljs-keyword">true</span>));<br>    System.out.println(future.isCancelled());<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="执行定时任务"><a href="#执行定时任务" class="headerlink" title="执行定时任务"></a>执行定时任务</h2><p>既然线程池怎么强大，那么线程池能不能执行定时任务呢？我们之前如果需要执行一个定时任务，那么肯定会用到Timer和TimerTask，但是它只会创建一个线程处理我们的定时任务，无法实现多线程调度，并且它无法处理异常情况一旦抛出未捕获异常那么会直接终止，显然我们需要一个更加强大的定时器。</p><p>JDK5之后，我们可以使用<code>ScheduledThreadPoolExecutor</code>来提交定时任务，它继承自ThreadPoolExecutor，并且所有的构造方法都必须要求最大线程池容量为Integer.MAX_VALUE，并且都是采用的DelayedWorkQueue作为等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue(), threadFactory);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue(), handler);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>Executors也为我们预置了newScheduledThreadPool方法用于创建线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>    executor.schedule(() -&gt; System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>), <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下它的方法，这个方法可以提交一个延时任务，只有到达指定时间之后才会开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>  <span class="hljs-comment">//直接设定核心线程数为1</span><br>    ScheduledThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//这里我们计划在3秒后执行</span><br>    executor.schedule(() -&gt; System.out.println(<span class="hljs-string">&quot;HelloWorld!&quot;</span>), <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以像之前一样，传入一个Callable对象，用于接收返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    ScheduledThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(<span class="hljs-number">2</span>);<br>  <span class="hljs-comment">//这里使用ScheduledFuture</span><br>    ScheduledFuture&lt;String&gt; future = executor.schedule(() -&gt; <span class="hljs-string">&quot;????&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    System.out.println(<span class="hljs-string">&quot;任务剩余等待时间：&quot;</span>+future.getDelay(TimeUnit.MILLISECONDS) / <span class="hljs-number">1000.0</span> + <span class="hljs-string">&quot;s&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;任务执行结果：&quot;</span>+future.get());<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>schedule</code>方法返回了一个ScheduledFuture对象，和Future一样，它也支持返回值的获取、包括对任务的取消同时还支持获取剩余等待时间。</p><p>那么如果我们希望按照一定的频率不断执行任务呢？</p><ul><li><code>scheduleAtFixedRate</code>：是以period为间隔来执行任务的，如果任务执行时间小于period，则上次任务执行完成后会间隔period后再去执行下一次任务；但如果任务执行时间大于period，则上次任务执行完毕后会不间隔的立即开始下次任务</li><li><code>scheduleWithFixedDelay</code> ：是不管任务执行多久，都会等上一次任务执行完毕后再延迟delay后去执行下次任务</li></ul><p><strong>scheduleAtFixedRate，任务执行时间小于period时，则上次任务执行完成后会间隔period后再去执行下一次任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>    executorService.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>        <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>String time = simpleDateFormat.format(<span class="hljs-keyword">new</span> Date());<br>System.out.println(time + <span class="hljs-string">&quot; &gt;&gt;第&quot;</span>+ (++count) + <span class="hljs-string">&quot;次执行定时任务.&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">43</span> &gt;&gt;第<span class="hljs-number">1</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">45</span> &gt;&gt;第<span class="hljs-number">2</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span> &gt;&gt;第<span class="hljs-number">3</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">49</span> &gt;&gt;第<span class="hljs-number">4</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">51</span> &gt;&gt;第<span class="hljs-number">5</span>次执行定时任务.<br></code></pre></td></tr></table></figure><p><strong>scheduleAtFixedRate，任务执行时间大于period时，则上次任务执行完毕后会不间隔的立即开始下次任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>    executorService.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>        <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>String time = simpleDateFormat.format(<span class="hljs-keyword">new</span> Date());<br>System.out.println(time + <span class="hljs-string">&quot; &gt;&gt;第&quot;</span>+ (++count) + <span class="hljs-string">&quot;次执行定时任务.&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">10</span> &gt;&gt;第<span class="hljs-number">1</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">13</span> &gt;&gt;第<span class="hljs-number">2</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">16</span> &gt;&gt;第<span class="hljs-number">3</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">19</span> &gt;&gt;第<span class="hljs-number">4</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">22</span> &gt;&gt;第<span class="hljs-number">5</span>次执行定时任务.<br></code></pre></td></tr></table></figure><p><strong>scheduleWithFixedDelay，不管任务执行多久，都会等上一次任务执行完毕后再延迟delay后去执行下次任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>    executorService.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            String time = simpleDateFormat.format(<span class="hljs-keyword">new</span> Date());<br>            System.out.println(time + <span class="hljs-string">&quot; &gt;&gt;第&quot;</span> + (++count) + <span class="hljs-string">&quot;次执行定时任务.&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">14</span>:<span class="hljs-number">40</span>:<span class="hljs-number">12</span> &gt;&gt;第<span class="hljs-number">1</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">40</span>:<span class="hljs-number">17</span> &gt;&gt;第<span class="hljs-number">2</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span> &gt;&gt;第<span class="hljs-number">3</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">40</span>:<span class="hljs-number">28</span> &gt;&gt;第<span class="hljs-number">4</span>次执行定时任务.<br><span class="hljs-attribute">14</span>:<span class="hljs-number">40</span>:<span class="hljs-number">33</span> &gt;&gt;第<span class="hljs-number">5</span>次执行定时任务.<br></code></pre></td></tr></table></figure><h2 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h2><p>前面我们了解了线程池的使用，那么接着我们来看看它的详细实现过程，结构稍微有点复杂，坐稳，发车了。</p><h3 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a><strong>关键属性</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span> </span>&#123;<br><br>    <span class="hljs-comment">// 控制变量-存放状态和线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 任务队列，必须是阻塞队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br>    <span class="hljs-comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 全局锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">// awaitTermination方法使用的等待条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition termination = mainLock.newCondition();<br><br>    <span class="hljs-comment">// 记录峰值线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> largestPoolSize;<br>    <br>    <span class="hljs-comment">// 记录已经成功执行完毕的任务数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> completedTaskCount;<br>    <br>    <span class="hljs-comment">// 线程工厂，用于创建新的线程实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<br><br>    <span class="hljs-comment">// 拒绝执行处理器，对应不同的拒绝策略</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br>    <br>    <span class="hljs-comment">// 空闲线程等待任务的时间周期，单位是纳秒</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> keepAliveTime;<br>    <br>    <span class="hljs-comment">// 是否允许核心线程超时，如果为true则keepAliveTime对核心线程也生效</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> allowCoreThreadTimeOut;<br>    <br>    <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> corePoolSize;<br><br>    <span class="hljs-comment">// 线程池容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> maximumPoolSize;<br><br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="状态控制"><a href="#状态控制" class="headerlink" title="状态控制"></a><strong>状态控制</strong></h3><p>主要围绕原子整型成员变量 <code>ctl</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个变量比较关键，用到了原子AtomicInteger，用于同时保存线程池运行状态和线程数量（使用原子类是为了保证原子性）</span><br><span class="hljs-comment">//它是通过拆分32个bit位来保存数据的，前3位保存状态，后29位保存工作线程数量（那要是工作线程数量29位装不下不就GG？）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;    <span class="hljs-comment">//29位，线程数量位</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;   <span class="hljs-comment">//计算得出最大容量（1左移29位，最大容量为2的29次方-1）</span><br><span class="hljs-comment">//即CAPACITY为000-11111111111111111111111111111</span><br><br><span class="hljs-comment">// 所有的运行状态，注意都是只占用前3位，不会占用后29位</span><br><span class="hljs-comment">// 运行中状态，可以接受新的任务和执行任务队列中的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//111 | 0000... (后29数量位，下同)</span><br><br><span class="hljs-comment">// shutdown状态，不再接收新的任务，但是会执行任务队列中的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//000 | 数量位 </span><br><br><span class="hljs-comment">// 停止状态，不再接收新的任务，也不会执行任务队列中的任务，中断所有执行中的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//001 | 数量位</span><br><br><span class="hljs-comment">// 整理中状态，所有任务已经终结，工作线程数为0，过渡到此状态的工作线程会调用钩子方法terminated()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//010 | 数量位</span><br><br><span class="hljs-comment">// 终结状态，钩子方法terminated()执行完毕</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//011 | 数量位</span><br><br><span class="hljs-comment">//通过ctl值获取运行状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <br><span class="hljs-comment">//通过ctl值获取工作线程数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><span class="hljs-comment">//通过运行状态和工作线程数量计算ctl的值，或运算 </span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;   <br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateLessThan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &lt; s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateAtLeast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &gt;= s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &lt; SHUTDOWN;<br>&#125;<br><br><span class="hljs-comment">// CAS操作线程数增加1</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// CAS操作线程数减少1</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndDecrementWorkerCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 线程数直接减少1</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrementWorkerCount</span><span class="hljs-params">()</span> </span>&#123;<br>    ctl.addAndGet(-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/image-2.png" alt></p><div class="table-container"><table><thead><tr><th style="text-align:center">状态名称</th><th style="text-align:center">位图</th><th style="text-align:center">十进制值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">RUNNING</td><td style="text-align:center">111-00000000000000000000000000000</td><td style="text-align:center">-536870912</td><td style="text-align:center">运行中状态，可以接收新的任务和执行任务队列中的任务</td></tr><tr><td style="text-align:center">SHUTDOWN</td><td style="text-align:center">000-00000000000000000000000000000</td><td style="text-align:center">0</td><td style="text-align:center">shutdown状态，不再接收新的任务，但是会执行任务队列中的任务</td></tr><tr><td style="text-align:center">STOP</td><td style="text-align:center">001-00000000000000000000000000000</td><td style="text-align:center">536870912</td><td style="text-align:center">停止状态，不再接收新的任务，也不会执行任务队列中的任务，中断所有执行中的任务</td></tr><tr><td style="text-align:center">TIDYING</td><td style="text-align:center">010-00000000000000000000000000000</td><td style="text-align:center">1073741824</td><td style="text-align:center">整理中状态，所有任务已经终结，工作线程数为0，过渡到此状态的工作线程会调用钩子方法terminated()</td></tr><tr><td style="text-align:center">TERMINATED</td><td style="text-align:center">011-00000000000000000000000000000</td><td style="text-align:center">1610612736</td><td style="text-align:center">终结状态，钩子方法terminated()执行完毕</td></tr></tbody></table></div><p>这里有一个比较特殊的技巧，由于运行状态值存放在高3位，所以可以直接通过十进制值（甚至可以忽略低29位，直接用ctl进行比较，或者使用ctl和线程池状态常量进行比较）来比较和判断线程池的状态：</p><blockquote><p>RUNNING(-536870912) &lt; SHUTDOWN(0) &lt; STOP(536870912) &lt; TIDYING(1073741824) &lt; TERMINATED(1610612736)</p></blockquote><p>下面这三个方法就是使用这种技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ctl和状态常量比较，判断是否小于</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateLessThan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &lt; s;<br>&#125;<br><br><span class="hljs-comment">// ctl和状态常量比较，判断是否小于或等于</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateAtLeast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &gt;= s;<br>&#125;<br><br><span class="hljs-comment">// ctl和状态常量SHUTDOWN比较，判断是否处于RUNNING状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &lt; SHUTDOWN;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是线程池状态的跃迁图：</p><p><img src="/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/image-3.png" alt></p><blockquote><p>PS：线程池源码中有很多中间变量用了简单的单字母表示，例如c就是表示ctl、wc就是表示worker count、rs就是表示running status。</p></blockquote><h3 id="execute方法源码分析"><a href="#execute方法源码分析" class="headerlink" title="execute方法源码分析"></a>execute方法源码分析</h3><p><code>execute</code>方法是线程池异步执行任务的方法实现。我们来看看在调用<code>execute</code>方法之后，线程池会做些什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//再次提醒，这里没加锁！！该有什么意识不用我说了吧，所以说ctl才会使用原子类。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-comment">//如果任务为null，那执行个寂寞，所以说直接空指针</span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(); <br>    <span class="hljs-comment">//获取ctl的值</span><br>    <span class="hljs-keyword">int</span> c = ctl.get();    <br>    <span class="hljs-comment">//判断如果当前工作线程数小于核心线程数，则创建新的核心线程并且执行传入的任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-comment">//如果创建新的核心线程成功则直接返回</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//如果创建新的核心线程失败（有可能其他线程也在对线程池进行操作），需要更新ctl的临时变量c的值</span><br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">//走到这里说明创建核心线程失败，也就是当前工作线程数大于等于核心线程数</span><br>    <span class="hljs-comment">//继续判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列中添加一个和新的任务（添加失败则返回false）</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-comment">//再次获取ctl的值</span><br>        <span class="hljs-keyword">int</span> recheck = ctl.get();  <br>        <span class="hljs-comment">//这里是向任务队列投放任务成功，对线程池的运行中状态做二次检查</span><br>        <span class="hljs-comment">//如果线程池二次检查状态为非运行中状态，则从任务队列中移除当前的任务（也就是移除前面成功入队的任务实例）</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            <span class="hljs-comment">//调用拒绝策略处理（会根据我们的拒绝策略决定如何进行拒绝操作）</span><br>            reject(command);   <br>        <span class="hljs-comment">//如果走到下面的else if分支，则有以下的前提：</span><br>        <span class="hljs-comment">//①、待执行的任务已经成功加入任务队列</span><br>        <span class="hljs-comment">//②、线程池可能是RUNNING状态</span><br>        <span class="hljs-comment">//③、传入的任务可能从任务队列中移除失败（唯一的可能性就是任务已经被执行了）</span><br>        <span class="hljs-comment">//如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null</span><br>        <span class="hljs-comment">//也就是创建的非核心线程不会马上运行，而是等待获取任务队列中的任务去执行</span><br>        <span class="hljs-comment">//如果当前工作线程数量不为0，则什么也不做，因为任务已经成功入队了，</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//如果走到这里，则有以下的前提：</span><br>    <span class="hljs-comment">//①、线程池中的线程总数已经大于等于核心线程数（即核心线程已经全部懒创建完毕）</span><br>    <span class="hljs-comment">//②、线程池可能不是RUNNING状态</span><br>    <span class="hljs-comment">//③、线程池可能是RUNNING状态同时任务队列已经满了</span><br>    <span class="hljs-comment">//如果向任务队列投放任务失败，则会尝试创建非核心线程传入任务执行</span><br>    <span class="hljs-comment">//创建非核心线程失败，此时需要拒绝执行任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        <span class="hljs-comment">//确实装不下了，调用拒绝策略处理任务</span><br>        reject(command);   <br>&#125;<br></code></pre></td></tr></table></figure><p>这里简单分析一下整个流程：</p><ol><li><p>如果当前工作线程总数小于<code>corePoolSize</code>，则直接创建核心线程执行任务（任务实例会传入直接用于构造工作线程实例）。</p></li><li><p>如果当前工作线程总数大于等于<code>corePoolSize</code>，判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务，这里会二次检查线程池运行状态，如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null。</p></li><li>如果向任务队列投放任务失败（任务队列已经满了），则会尝试创建非核心线程传入任务实例执行。</li><li>如果创建非核心线程失败，此时需要拒绝执行任务，调用拒绝策略处理任务。</li></ol><p><strong>这里有一个疑惑点</strong>：为什么需要二次检查线程池的运行状态？当前工作线程数为0，尝试创建一个非核心线程并且传入的任务对象为null？这个可以看API注释：</p><blockquote><p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结）或者执行当前方法的时候线程是否已经shutdown了。所以我们需要二次检查线程池的状态，必要时要把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程</p></blockquote><p>任务提交流程从调用者的角度来看如下：</p><p><img src="/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/image-4.png" alt></p><h3 id="addWorker方法源码分析"><a href="#addWorker方法源码分析" class="headerlink" title="addWorker方法源码分析"></a>addWorker方法源码分析</h3><p><strong>boolean addWorker(Runnable firstTask, boolean core)</strong>方法的第一个参数可以用于直接传入任务实例，第二个参数用于标识将要创建的工作线程是否核心线程。方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加工作线程，如果返回false则说明没有新建工作线程，如果返回true则说明新建和启动工作线程成功</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>  <span class="hljs-comment">//这里给最外层循环打了个标签，方便一会的跳转操作</span><br>    retry:<br>    <span class="hljs-comment">//注意这是个死循环 - 最外层循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//获取ctl值</span><br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//解析当前的运行状态</span><br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);    <br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;   <span class="hljs-comment">//线程池状态至少要为SHUTDOWN状态</span><br>            ! (rs == SHUTDOWN &amp;&amp;   <span class="hljs-comment">//如果判断线程不是SHUTDOWN状态、任务不为null、等待队列不为空，只要有其中一者不满足，直接返回false，添加失败</span><br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;   <br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//注意这也是一个死循环 - 二层循环</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">//这里每一轮循环都会重新获取工作线程数wc</span><br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-comment">//判断是否超过工作线程上限数</span><br>            <span class="hljs-comment">//如果是核心线程，则不能大于核心线程数</span><br>            <span class="hljs-comment">//如果是非核心线程，则不能大于线程池容量</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-comment">//返回false则说明创建线程失败</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//成功通过CAS更新工作线程数wc，则break到最外层循环</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))    <br>                <span class="hljs-keyword">break</span> retry; <br>            <span class="hljs-comment">//走到这里说明通过CAS更新工作线程数wc失败了，这个时候需要重新获取ctl的值</span><br>            c = ctl.get();  <br>            <span class="hljs-comment">//如果当前线程池状态和之前的状态不一样，则重新跳出到最外层循环继续执行</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 如果是其他原因导致的CAS失败（其他线程并发更新导致的），则在内层循环继续执行</span><br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">//线程计数自增也完了，接着就是添加新的工作线程了</span><br>    <span class="hljs-comment">//标记工作线程是否启动成功</span><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//标记工作线程是否创建成功</span><br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    <br>    <span class="hljs-comment">//暂时理解为工作线程，别急，我们之后会解读Worker类</span><br>    Worker w = <span class="hljs-keyword">null</span>;     <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//传入任务实例firstTask创建Worker实例，Worker构造里面会通过线程工厂创建新的Thread对象，所以下面可以直接操作Thread t = w.thread</span><br>        <span class="hljs-comment">//这一步Worker实例已经创建，但是没有加入工作线程集合或者没有启动它持有的线程Thread实例</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask); <br>        <span class="hljs-keyword">final</span> Thread t = w.thread; <br>        <span class="hljs-comment">//如果线程不为null，那就可以安排干活了</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;   <br>            <span class="hljs-comment">//这里需要全局加锁，因为会改变一些指标值和非线程安全的集合</span><br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-comment">//获取当前线程的运行状态</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());  <br>                <span class="hljs-comment">//如果线程池状态为RUNNING或者状态为SHUTDOWN并且firstTask为空，那么继续</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-comment">// 检查线程是否正在运行，如果是那肯定是不能运行我们的任务的</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException(); <br>                    <span class="hljs-comment">//把创建的工作线程实例添加到工作线程集合中</span><br>                    workers.add(w);    <br>                    <span class="hljs-comment">//看看当前workers的大小</span><br>                    <span class="hljs-keyword">int</span> s = workers.size(); <br>                    <span class="hljs-comment">//尝试更新历史峰值工作线程数，也就是线程池峰值容量</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)   <br>                        largestPoolSize = s;<br>                    <span class="hljs-comment">//这里更新工作线程是否添加成功标识为true，后面才会调用start()方法启动真实的线程实例</span><br>                    workerAdded = <span class="hljs-keyword">true</span>;   <br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">//如果成功添加工作线程，则调用Worker内部的线程实例t的start()方法启动真实的线程实例</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                <span class="hljs-comment">//标记线程启动成功</span><br>                workerStarted = <span class="hljs-keyword">true</span>;  <br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果线程在上面的启动过程中失败了，则需要从工作线程集合中移除对应的Worker</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)    <br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-comment">//返回是否成功</span><br>    <span class="hljs-keyword">return</span> workerStarted;   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加Worker失败</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果Worker不为空，则移除之前的Worker</span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-keyword">null</span>)<br>            workers.remove(w);<br>        <span class="hljs-comment">// wc数量减1    </span><br>        decrementWorkerCount();<br>        <span class="hljs-comment">// 如果线程池是终止状态，则会尝试加速终止线程池</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工作线程内部类Worker源码分析"><a href="#工作线程内部类Worker源码分析" class="headerlink" title="工作线程内部类Worker源码分析"></a>工作线程内部类Worker源码分析</h3><p>线程池中的每一个具体的工作线程被包装为内部类Worker实例，Worker继承于AbstractQueuedSynchronizer(AQS)，实现了Runnable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">//保存ThreadFactory创建的线程实例，如果ThreadFactory创建线程失败则为null</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">//保存传入的Runnable任务实例</span><br>    Runnable firstTask;<br>    <span class="hljs-comment">//记录每个线程完成的任务总数</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;<br><br>    <span class="hljs-comment">//唯一的构造函数，传入任务实例firstTask，注意可以为null</span><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">//禁止线程中断，直到runWorker()方法执行，将AQS的state设定为-1</span><br>        setState(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>        <span class="hljs-comment">//通过ThreadFactory创建线程实例，注意一下Worker实例自身作为Runnable用于创建新的线程实例</span><br>        <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">//委托到外部的runWorker()方法，注意runWorker()方法是线程池的方法，而不是Worker的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>   <span class="hljs-comment">//是否持有独占锁，0就是没加锁，1就是已加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//独占模式下尝试获取资源，这里没有判断传入的变量，直接CAS判断0更新为1是否成功，成功则设置独占线程为当前线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//独占模式下尝试释放资源，这里没有判断传入的变量，直接把state设置为0</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span>        </span>&#123; acquire(<span class="hljs-number">1</span>); &#125;<br><br>    <span class="hljs-comment">//尝试加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br><br>    <span class="hljs-comment">//解锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span>      </span>&#123; release(<span class="hljs-number">1</span>); &#125;<br><br>    <span class="hljs-comment">//是否锁定</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>    <br>    <span class="hljs-comment">//启动后进行线程中断，注意这里会判断线程实例的中断标志位是否为false，只有中断标志位为false才会中断</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptIfStarted</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread t;<br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    <span class="hljs-comment">//获取当前线程，实际上和Worker持有的线程实例是相同的</span><br>    Thread wt = Thread.currentThread();<br>    <span class="hljs-comment">//获取Worker中持有的初始化时传入的任务对象，这里注意存放在临时变量task中</span><br>    Runnable task = w.firstTask;<br>    <span class="hljs-comment">//设置Worker中持有的初始化时传入的任务对象为null</span><br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//由于Worker初始化时AQS中state设置为-1，这里要先做一次解锁把state更新为0，允许线程中断</span><br>    w.unlock(); <br>    <span class="hljs-comment">//记录线程是否因为用户异常而终止，默认为true</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//初始化任务不为null，或者从任务队列获取任务不为空（从任务队列获取到的任务会更新到临时变量task中）</span><br>        <span class="hljs-comment">//getTask()由于使用了阻塞队列，这个while循环如果命中后半段会处于阻塞或者超时阻塞状态，getTask()返回null会导致线程跳出死循环使线程终结</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//Worker加锁，本质是AQS获取资源并且尝试CAS更新state由0变为</span><br>            w.lock();<br>            <span class="hljs-comment">//由于线程池在STOP状态及以上会禁止新线程加入并且中断正在进行的线程</span><br>            <span class="hljs-comment">//只要线程池是STOP及以上的状态，那肯定是不能开始新任务的</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())   <span class="hljs-comment">//再次确保线程被没有打上中断标记</span><br>                wt.interrupt();     <span class="hljs-comment">//打中断标记</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//钩子方法，任务执行前</span><br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//OK，开始执行任务</span><br>                    task.run();    <br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//钩子方法，任务执行后</span><br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//清空task临时变量，这个很重要，否则while会死循环执行同一个task</span><br>                task = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">//累加Worker完成的任务数</span><br>                w.completedTasks++;<br>                <span class="hljs-comment">//Worker解锁，本质是AQS释放资源，设置state为0</span><br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//走到这里说明某一个getTask()返回为null，线程正常退出</span><br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//处理线程退出，completedAbruptly为true则说明由于用户异常导致线程非正常退出</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getTask方法源码分析"><a href="#getTask方法源码分析" class="headerlink" title="getTask方法源码分析"></a>getTask方法源码分析</h3><p>getTask()方法是工作线程在while死循环中获取任务队列中的任务对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//记录上一次从队列中拉取的时候是否超时</span><br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-comment">//注意这是死循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">//获取ctl </span><br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>         <span class="hljs-comment">//解析线程池运行状态</span><br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);     <br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果线程池状态至少为SHUTDOWN，则需要判断两种情况</span><br>        <span class="hljs-comment">//①、线程池状态至少为STOP，也就是线程池正在停止，一般是调用了shutdownNow()方法</span><br>        <span class="hljs-comment">//②、任务队列为空</span><br>        <span class="hljs-comment">//如果在线程池至少为SHUTDOWN状态并且满足上面两个条件之一，则工作线程数wc减去1，然后直接返回null</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount(); <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//跑到这里说明线程池还处于RUNNING状态，重新获取一次工作线程数</span><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-comment">//timed临时变量用于线程超时控制，决定是否需要通过poll带超时的非阻塞方法进行任务队列的任务拉取</span><br>        <span class="hljs-comment">//①、allowCoreThreadTimeOut默认值为false，如果设置为true，则允许核心线程也能通过poll方法从任务队列中拉取任务</span><br>        <span class="hljs-comment">//②、工作线程数大于核心线程数时，说明线程池中创建了额外的非核心线程，这些非核心线程一定是通过poll方法从任务队列中拉取任务</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-comment">//①、wc &gt; maximumPoolSize 说明当前的工作线程总数大于maximumPoolSize，说明通过setMaximumPoolSize()方法减少了线程池容量</span><br>        <span class="hljs-comment">//②、或者，timed &amp;&amp; timedOut 说明线程命中了超时控制并且上一轮循环通过poll方法从任务队列中拉取任务为null</span><br>        <span class="hljs-comment">//③、并且，工作线程总数大于1或者任务队列为空，则通过CAS把线程数减少1，同时返回null</span><br>        <span class="hljs-comment">//CAS把线程数减少1失败，则会进入下一轮循环重试</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果timed为true，通过poll方法做超时拉取，keepAliveTime时间内没有等待到有效的任务，则返回null</span><br>            <span class="hljs-comment">//如果timed为false，通过take方法做阻塞拉取，会阻塞到下一个有效的任务时再返回（一般不会为null）</span><br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <br>                workQueue.take();<br>            <span class="hljs-comment">//这里很重要，只有非null时才会返回，null的情况下会进入下一轮循环</span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            <span class="hljs-comment">//跑到这里说明上一次从任务队列中获取到的任务为null，一般workQueue.poll()方法超时返回null</span><br>            timedOut = <span class="hljs-keyword">true</span>; <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shutdown方法源码分析"><a href="#shutdown方法源码分析" class="headerlink" title="shutdown方法源码分析"></a>shutdown方法源码分析</h3><p>我们来看当线程池关闭时会做什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通的shutdown会继续将等待队列中的线程执行完成后再关闭线程池</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//判断是否有权限终止</span><br>        checkShutdownAccess();<br>      <span class="hljs-comment">//CAS将线程池运行状态改为SHUTDOWN状态</span><br>        advanceRunState(SHUTDOWN);<br>       <span class="hljs-comment">//让闲着的线程中断（比如正在等待新的任务），但是并不会影响正在运行的线程</span><br>        interruptIdleWorkers();<br>        <span class="hljs-comment">//给ScheduledThreadPoolExecutor提供的钩子方法，就是等ScheduledThreadPoolExecutor去实现的，当前类没有实现</span><br>        onShutdown(); <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">//最后尝试终止线程池，使状态更变为TIDYING，执行钩子方法terminated()后，最终状态更新为TERMINATED</span><br>    tryTerminate();   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提升状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">advanceRunState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetState)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//线程池状态至少为指定的targetState状态，或者CAS设置为指定的targetState状态，才会跳出循环</span><br>        <span class="hljs-keyword">if</span> (runStateAtLeast(c, targetState) ||    <br>            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中断所有的空闲的工作线程</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">()</span> </span>&#123;<br>    interruptIdleWorkers(<span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            <span class="hljs-comment">//拿到Worker中的线程</span><br>            Thread t = w.thread;    <br>            <span class="hljs-comment">//先判断一下线程是不是没有被中断然后尝试加锁</span><br>            <span class="hljs-comment">//但是通过前面的runWorker()源代码我们得知，开始之后是让Worker加了锁的，所以如果线程还在执行任务，那么这里肯定会false</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;   <br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//如果走到这里，那么说明线程肯定是一个闲着的线程，直接给中断</span><br>                    t.interrupt();    <br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//解锁</span><br>                    w.unlock();    <br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果只针对一个Worker，那么就结束循环</span><br>            <span class="hljs-keyword">if</span> (onlyOne)   <br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>shutdownNow()</code>方法也差不多，但是这里会更直接一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//shutdownNow开始后，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//权限校验，安全策略相关判断</span><br>        checkShutdownAccess();<br>      <span class="hljs-comment">//设置为STOP状态，不再像shutdown那么温柔</span><br>        advanceRunState(STOP);<br>      <span class="hljs-comment">//直接中断所有工作线程</span><br>        interruptWorkers();<br>      <span class="hljs-comment">//清空工作队列并且取出所有的未执行的任务</span><br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">//最后尝试终止线程池，使状态更变为TIDYING，执行钩子方法terminated()后，最终状态更新为TERMINATED</span><br>    tryTerminate();<br>    <span class="hljs-comment">//返回还未开始的任务</span><br>    <span class="hljs-keyword">return</span> tasks; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptWorkers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//遍历所有Worker</span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) <br>            <span class="hljs-comment">//无差别对待，一律添加中断标记</span><br>            w.interruptIfStarted();   <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看看<code>tryTerminate()</code>是怎么完完全全终止掉一个线程池的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//注意这是死循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//先获取一下ctl值</span><br>        <span class="hljs-keyword">int</span> c = ctl.get();    <br>      <span class="hljs-comment">//判断线程池的状态，如果是下面三种情况下的任意一种则直接返回：</span><br>        <span class="hljs-comment">//①、线程池处于RUNNING状态</span><br>        <span class="hljs-comment">//②、线程池至少为TIDYING状态</span><br>        <span class="hljs-comment">//③、线程池至少为STOP状态并且任务队列不为空</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>      <br>      <span class="hljs-comment">//工作线程数不为0，则中断工作线程集合中的第一个空闲的工作线程</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>      <span class="hljs-comment">//走到这里，工作线程也为空了，可以终止线程池了</span><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//// CAS设置线程池状态为TIDYING，如果设置成功则执行钩子方法terminated()</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;   <br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//最后更新线程池状态为TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">//唤醒阻塞再termination条件的所有线程，这个变量的await()方法在awaitTermination()中调用</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//注意如果CAS失败会直接进下一轮循环重新判断</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 转换timeout的单位为纳秒</span><br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 循环等待直到线程池状态更变为TERMINATED，每轮循环等待nanos纳秒</span><br>        <span class="hljs-keyword">while</span> (runStateLessThan(ctl.get(), TERMINATED)) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            nanos = termination.awaitNanos(nanos);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="计数器锁-CountDownLatch"><a href="#计数器锁-CountDownLatch" class="headerlink" title="计数器锁 CountDownLatch"></a>计数器锁 CountDownLatch</h2><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p><p> <strong>CountDownLatch 的两种典型用法</strong></p><p><strong>1、某一线程在开始运行前等待 n 个线程执行完毕。</strong></p><p>将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p><p><strong>2、实现多个线程开始执行任务的最大并行性。</strong></p><p>注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p><p><strong>CountDownLatch 的使用示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: CountDownLatch 使用方法示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchExample1</span> </span>&#123;<br><br>    <span class="hljs-comment">//请求的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadCount = <span class="hljs-number">550</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span><br>        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">300</span>);<br>        <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadCount);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadNum = i;<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    test(threadNum);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<span class="hljs-comment">//标识一个请求已经被完成</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>        countDownLatch.await();<br>        threadPool.shutdown();<br>        System.out.println(<span class="hljs-string">&quot;finish&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> threadNum)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//模拟请求的耗时操作</span><br>        System.out.println(<span class="hljs-string">&quot;threadNum:&quot;</span> + threadNum);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//模拟请求的耗时操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p><p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务</p><p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount-<span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-comment">//.......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p><p><strong>CountDownLatch 的不足</strong></p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h2 id="循环屏障-CyclicBarrier"><a href="#循环屏障-CyclicBarrier" class="headerlink" title="循环屏障 CyclicBarrier"></a>循环屏障 CyclicBarrier</h2><p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p><blockquote><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p></blockquote><p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><p><code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p><p>再来看一下它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(parties, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">this</span>.parties = parties;<br>    <span class="hljs-keyword">this</span>.count = parties;<br>    <span class="hljs-keyword">this</span>.barrierCommand = barrierAction;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，parties 就代表了要拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p><p><strong>CyclicBarrier 的应用场景</strong></p><p><code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p><p> <strong>CyclicBarrier 的使用示例</strong></p><p>实例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierExample1</span> </span>&#123;<br>    <span class="hljs-comment">//请求的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadCount = <span class="hljs-number">550</span>;<br>    <span class="hljs-comment">//需要同步的线程数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建线程池</span><br>        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadNum = i;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            threadPool.execute(() -&gt; &#123;<br>                test(threadNum);<br>            &#125;);<br>        &#125;<br>        threadPool.shutdown();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> threadNum)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;threadNum:&quot;</span> + threadNum + <span class="hljs-string">&quot;is ready&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待60秒，保证子线程完全执行结束</span><br>            cyclicBarrier.await(<span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----CyclicBarrierException------&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;threadNum:&quot;</span> + threadNum + <span class="hljs-string">&quot;is finish&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">threadnum:0is ready<br>threadnum:1is ready<br>threadnum:2is ready<br>threadnum:3is ready<br>threadnum:4is ready<br>threadnum:4is finish<br>threadnum:0is finish<br>threadnum:1is finish<br>threadnum:2is finish<br>threadnum:3is finish<br>threadnum:5is ready<br>threadnum:6is ready<br>threadnum:7is ready<br>threadnum:8is ready<br>threadnum:9is ready<br>threadnum:9is finish<br>threadnum:5is finish<br>threadnum:8is finish<br>threadnum:7is finish<br>threadnum:6is finish<br>......<br></code></pre></td></tr></table></figure><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await()</code> 方法之后的方法才被执行。</p><p>另外，<code>CyclicBarrier</code> 还提供一个更高级的构造函数 <code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于当线程到达屏障时，优先执行 <code>barrierAction</code>，方便处理更复杂的业务场景。</p><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 新建 CyclicBarrier 的时候指定一个 Runnable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierExample2</span> </span>&#123;<br>    <span class="hljs-comment">//请求的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadCount = <span class="hljs-number">550</span>;<br>    <span class="hljs-comment">//需要同步的线程数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">5</span>, () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;------当线程数达到之后，优先执行------&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建线程池</span><br>        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadNum = i;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    test(threadNum);<br>                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> threadNum)</span> <span class="hljs-keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;threadNum:&quot;</span> + threadNum + <span class="hljs-string">&quot;is ready&quot;</span>);<br>        cyclicBarrier.await();<br>        System.out.println(<span class="hljs-string">&quot;threadNum:&quot;</span> + threadNum + <span class="hljs-string">&quot;is finish&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">threadnum:0is ready<br>threadnum:1is ready<br>threadnum:2is ready<br>threadnum:3is ready<br>threadnum:4is ready<br>------当线程数达到之后，优先执行------<br>threadnum:4is finish<br>threadnum:0is finish<br>threadnum:2is finish<br>threadnum:1is finish<br>threadnum:3is finish<br>threadnum:5is ready<br>threadnum:6is ready<br>threadnum:7is ready<br>threadnum:8is ready<br>threadnum:9is ready<br>------当线程数达到之后，优先执行------<br>threadnum:9is finish<br>threadnum:5is finish<br>threadnum:6is finish<br>threadnum:8is finish<br>threadnum:7is finish<br>......<br></code></pre></td></tr></table></figure><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p><p><strong>CyclicBarrier 源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrier</span> </span>&#123;<br>    <span class="hljs-comment">//内部类，存放broken标记，表示屏障是否损坏，损坏的屏障是无法正常工作的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generation</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> broken = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** 内部维护一个可重入锁 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-comment">/** 再维护一个Condition */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition trip = lock.newCondition();<br>    <span class="hljs-comment">/** 这个就是屏障的最大阻挡容量，就是构造方法传入的初始值 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> parties;<br>    <span class="hljs-comment">/* 在屏障破裂时做的事情 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;<br>    <span class="hljs-comment">/** 当前这一轮的Generation对象，每一轮都有一个新的，用于保存broken标记 */</span><br>    <span class="hljs-keyword">private</span> Generation generation = <span class="hljs-keyword">new</span> Generation();<br><br>    <span class="hljs-comment">//默认为最大阻挡容量，每来一个线程-1，和CountDownLatch挺像，当屏障破裂或是被重置时，都会将其重置为最大阻挡容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>  <span class="hljs-comment">//构造方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        <span class="hljs-keyword">this</span>.parties = parties;<br>        <span class="hljs-keyword">this</span>.count = parties;<br>        <span class="hljs-keyword">this</span>.barrierCommand = barrierAction;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(parties, <span class="hljs-keyword">null</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">//开启下一轮屏障，一般屏障被冲破之后，就自动重置了，进入到下一轮</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextGeneration</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 唤醒所有等待状态的线程</span><br>        trip.signalAll();<br>        <span class="hljs-comment">// 重置count的值</span><br>        count = parties;<br>      <span class="hljs-comment">//创建新的Generation对象</span><br>        generation = <span class="hljs-keyword">new</span> Generation();<br>    &#125;<br><br>    <span class="hljs-comment">//破坏当前屏障，变为损坏状态，之后就不能再使用了，除非重置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">breakBarrier</span><span class="hljs-params">()</span> </span>&#123;<br>        generation.broken = <span class="hljs-keyword">true</span>;<br>        count = parties;<br>        trip.signalAll();<br>    &#125;<br>  <br>  <span class="hljs-comment">//开始等待</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> dowait(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(toe); <span class="hljs-comment">// 因为这里没有使用定时机制，不可能发生异常，如果发生怕是出了错误</span><br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">//可超时的等待</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException,</span><br><span class="hljs-function">               BrokenBarrierException,</span><br><span class="hljs-function">               TimeoutException </span>&#123;<br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-keyword">true</span>, unit.toNanos(timeout));<br>    &#125;<br><br>    <span class="hljs-comment">//这里就是真正的等待流程了，让我们细细道来</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dowait</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="hljs-function">               TimeoutException </span>&#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lock();   <span class="hljs-comment">//加锁，注意，因为多个线程都会调用await方法，因此只有一个线程能进，其他都被卡着了</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> Generation g = generation;   <span class="hljs-comment">//获取当前这一轮屏障的Generation对象</span><br><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();   <span class="hljs-comment">//如果这一轮屏障已经损坏，那就没办法使用了</span><br><br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;   <span class="hljs-comment">//如果当前等待状态的线程被中断，那么会直接破坏掉屏障，并抛出中断异常（破坏屏障的第1种情况）</span><br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> index = --count;     <span class="hljs-comment">//如果上面都没有出现不正常，那么就走正常流程，首先count自减并赋值给index，index表示当前是等待的第几个线程</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果自减之后就是0了，那么说明来的线程已经足够，可以冲破屏障了</span><br>                <span class="hljs-keyword">boolean</span> ranAction = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">final</span> Runnable command = barrierCommand;<br>                    <span class="hljs-keyword">if</span> (command != <span class="hljs-keyword">null</span>)<br>                        command.run();   <span class="hljs-comment">//执行冲破屏障后的任务，如果这里抛异常了，那么会进finally</span><br>                    ranAction = <span class="hljs-keyword">true</span>;<br>                    nextGeneration();   <span class="hljs-comment">//一切正常，开启下一轮屏障（方法进入之后会唤醒所有等待的线程，这样所有的线程都可以同时继续运行了）然后返回0，注意最下面finally中会解锁，不然其他线程唤醒了也拿不到锁啊</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!ranAction)   <span class="hljs-comment">//如果是上面出现异常进来的，那么也会直接破坏屏障（破坏屏障的第2种情况）</span><br>                        breakBarrier();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 能走到这里，那么说明当前等待的线程数还不够多，不足以冲破屏障</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;   <span class="hljs-comment">//无限循环，一直等，等到能冲破屏障或是出现异常为止</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!timed)<br>                        trip.await();    <span class="hljs-comment">//如果不是定时的，那么就直接永久等待</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                        nanos = trip.awaitNanos(nanos);   <span class="hljs-comment">//否则最多等一段时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;    <span class="hljs-comment">//等的时候会判断是否被中断（依然是破坏屏障的第1种情况）</span><br>                    <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                        breakBarrier();<br>                        <span class="hljs-keyword">throw</span> ie;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (g.broken)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();   <span class="hljs-comment">//如果线程被唤醒之后发现屏障已经被破坏，那么直接抛异常</span><br><br>                <span class="hljs-keyword">if</span> (g != generation)   <span class="hljs-comment">//成功冲破屏障开启下一轮，那么直接返回当前是第几个等待的线程。</span><br>                    <span class="hljs-keyword">return</span> index;<br><br>                <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;   <span class="hljs-comment">//线程等待超时，也会破坏屏障（破坏屏障的第3种情况）然后抛异常</span><br>                    breakBarrier();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();    <span class="hljs-comment">//最后别忘了解锁，不然其他线程拿不到锁</span><br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">//不多说了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getParties</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> parties;<br>    &#125;<br><br>  <span class="hljs-comment">//判断是否被破坏，也是加锁访问，因为有可能这时有其他线程正在执行dowait</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBroken</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> generation.broken;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">//重置操作，也要加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            breakBarrier();   <span class="hljs-comment">// 先破坏这一轮的线程，注意这个方法会先破坏再唤醒所有等待的线程，那么所有等待的线程会直接抛BrokenBarrierException异常（详情请看上方dowait倒数第13行）</span><br>            nextGeneration(); <span class="hljs-comment">// 开启下一轮</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">//获取等待线程数量，也要加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumberWaiting</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> parties - count;   <span class="hljs-comment">//最大容量 - 当前剩余容量 = 正在等待线程数</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>还记得我们在《操作系统》中学习的信号量机制吗？它在解决进程之间的同步问题中起着非常大的作用。</p><blockquote><p>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。</p></blockquote><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</p><p>通过使用信号量，我们可以决定某个资源同一时间能够被访问的最大线程数，它相当于对某个资源的访问进行了流量控制。简单来说，它就是一个可以被N个线程占用的排它锁（因此也支持公平和非公平模式），我们可以在最开始设定Semaphore的许可证数量，每个线程都可以获得1个或n个许可证，当许可证耗尽或不足以供其他线程获取时，其他线程将被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    <span class="hljs-comment">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span><br>    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">2</span>);   <span class="hljs-comment">//许可证配额设定为2</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();   <span class="hljs-comment">//申请一个许可证</span><br>                System.out.println(<span class="hljs-string">&quot;许可证申请成功！&quot;</span>);<br>                semaphore.release();   <span class="hljs-comment">//归还一个许可证</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    <span class="hljs-comment">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span><br>    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);   <span class="hljs-comment">//许可证配额设定为3</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire(<span class="hljs-number">2</span>);    <span class="hljs-comment">//一次性申请两个许可证</span><br>                System.out.println(<span class="hljs-string">&quot;许可证申请成功！&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();   <br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以通过Semaphore获取一些常规信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);   <span class="hljs-comment">//只配置一个许可证，5个线程进行争抢，不内卷还想要许可证？</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        <span class="hljs-keyword">new</span> Thread(semaphore::acquireUninterruptibly).start();   <span class="hljs-comment">//可以以不响应中断（主要是能简写一行，方便）</span><br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    System.out.println(<span class="hljs-string">&quot;剩余许可证数量：&quot;</span>+semaphore.availablePermits());<br>    System.out.println(<span class="hljs-string">&quot;是否存在线程等待许可证：&quot;</span>+(semaphore.hasQueuedThreads() ? <span class="hljs-string">&quot;是&quot;</span> : <span class="hljs-string">&quot;否&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;等待许可证线程数量：&quot;</span>+semaphore.getQueueLength());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以手动回收掉所有的许可证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">new</span> Thread(semaphore::acquireUninterruptibly).start();<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    System.out.println(<span class="hljs-string">&quot;收回剩余许可数量：&quot;</span>+semaphore.drainPermits());   <span class="hljs-comment">//直接回收掉剩余的许可证</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据交换-Exchanger"><a href="#数据交换-Exchanger" class="headerlink" title="数据交换 Exchanger"></a>数据交换 Exchanger</h2><p>使用Exchanger，它能够实现线程之间的数据交换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> Exchanger&lt;&gt;();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;收到主线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="hljs-string">&quot;AAAA&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;).start();<br>    System.out.println(<span class="hljs-string">&quot;收到子线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="hljs-string">&quot;BBBB&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">收到主线程传递的交换数据：BBBB<br>收到子线程传递的交换数据：AAAA<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在调用<code>exchange</code>方法后，当前线程会等待其他线程调用同一个exchanger对象的<code>exchange</code>方法，当另一个线程也调用之后，方法会返回对方线程传入的参数。</p><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>在JDK7时，出现了一个新的框架用于并行执行任务，它的目的是为了把大型任务拆分为多个小任务，最后汇总多个小任务的结果，得到整大任务的结果，并且这些小任务都是同时在进行，大大提高运算效率。Fork就是拆分，Join就是合并。</p><p>我们来演示一下实际的情况，比如一个算式：18x7+36x8+9x77+8x53，可以拆分为四个小任务：18x7、36x8、9x77、8x53，最后我们只需要将这四个任务的结果加起来，就是我们原本算式的结果了，有点归并排序的味道。</p><p><img src="/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/image-5.png" alt></p><p>它不仅仅只是拆分任务并使用多线程，而且还可以利用工作窃取算法，提高线程的利用率。</p><blockquote><p><strong>工作窃取算法：</strong>是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></blockquote><p><img src="/2022/08/01/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/image-6.png" alt></p><p>现在我们来看看如何使用它，这里以计算1-1000的和为例，我们可以将其拆分为8个小段的数相加，比如1-125、126-250… ，最后再汇总即可，它也是依靠线程池来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool();<br>        System.out.println(pool.submit(<span class="hljs-keyword">new</span> SubTask(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)).get());<br>    &#125;<br><br><br>  <span class="hljs-comment">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start;   <span class="hljs-comment">//比如我们要计算一个范围内所有数的和，那么就需要限定一下范围，这里用了两个int存放</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SubTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.start = start;<br>            <span class="hljs-keyword">this</span>.end = end;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(end - start &gt; <span class="hljs-number">125</span>) &#123;    <span class="hljs-comment">//每个任务最多计算125个数的和，如果大于继续拆分，小于就可以开始算了</span><br>                SubTask subTask1 = <span class="hljs-keyword">new</span> SubTask(start, (end + start) / <span class="hljs-number">2</span>);<br>                subTask1.fork();    <span class="hljs-comment">//执行子任务</span><br>                SubTask subTask2 = <span class="hljs-keyword">new</span> SubTask((end + start) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, end);<br>                subTask2.fork();   <span class="hljs-comment">//执行子任务</span><br>                <span class="hljs-keyword">return</span> subTask1.join() + subTask2.join();   <span class="hljs-comment">//越玩越有递归那味了</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 开始计算 &quot;</span>+start+<span class="hljs-string">&quot;-&quot;</span>+end+<span class="hljs-string">&quot; 的值!&quot;</span>);<br>                <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>                    res += i;<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;   <span class="hljs-comment">//返回的结果会作为join的结果</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span> 开始计算 <span class="hljs-number">1</span>-<span class="hljs-number">125</span> 的值!<br><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">4</span> 开始计算 <span class="hljs-number">251</span>-<span class="hljs-number">375</span> 的值!<br><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">5</span> 开始计算 <span class="hljs-number">751</span>-<span class="hljs-number">875</span> 的值!<br><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">5</span> 开始计算 <span class="hljs-number">876</span>-<span class="hljs-number">1000</span> 的值!<br><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span> 开始计算 <span class="hljs-number">501</span>-<span class="hljs-number">625</span> 的值!<br><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span> 开始计算 <span class="hljs-number">126</span>-<span class="hljs-number">250</span> 的值!<br><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">5</span> 开始计算 <span class="hljs-number">626</span>-<span class="hljs-number">750</span> 的值!<br><span class="hljs-attribute">ForkJoinPool</span>-<span class="hljs-number">1</span>-worker-<span class="hljs-number">4</span> 开始计算 <span class="hljs-number">376</span>-<span class="hljs-number">500</span> 的值!<br><span class="hljs-attribute">500500</span><br><br><span class="hljs-attribute">Process</span> finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，结果非常正确，但是整个计算任务实际上是拆分为了8个子任务同时完成的，结合多线程，原本的单线程任务，在多线程的加持下速度成倍提升。</p><p>包括Arrays工具类提供的并行排序也是利用了ForkJoinPool来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parallelSort</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = a.length, p, g;<br>    <span class="hljs-keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||<br>        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="hljs-number">1</span>)<br>        DualPivotQuicksort.sort(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">new</span> ArraysParallelSortHelpers.FJByte.Sorter<br>            (<span class="hljs-keyword">null</span>, a, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[n], <span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>,<br>             ((g = n / (p &lt;&lt; <span class="hljs-number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?<br>             MIN_ARRAY_SORT_GRAN : g).invoke();<br>&#125;<br></code></pre></td></tr></table></figure><p>并行排序的性能在多核心CPU环境下，肯定是优于普通排序的，并且排序规模越大优势越显著。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JUC笔记（二）并发编程核心</title>
    <link href="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/"/>
    <url>/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>在前面，我们了解了多线程的底层运作机制，我们终于知道，原来多线程环境下存在着如此之多的问题。在JDK5之前，我们只能选择<code>synchronized</code>关键字来实现锁，而JDK5之后，由于<code>volatile</code>关键字得到了升级，所以并发框架包便出现了，相比传统的<code>synchronized</code>关键字，我们对于锁的实现，有了更多的选择。</p><p>就让我们来感受一下，JUC为我们带来了什么。</p><h1 id="锁框架"><a href="#锁框架" class="headerlink" title="锁框架"></a>锁框架</h1><p>在JDK 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。</p><h2 id="Lock和Condition接口"><a href="#Lock和Condition接口" class="headerlink" title="Lock和Condition接口"></a>Lock和Condition接口</h2><p>使用并发包中的锁和我们传统的<code>synchronized</code>锁不太一样，这里的锁我们可以认为是一把真正意义上的锁，每个锁都是一个对应的锁对象，我只需要向锁对象获取锁或者释放锁即可。我们首先来看看，此接口中定义了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;<br>  <span class="hljs-comment">//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//同上，但是等待过程中会响应中断</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">//尝试获取锁，但是不会阻塞，如果能获取到会返回true，不能返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//暂时可以理解为替代传统的Object的wait()、notify()等操作的工具</span><br>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以演示一下，如何使用Lock类来进行加锁和释放锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Lock testLock = <span class="hljs-keyword">new</span> ReentrantLock();   <span class="hljs-comment">//可重入锁ReentrantLock类是Lock类的一个实现，我们后面会进行介绍</span><br>        Runnable action = () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123;   <span class="hljs-comment">//还是以自增操作为例</span><br>                testLock.lock();    <span class="hljs-comment">//加锁，加锁成功后其他线程如果也要获取锁，会阻塞，等待当前线程释放</span><br>                i++;<br>                testLock.unlock();  <span class="hljs-comment">//解锁，释放锁之后其他线程就可以获取这把锁了（注意在这之前一定得加锁，不然报错）</span><br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> Thread(action).start();<br>        <span class="hljs-keyword">new</span> Thread(action).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//等上面两个线程跑完</span><br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，和我们之前使用<code>synchronized</code>相比，我们这里是真正在操作一个”锁”对象，当我们需要加锁时，只需要调用<code>lock()</code>方法，而需要释放锁时，只需要调用<code>unlock()</code>方法。程序运行的最终结果和使用<code>synchronized</code>锁是一样的。</p><p>那么，我们如何像传统的加锁那样，调用对象的<code>wait()</code>和<code>notify()</code>方法呢，并发包提供了Condition接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Condition</span> </span>&#123;<br>  <span class="hljs-comment">//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒（感觉就是和普通对象的wait和notify是对应的）同时，等待状态下是可以响应中断的</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">//同上，但不响应中断（看名字都能猜到）</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断</span><br>  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断</span><br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断</span><br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//同上，但是是唤醒所有等待线程</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们通过一个简单的例子来演示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Lock testLock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    Condition condition = testLock.newCondition();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        testLock.lock();   <span class="hljs-comment">//和synchronized一样，必须持有锁的情况下才能使用await</span><br>        System.out.println(<span class="hljs-string">&quot;线程1进入等待状态！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();   <span class="hljs-comment">//进入等待状态</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1等待结束！&quot;</span>);<br>        testLock.unlock();<br>    &#125;).start();<br>    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">//防止线程2先跑</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        testLock.lock();<br>        System.out.println(<span class="hljs-string">&quot;线程2开始唤醒其他等待线程&quot;</span>);<br>        condition.signal();   <span class="hljs-comment">//唤醒线程1，但是此时线程1还必须要拿到锁才能继续运行</span><br>        System.out.println(<span class="hljs-string">&quot;线程2结束&quot;</span>);<br>        testLock.unlock();   <span class="hljs-comment">//这里释放锁之后，线程1就可以拿到锁继续运行了</span><br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，Condition对象使用方法和传统的对象使用差别不是很大。</p><p><strong>思考：</strong>下面这种情况跟上面有什么不同？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Lock testLock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        testLock.lock();<br>        System.out.println(<span class="hljs-string">&quot;线程1进入等待状态！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            testLock.newCondition().await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1等待结束！&quot;</span>);<br>        testLock.unlock();<br>    &#125;).start();<br>    Thread.sleep(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        testLock.lock();<br>        System.out.println(<span class="hljs-string">&quot;线程2开始唤醒其他等待线程&quot;</span>);<br>        testLock.newCondition().signal();<br>        System.out.println(<span class="hljs-string">&quot;线程2结束&quot;</span>);<br>        testLock.unlock();<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过分析可以得到，在调用<code>newCondition()</code>后，会生成一个新的Condition对象，并且同一把锁内是可以存在多个Condition对象的（实际上原始的锁机制等待队列只能有一个，而这里可以创建很多个Condition来实现多等待队列），而上面的例子中，线程1 和 线程2 实际上使用的是不同的Condition对象，只有对同一个Condition对象进行等待和唤醒操作才会有效，而不同的Condition对象是分开计算的。</p><p>最后我们再来讲解一下时间单位，这是一个枚举类，也是位于<code>java.util.concurrent</code>包下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TimeUnit</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Time unit representing one thousandth of a microsecond</span><br><span class="hljs-comment">     */</span><br>    NANOSECONDS &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">toNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d)</span>   </span>&#123; <span class="hljs-keyword">return</span> d; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">toMicros</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d)</span>  </span>&#123; <span class="hljs-keyword">return</span> d/(C1/C0); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">toMillis</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d)</span>  </span>&#123; <span class="hljs-keyword">return</span> d/(C2/C0); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">toSeconds</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d)</span> </span>&#123; <span class="hljs-keyword">return</span> d/(C3/C0); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">toMinutes</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d)</span> </span>&#123; <span class="hljs-keyword">return</span> d/(C4/C0); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">toHours</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d)</span>   </span>&#123; <span class="hljs-keyword">return</span> d/(C5/C0); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">toDays</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d)</span>    </span>&#123; <span class="hljs-keyword">return</span> d/(C6/C0); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d, TimeUnit u)</span> </span>&#123; <span class="hljs-keyword">return</span> u.toNanos(d); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">excessNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> d, <span class="hljs-keyword">long</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(d - (m*C2)); &#125;<br>    &#125;,<br>  <span class="hljs-comment">//....</span><br></code></pre></td></tr></table></figure><p>可以看到时间单位有很多的，比如<code>DAY</code>、<code>SECONDS</code>、<code>MINUTES</code>等，我们可以直接将其作为时间单位，比如我们要让一个线程等待3秒钟，可以像下面这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Lock testLock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        testLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待是否未超时：&quot;</span>+testLock.newCondition().await(<span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        testLock.unlock();<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，Lock类的tryLock方法也是支持使用时间单位的，各位可以自行进行测试。TimeUnit除了可以作为时间单位表示以外，还可以在不同单位之间相互转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;60秒 = &quot;</span>+TimeUnit.SECONDS.toMinutes(<span class="hljs-number">60</span>) +<span class="hljs-string">&quot;分钟&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;365天 = &quot;</span>+TimeUnit.DAYS.toSeconds(<span class="hljs-number">365</span>) +<span class="hljs-string">&quot; 秒&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以更加便捷地使用对象的<code>wait()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (Main.class) &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始等待&quot;</span>);<br>        TimeUnit.SECONDS.timedWait(Main.class, <span class="hljs-number">3</span>);   <span class="hljs-comment">//直接等待3秒</span><br>        System.out.println(<span class="hljs-string">&quot;等待结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以直接使用它来进行休眠操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);  <span class="hljs-comment">//休眠1秒钟</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>前面，我们讲解了锁框架的两个核心接口，那么我们接着来看看锁接口的具体实现类，我们前面用到了ReentrantLock，它其实是锁的一种，叫做可重入锁，那么这个可重入代表的是什么意思呢？简单来说，就是同一个线程，可以反复进行加锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    lock.lock();<br>    lock.lock();   <span class="hljs-comment">//连续加锁2次</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2想要获取锁&quot;</span>);<br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;线程2成功获取到锁&quot;</span>);<br>    &#125;).start();<br>    lock.unlock();<br>    System.out.println(<span class="hljs-string">&quot;线程1释放了一次锁&quot;</span>);<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    lock.unlock();<br>    System.out.println(<span class="hljs-string">&quot;线程1再次释放了一次锁&quot;</span>);  <span class="hljs-comment">//释放两次后其他线程才能加锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">线程<span class="hljs-number">1</span>释放了一次锁<br>线程<span class="hljs-number">2</span>想要获取锁<br>线程<span class="hljs-number">1</span>再次释放了一次锁<br>线程<span class="hljs-number">2</span>成功获取到锁<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，主线程连续进行了两次加锁操作（此操作是不会被阻塞的），在当前线程持有锁的情况下继续加锁不会被阻塞，并且，加锁几次，就必须要解锁几次，否则此线程依旧持有锁。我们可以使用<code>getHoldCount()</code>方法查看当前线程的加锁次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    lock.lock();<br>    lock.lock();<br>    System.out.println(<span class="hljs-string">&quot;当前加锁次数：&quot;</span>+lock.getHoldCount()+<span class="hljs-string">&quot;，是否被锁：&quot;</span>+lock.isLocked());<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    lock.unlock();<br>    System.out.println(<span class="hljs-string">&quot;当前加锁次数：&quot;</span>+lock.getHoldCount()+<span class="hljs-string">&quot;，是否被锁：&quot;</span>+lock.isLocked());<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    lock.unlock();<br>    System.out.println(<span class="hljs-string">&quot;当前加锁次数：&quot;</span>+lock.getHoldCount()+<span class="hljs-string">&quot;，是否被锁：&quot;</span>+lock.isLocked());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">当前加锁次数：<span class="hljs-number">2</span>，是否被锁：true<br>当前加锁次数：<span class="hljs-number">1</span>，是否被锁：true<br>当前加锁次数：<span class="hljs-number">0</span>，是否被锁：false<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，当锁不再被任何线程持有时，值为<code>0</code>，并且通过<code>isLocked()</code>方法查询结果为<code>false</code></p><p>实际上，如果存在线程持有当前的锁，那么其他线程在获取锁时，是会暂时进入到等待队列的，我们可以通过<code>getQueueLength()</code>方法获取等待中线程数量的预估值；我们可以通过<code>hasQueuedThread()</code>方法来判断某个线程是否正在等待获取锁状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    lock.lock();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(lock::lock), t2 = <span class="hljs-keyword">new</span> Thread(lock::lock);;<br>    t1.start();<br>    t2.start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;当前等待锁释放的线程数：&quot;</span>+lock.getQueueLength());<br>    System.out.println(<span class="hljs-string">&quot;线程1是否在等待队列中：&quot;</span>+lock.hasQueuedThread(t1));<br>    System.out.println(<span class="hljs-string">&quot;线程2是否在等待队列中：&quot;</span>+lock.hasQueuedThread(t2));<br>    System.out.println(<span class="hljs-string">&quot;当前线程是否在等待队列中：&quot;</span>+lock.hasQueuedThread(Thread.currentThread()));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">当前等待锁释放的线程数：<span class="hljs-number">2</span><br>线程<span class="hljs-number">1</span>是否在等待队列中：<span class="hljs-literal">true</span><br>线程<span class="hljs-number">2</span>是否在等待队列中：<span class="hljs-literal">true</span><br>当前线程是否在等待队列中：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>同样的，Condition也可以进行判断；通过使用<code>getWaitQueueLength()</code>方法能够查看同一个Condition目前有多少线程处于等待状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    Condition condition = lock.newCondition();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        lock.unlock();<br>    &#125;).start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    lock.lock();<br>    System.out.println(<span class="hljs-string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));<br>    condition.signal();<br>    System.out.println(<span class="hljs-string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">当前Condition的等待线程数：<span class="hljs-number">1</span><br>当前Condition的等待线程数：<span class="hljs-number">0</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>前面我们了解了如果线程之间争抢同一把锁，会暂时进入到等待队列中，那么多个线程获得锁的顺序是不是一定是根据线程调用<code>lock()</code>方法时间来定的呢，我们可以看到，<code>ReentrantLock</code>的构造方法中，是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync = <span class="hljs-keyword">new</span> NonfairSync();   <span class="hljs-comment">//看名字貌似是非公平的</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实锁分为公平锁和非公平锁，默认我们创建出来的ReentrantLock是采用的非公平锁作为底层锁机制。那么什么是公平锁什么又是非公平锁呢？</p><ul><li><strong>公平锁：</strong>多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li><li><strong>非公平锁：</strong>多个线程去获取锁的时候，会直接去尝试获取，如果获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li></ul><p>简单来说，公平锁不让插队，都老老实实排着；非公平锁让插队，但是排队的人让不让你插队就是另一回事了。</p><p>我们可以来测试一下公平锁和非公平锁的表现情况；这里我们选择使用第二个构造方法，可以选择是否为公平锁实现。</p><p><strong>非公平的情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//非公平</span><br><br>    Runnable action = () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 开始...&quot;</span>);<br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 成功获取锁！&quot;</span>);<br>        lock.unlock();<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;   <span class="hljs-comment">//建立10个线程</span><br>        <span class="hljs-keyword">new</span> Thread(action, <span class="hljs-string">&quot;T&quot;</span>+i).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">线程 <span class="hljs-built_in">T0</span> 开始...<br>线程 <span class="hljs-built_in">T4</span> 开始...<br>线程 <span class="hljs-built_in">T0</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T3</span> 开始...<br>线程 <span class="hljs-built_in">T2</span> 开始...<br>线程 <span class="hljs-built_in">T1</span> 开始...<br>线程 <span class="hljs-built_in">T1</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T7</span> 开始...<br>线程 <span class="hljs-built_in">T7</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T6</span> 开始...<br>线程 <span class="hljs-built_in">T5</span> 开始...<br>线程 <span class="hljs-built_in">T6</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T4</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T3</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T9</span> 开始...<br>线程 <span class="hljs-built_in">T8</span> 开始...<br>线程 <span class="hljs-built_in">T2</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T5</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T9</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T8</span> 成功获取锁！<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>公平的情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//公平</span><br><br>    Runnable action = () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 开始...&quot;</span>);<br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 成功获取锁！&quot;</span>);<br>        lock.unlock();<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;   <span class="hljs-comment">//建立10个线程</span><br>        <span class="hljs-keyword">new</span> Thread(action, <span class="hljs-string">&quot;T&quot;</span>+i).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">线程 <span class="hljs-built_in">T0</span> 开始...<br>线程 <span class="hljs-built_in">T2</span> 开始...<br>线程 <span class="hljs-built_in">T1</span> 开始...<br>线程 <span class="hljs-built_in">T3</span> 开始...<br>线程 <span class="hljs-built_in">T8</span> 开始...<br>线程 <span class="hljs-built_in">T0</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T5</span> 开始...<br>线程 <span class="hljs-built_in">T6</span> 开始...<br>线程 <span class="hljs-built_in">T7</span> 开始...<br>线程 <span class="hljs-built_in">T4</span> 开始...<br>线程 <span class="hljs-built_in">T9</span> 开始...<br>线程 <span class="hljs-built_in">T2</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T1</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T3</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T8</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T5</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T6</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T7</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T4</span> 成功获取锁！<br>线程 <span class="hljs-built_in">T9</span> 成功获取锁！<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里我们只需要对比<code>开始...</code>和<code>成功获取锁！</code>的顺序是否一致即可，如果是一致，那说明所有的线程都是按顺序排队获取的锁，如果不是，那说明肯定是有线程插队了。</p><p>运行结果可以发现，在公平模式下，确实是按照顺序进行的，而在非公平模式下，一般会出现这种情况：线程刚开始获取锁马上就能抢到，并且此时之前早就开始的线程还在等待状态，很明显的插队行为。</p><blockquote><p>那么，接着下一个问题，公平锁在任何情况下都一定是公平的吗？有关这个问题，我们会留到队列同步器中再进行讨论。</p></blockquote><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>除了可重入锁之外，还有一种类型的锁叫做读写锁，当然它并不是专门用作读写操作的锁，它和可重入锁不同的地方在于，可重入锁是一种排他锁，当一个线程得到锁之后，另一个线程必须等待其释放锁，否则一律不允许获取到锁。而读写锁在同一时间，是可以让多个线程获取到锁的，它其实就是针对于读写场景而出现的。</p><p>读写锁维护了一个读锁和一个写锁，这两个锁的机制是不同的。</p><ul><li>读锁：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁。</li><li>写锁：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁。</li></ul><p>读写锁也有一个专门的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteLock</span> </span>&#123;<br>    <span class="hljs-comment">//获取读锁</span><br>    <span class="hljs-function">Lock <span class="hljs-title">readLock</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">//获取写锁</span><br>    <span class="hljs-function">Lock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此接口有一个实现类ReentrantReadWriteLock（实现的是ReadWriteLock接口，而不是Lock接口，它本身并不是锁），注意我们操作ReentrantReadWriteLock时，不能直接上锁，而是需要获取读锁或是写锁，再进行锁操作。</p><p>这里我们对读锁加锁，可以看到可以<strong>多个线程能同时对读锁加锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    lock.readLock().lock();<br>    <span class="hljs-keyword">new</span> Thread(lock.readLock()::lock).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们对写锁加锁，<strong>多个线程无法同时对写锁加锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>        lock.writeLock().lock();<br>        <span class="hljs-keyword">new</span> Thread(lock.writeLock()::lock).start();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>多线程，有读锁状态下无法加写锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    lock.readLock().lock();<br>    <span class="hljs-keyword">new</span> Thread(lock.writeLock()::lock).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，<strong>多线程，有写锁状态下无法加读锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    lock.writeLock().lock();<br>    <span class="hljs-keyword">new</span> Thread(lock.readLock()::lock).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>ReentrantReadWriteLock不仅具有读写锁的功能，还保留了可重入锁和公平/非公平机制，比如<strong>同一个线程可以重复为写锁加锁，并且必须全部解锁才真正释放锁：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    lock.writeLock().lock();<br>    lock.writeLock().lock();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        lock.writeLock().lock();<br>        System.out.println(<span class="hljs-string">&quot;成功获取到写锁！&quot;</span>);<br>    &#125;).start();<br>    System.out.println(<span class="hljs-string">&quot;释放第一层锁！&quot;</span>);<br>    lock.writeLock().unlock();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;释放第二层锁！&quot;</span>);<br>    lock.writeLock().unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过之前的例子来验证公平和非公平：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">//        ReentrantReadWriteLock lock = new ReentrantReadWriteLock(false);</span><br><br>        Runnable action = () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 将在1秒后开始获取锁...&quot;</span>);<br>            lock.writeLock().lock();<br>            System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 成功获取锁！&quot;</span>);<br>            lock.writeLock().unlock();<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;   <span class="hljs-comment">//建立10个线程</span><br>            <span class="hljs-keyword">new</span> Thread(action, <span class="hljs-string">&quot;T&quot;</span>+i).start();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="锁降级和锁升级"><a href="#锁降级和锁升级" class="headerlink" title="锁降级和锁升级"></a>锁降级和锁升级</h3><p><strong>锁降级指的是写锁降级为读锁。当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但是线程自己是可以加读锁的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    lock.writeLock().lock();<br>    lock.readLock().lock();<br>    System.out.println(<span class="hljs-string">&quot;成功加读锁！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，如果我们在同时加了写锁和读锁的情况下，释放写锁，是否其他的线程就可以一起加读锁了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    lock.writeLock().lock();<br>    lock.readLock().lock();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始加读锁！&quot;</span>);<br>        lock.readLock().lock();<br>        System.out.println(<span class="hljs-string">&quot;读锁添加成功！&quot;</span>);<br>    &#125;).start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    lock.writeLock().unlock();    <span class="hljs-comment">//如果释放写锁，会怎么样？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">开始加读锁！<br>读锁添加成功！<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，一旦写锁被释放，那么主线程就只剩下读锁了，因为读锁可以被多个线程共享，所以这时第二个线程也添加了读锁。而这种操作，就被称之为”锁降级”（注意不是先释放写锁再加读锁，而是持有写锁的情况下申请读锁再释放写锁）</p><p>如果上述代码释放的是写锁，那么程序将无法运行结束，因为多个线程无法同时对写锁加锁。</p><p>注意在仅持有读锁的情况下去申请写锁，属于”锁升级”，ReentrantReadWriteLock是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    lock.readLock().lock();<br>    lock.writeLock().lock();<br>    System.out.println(<span class="hljs-string">&quot;所升级成功！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列同步器AQS"><a href="#队列同步器AQS" class="headerlink" title="队列同步器AQS"></a>队列同步器AQS</h2><blockquote><p><strong>注意：</strong>难度巨大！一定要熟练使用锁之后再来学习</p></blockquote><p>前面我们了解了可重入锁和读写锁，那么它们的底层实现原理到底是什么样的呢？</p><p>比如我们执行了ReentrantLock的<code>lock()</code>方法，那它的内部是怎么在执行的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.lock();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它的内部实际上啥都没做，而是交给了Sync对象在进行，并且，不只是这个方法，其他的很多方法都是依靠Sync对象在进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个Sync对象是干什么的呢？可以看到，公平锁和非公平锁都是继承自Sync，而Sync是继承自AbstractQueuedSynchronizer，简称队列同步器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>   <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>所以，要了解它的底层到底是如何进行操作的，还得看队列同步器，我们就先从这里下手吧！</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>AbstractQueuedSynchronizer（下面称为AQS）是实现锁机制的基础，它的内部封装了包括锁的获取、释放、以及等待队列。</p><p>一个锁（排他锁为例）的基本功能就是获取锁、释放锁、当锁被占用时，其他线程来争抢会进入等待队列，AQS已经将这些基本的功能封装完成了，其中等待队列是核心内容，等待队列是由双向链表数据结构实现的，每个等待状态下的线程都可以被封装进结点中并放入双向链表中，而对于双向链表是以队列的形式进行操作的，它像这样：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-1.png" alt></p><p>AQS中有一个<code>head</code>字段和一个<code>tail</code>字段分别记录双向链表的头结点和尾结点，而之后的一系列操作都是围绕此队列来进行的。我们先来了解一下每个结点都包含了哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>  <span class="hljs-comment">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br>  <span class="hljs-comment">//等待状态，这里都定义好了</span><br>   <span class="hljs-comment">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//此节点后面的节点被挂起（进入等待状态）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//在条件队列中的节点才是这个状态</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>  <span class="hljs-comment">//传播，一般用于共享锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;    <span class="hljs-comment">//等待状态值</span><br>    <span class="hljs-keyword">volatile</span> Node prev;   <span class="hljs-comment">//双向链表基操</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-keyword">volatile</span> Thread thread;   <span class="hljs-comment">//每一个线程都可以被封装进一个节点进入到等待队列</span><br>  <br>    Node nextWaiter;   <span class="hljs-comment">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>        Node p = prev;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    Node() &#123;<br>    &#125;<br><br>    Node(Thread thread, Node mode) &#123;<br>        <span class="hljs-keyword">this</span>.nextWaiter = mode;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br><br>    Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123;<br>        <span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一开始的时候，<code>head</code>和<code>tail</code>都是<code>null</code>，<code>state</code>为默认值<code>0</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br></code></pre></td></tr></table></figure><p>不用担心双向链表不会进行初始化，初始化是在实际使用时才开始的，先不管，我们接着来看其他的初始化内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接使用Unsafe类进行操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><span class="hljs-comment">//记录类中的属性在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> stateOffset;   <span class="hljs-comment">//这里对应的就是AQS类中的state成员字段</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> headOffset;    <span class="hljs-comment">//这里对应的就是AQS类中的head头结点成员字段</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> tailOffset;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> waitStatusOffset;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nextOffset;<br><br><span class="hljs-keyword">static</span> &#123;   <span class="hljs-comment">//静态代码块，在类加载的时候就会自动获取偏移地址</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        stateOffset = unsafe.objectFieldOffset<br>            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>));<br>        headOffset = unsafe.objectFieldOffset<br>            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;head&quot;</span>));<br>        tailOffset = unsafe.objectFieldOffset<br>            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));<br>        waitStatusOffset = unsafe.objectFieldOffset<br>            (Node.class.getDeclaredField(<span class="hljs-string">&quot;waitStatus&quot;</span>));<br>        nextOffset = unsafe.objectFieldOffset<br>            (Node.class.getDeclaredField(<span class="hljs-string">&quot;next&quot;</span>));<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>&#125;<br><br><span class="hljs-comment">//通过CAS操作来修改头结点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetHead</span><span class="hljs-params">(Node update)</span> </span>&#123;<br>  <span class="hljs-comment">//调用的是Unsafe类的compareAndSwapObject方法，通过CAS算法比较对象并替换</span><br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-keyword">this</span>, headOffset, <span class="hljs-keyword">null</span>, update);<br>&#125;<br><br><span class="hljs-comment">//同上，省略部分代码</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetWaitStatus</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetNext</span><span class="hljs-params">(Node node, Node expect, Node update)</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>可以发现，队列同步器由于要使用到CAS算法，所以，直接使用了Unsafe工具类，Unsafe类中提供了CAS操作的方法（Java无法实现，底层由C++实现）所有对AQS类中成员字段的修改，都有对应的CAS操作封装。</p><p>现在我们大致了解了一下它的底层运作机制，我们接着来看这个类是如何进行使用的，它提供了一些可重写的方法（根据不同的锁类型和机制，可以自由定制规则，并且为独占式和非独占式锁都提供了对应的方法），以及一些已经写好的模板方法（模板方法会调用这些可重写的方法），使用此类只需要将可重写的方法进行重写，并调用提供的模板方法，从而实现锁功能（学习过设计模式会比较好理解一些）</p><p>我们首先来看可重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//独占式获取同步状态，查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br><br><span class="hljs-comment">//独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br><br><span class="hljs-comment">//共享式获取同步状态，返回值大于0表示成功，否则失败</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br><br><span class="hljs-comment">//共享式释放同步状态</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br><br><span class="hljs-comment">//当前同步器是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这些需要重写的方法默认是直接抛出<code>UnsupportedOperationException</code>，也就是说根据不同的锁类型，我们需要去实现对应的方法，<strong>我们可以来看一下ReentrantLock（此类是全局独占式的）中的公平锁是如何借助AQS实现的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br><br>  <span class="hljs-comment">//加锁操作调用了模板方法acquire</span><br>  <span class="hljs-comment">//为了防止各位绕晕，请时刻记住，lock方法一定是在某个线程下为了加锁而调用的，并且同一时间可能会有其他线程也在调用此方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先看看加锁操作干了什么事情，这里直接调用了AQS提供的模板方法<code>acquire()</code>，我们来看看它在AQS类中的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span> <span class="hljs-comment">//这个是JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出，下同</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   <span class="hljs-comment">//节点为独占模式Node.EXCLUSIVE</span><br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会调用<code>tryAcquire()</code>方法（这里是由FairSync类实现的），如果尝试加独占锁失败（返回false了）说明可能这个时候有其他线程持有了此独占锁，所以当前线程得先等着，那么会调用<code>addWaiter()</code>方法将线程加入等待队列中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 先尝试使用CAS直接入队，如果这个时候其他线程也在入队（就是不止一个线程在同一时间争抢这把锁）就进入enq()</span><br>    Node pred = tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//此方法是CAS快速入队失败时调用</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>  <span class="hljs-comment">//自旋形式入队，可以看到这里是一个无限循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node t = tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-comment">//这种情况只能说明头结点和尾结点都还没初始化</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))   <span class="hljs-comment">//初始化头结点和尾结点</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;   <span class="hljs-comment">//只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点，所以说得进下一次循环再来一次CAS，这种形式就是自旋</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在了解了<code>addWaiter()</code>方法会将节点加入等待队列之后，我们接着来看，<code>addWaiter()</code>会返回已经加入的节点，<code>acquireQueued()</code>在得到返回的节点时，也会进入自旋状态，等待唤醒（也就是开始进入到拿锁的环节了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="hljs-comment">//可以看到当此节点位于队首(node.prev == head)时，会再次调用tryAcquire方法获取锁，如果获取成功，会返回此过程中是否被中断的值</span><br>                setHead(node);    <span class="hljs-comment">//新的头结点设置为当前结点</span><br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 原有的头结点没有存在的意义了</span><br>                failed = <span class="hljs-keyword">false</span>;   <span class="hljs-comment">//没有失败</span><br>                <span class="hljs-keyword">return</span> interrupted;   <span class="hljs-comment">//直接返回等待过程中是否被中断</span><br>            &#125;<br>          <span class="hljs-comment">//依然没获取成功，</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="hljs-comment">//将当前节点的前驱节点等待状态设置为SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下</span><br>                parkAndCheckInterrupt())   <span class="hljs-comment">//挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回true，直接将中断标志设为true，否则就是正常唤醒，继续自旋</span><br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//已经是SIGNAL，直接true</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//不能是已经取消的节点，必须找到一个没被取消的</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;   <span class="hljs-comment">//直接抛弃被取消的节点</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//不是SIGNAL，先CAS设置为SIGNAL（这里没有返回true因为CAS不一定成功，需要下一轮再判断一次）</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   <span class="hljs-comment">//返回false，马上开启下一轮循环</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    LockSupport.park(<span class="hljs-keyword">this</span>);   <span class="hljs-comment">//通过unsafe类操作底层挂起线程（会直接进入阻塞状态）</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，<code>acquire()</code>中的if条件如果为true，那么只有一种情况，就是等待过程中被中断了，其他任何情况下都是成功获取到独占锁，所以当等待过程被中断时，会调用<code>selfInterrupt()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是直接向当前线程发送中断信号了。</p><p>上面提到了LockSupport类，它是一个工具类，我们也可以来玩一下这个park和unpark:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t = Thread.currentThread();  <span class="hljs-comment">//先拿到主线程的Thread对象</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;主线程可以继续运行了！&quot;</span>);<br>            LockSupport.unpark(t);<br>          <span class="hljs-comment">//t.interrupt();   发送中断信号也可以恢复运行</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;).start();<br>    System.out.println(<span class="hljs-string">&quot;主线程被挂起！&quot;</span>);<br>    LockSupport.park();<br>    System.out.println(<span class="hljs-string">&quot;主线程继续运行！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们就把公平锁的<code>lock()</code>方法实现讲解完毕了（让我猜猜，已经晕了对吧，越是到源码越考验个人的基础知识掌握，基础不牢地动山摇）<strong>接着我们来看公平锁的<code>tryAcquire()</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>  <span class="hljs-comment">//可重入独占锁的公平实现</span><br>    <span class="hljs-meta">@ReservedStackAccess</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();   <span class="hljs-comment">//先获取当前线程的Thread对象</span><br>        <span class="hljs-keyword">int</span> c = getState();     <span class="hljs-comment">//获取当前AQS对象状态（独占模式下0为未占用，大于0表示已占用）</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">//如果是0，那就表示没有占用，现在我们的线程就要来尝试占用它</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    <span class="hljs-comment">//等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁</span><br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;   <span class="hljs-comment">//CAS设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还比你先抢到</span><br>                setExclusiveOwnerThread(current);    <span class="hljs-comment">//成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类AbstractOwnableSynchronizer中的，就表示当前这把锁已经是这个线程的了）</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//占用锁成功，返回true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;   <span class="hljs-comment">//如果不是0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁</span><br>            <span class="hljs-keyword">int</span> nextc = c + acquires;    <span class="hljs-comment">//多次加锁会将状态值进行增加，状态值就是加锁次数</span><br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//加到int值溢出了？</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);   <span class="hljs-comment">//设置为新的加锁次数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   <span class="hljs-comment">//其他任何情况都是加锁失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在了解了公平锁的实现之后，是不是感觉有点恍然大悟的感觉，虽然整个过程非常复杂，但是只要理清思路，还是比较简单的。</p><p><strong>加锁过程已经OK，我们接着来看，它的解锁过程，<code>unlock()</code>方法在AQS中是如何实现的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.release(<span class="hljs-number">1</span>);    <span class="hljs-comment">//直接调用了AQS中的release方法，参数为1表示解锁一次，state值-1</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;   <span class="hljs-comment">//和tryAcquire一样，也得子类去重写，释放锁操作</span><br>        Node h = head;    <span class="hljs-comment">//释放锁成功后，获取新的头结点</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)   <span class="hljs-comment">//如果新的头结点不为空并且不是刚刚建立的结点（初始状态下status为默认值0，而上面在进行了shouldParkAfterFailedAcquire之后，会被设定为SIGNAL状态，值为-1）</span><br>            unparkSuccessor(h);   <span class="hljs-comment">//唤醒头节点下一个节点中的线程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// 将等待状态waitStatus设置为初始值0</span><br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//获取下一个结点</span><br>    Node s = node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//如果下一个结点为空或是等待状态是已取消，那肯定是不能通知unpark的，这时就要遍历所有节点再另外找一个符合unpark要求的节点了</span><br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)   <span class="hljs-comment">//这里是从队尾向前，因为enq()方法中的t.next = node是在CAS之后进行的，而 node.prev = t 是CAS之前进行的，所以从后往前一定能够保证遍历所有节点</span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//要是找到了，就直接unpark，要是还是没找到，那就算了</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们来看看<code>tryRelease()</code>方法是怎么实现的，具体实现在Sync中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = getState() - releases;   <span class="hljs-comment">//先计算本次解锁之后的状态值</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())   <span class="hljs-comment">//因为是独占锁，那肯定这把锁得是当前线程持有才行</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();   <span class="hljs-comment">//否则直接抛异常</span><br>    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//如果解锁之后的值为0，表示已经完全释放此锁</span><br>        free = <span class="hljs-keyword">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);  <span class="hljs-comment">//将独占锁持有线程设置为null</span><br>    &#125;<br>    setState(c);   <span class="hljs-comment">//状态值设定为c</span><br>    <span class="hljs-keyword">return</span> free;  <span class="hljs-comment">//如果不是0表示此锁还没完全释放，返回false，是0就返回true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>综上，我们来画一个完整的流程图：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-2.png" alt></p><p>这里我们只讲解了公平锁，有关非公平锁和读写锁，还请各位观众根据我们之前的思路，自行解读。</p><h3 id="公平锁一定公平吗？"><a href="#公平锁一定公平吗？" class="headerlink" title="公平锁一定公平吗？"></a>公平锁一定公平吗？</h3><p>前面我们讲解了公平锁的实现原理，那么，我们尝试分析一下，在并发的情况下，公平锁一定公平吗？</p><p>我们再次来回顾一下<code>tryAcquire()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;   <span class="hljs-comment">//注意这里，公平锁的机制是，一开始会查看是否有节点处于等待</span><br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;   <span class="hljs-comment">//如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-keyword">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以<code>hasQueuedPredecessors()</code>这个环节容不得半点闪失，否则会直接破坏掉公平性，假如现在出现了这样的情况：</p><p>线程1已经持有锁了，这时线程2来争抢这把锁，走到<code>hasQueuedPredecessors()</code>，判断出为 <code>false</code>，线程2继续运行，然后线程2肯定获取锁失败（因为锁这时是被线程1占有的），因此就进入到等待队列中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    Node pred = tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">//由于一开始head和tail都是null，所以线程2直接就进enq()了</span><br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node t = tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 线程2进来之后，肯定是要先走这里的，因为head和tail都是null</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                tail = head;   <span class="hljs-comment">//这里就将tail直接等于head了，注意这里完了之后还没完，这里只是初始化过程</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而碰巧，这个时候线程3也来抢锁了，按照正常流程走到了<code>hasQueuedPredecessors()</code>方法，而在此方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>    Node h = head;<br>    Node s;<br>  <span class="hljs-comment">//这里直接判断h != t，而此时线程2才刚刚执行完 tail = head，所以直接就返回false了</span><br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>        ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，线程3这时就紧接着准备开始CAS操作了，又碰巧，这时线程1释放锁了，现在的情况就是，线程3直接开始CAS判断，而线程2还在插入节点状态，结果可想而知，居然是线程3先拿到了锁，这显然是违背了公平锁的公平机制。</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-3.png" alt></p><p>因此公平锁公不公平全看<code>hasQueuedPredecessors()</code>，而此方法只有在等待队列中存在节点时才能保证不会出现问题。所以<strong>公平锁，只有在等待队列存在节点时，才是真正公平的。</strong></p><h3 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h3><p>通过前面的学习，我们知道Condition类实际上就是用于代替传统对象的wait/notify操作的，同样可以实现等待/通知模式，并且同一把锁下可以创建多个Condition对象。那么我们接着来看看，它又是如何实现的呢，我们先从单个Condition对象进行分析：</p><p>在AQS中，Condition有一个实现类ConditionObject，而这里也是使用了链表实现了条件队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>;<br>    <span class="hljs-comment">/** 条件队列的头结点 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>    <span class="hljs-comment">/** 条件队列的尾结点 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>  <br>  <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>这里是直接使用了AQS中的Node类，但是使用的是Node类中的nextWaiter字段连接节点，并且Node的status为CONDITION：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-4.png" alt></p><p>我们知道，当一个线程调用<code>await()</code>方法时，会进入等待状态，直到其他线程调用<code>signal()</code>方法将其唤醒，而这里的条件队列，正是用于存储这些处于等待状态的线程。</p><p>我们先来看看最关键的<code>await()</code>方法是如何实现的，为了防止一会绕晕，在开始之前，我们先明确此方法的目标：</p><ul><li>只有已经持有锁的线程才可以使用此方法</li><li>当调用此方法后，会直接释放锁，无论加了多少次锁</li><li>只有其他线程调用<code>signal()</code>或是被中断时才会唤醒等待中的线程</li><li>被唤醒后，需要等待其他线程释放锁，拿到锁之后才可以继续执行，并且会恢复到之前的状态（await之前加了几层锁唤醒后依然是几层锁）</li></ul><p>好了，差不多可以上源码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();   <span class="hljs-comment">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span><br>    Node node = addConditionWaiter();    <span class="hljs-comment">//为当前线程创建一个新的节点，并将其加入到条件队列中</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);    <span class="hljs-comment">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span><br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;     <span class="hljs-comment">//用于保存中断状态</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;   <span class="hljs-comment">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中（之后我们会讲）</span><br>        LockSupport.park(<span class="hljs-keyword">this</span>);   <span class="hljs-comment">//如果依然处于等待状态，那么继续挂起</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)   <span class="hljs-comment">//看看等待的时候是不是被中断了</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  <span class="hljs-comment">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="hljs-comment">//直接开始acquireQueued尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了</span><br>        interruptMode = REINTERRUPT;<br>  <span class="hljs-comment">//已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作</span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <br>        unlinkCancelledWaiters();  <span class="hljs-comment">//将等待队列中，不是Node.CONDITION状态的节点移除</span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)   <span class="hljs-comment">//依然是响应中断</span><br>        reportInterruptAfterWait(interruptMode);<br>  <span class="hljs-comment">//OK，接着该干嘛干嘛</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上<code>await()</code>方法比较中规中矩，大部分操作也在我们的意料之中，那么我们接着来看<code>signal()</code>方法是如何实现的，同样的，为了防止各位绕晕，先明确signal的目标：</p><ul><li>只有持有锁的线程才能唤醒该锁所属于的Condition中等待的线程</li><li>优先唤醒条件队列中的第一个，如果唤醒过程中出现问题，接着找往下找，直到找到一个可以唤醒的</li><li>唤醒操作本质上是将条件队列中的结点直接丢进AQS等待队列中，让其参与到锁的竞争中</li><li>拿到锁之后，线程才能恢复运行</li></ul><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-5.png" alt></p><p>好了，上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())    <span class="hljs-comment">//先看看当前线程是不是持有锁的状态</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();   <span class="hljs-comment">//不是？那你不配唤醒别人</span><br>    Node first = firstWaiter;    <span class="hljs-comment">//获取条件队列的第一个结点</span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)    <span class="hljs-comment">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span><br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span><br>            lastWaiter = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//所以这里相当于是直接清空</span><br>        first.nextWaiter = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;   <span class="hljs-comment">//接着往下看</span><br>             (first = firstWaiter) != <span class="hljs-keyword">null</span>);   <span class="hljs-comment">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span><br>  <span class="hljs-comment">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span><br>    Node p = enq(node);<br>    <span class="hljs-keyword">int</span> ws = p.waitStatus;   <span class="hljs-comment">//保存前驱结点的等待状态</span><br>  <span class="hljs-comment">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);  <span class="hljs-comment">//直接唤醒线程</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实最让人不理解的就是倒数第二行，明明上面都正常进入到AQS等待队列了，应该是可以开始走正常流程了，那么这里为什么还要提前来一次unpark呢？</p><p>这里其实是为了进行优化而编写，直接unpark会有两种情况：</p><ul><li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足wc &gt; 0</li><li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足tail.waitStatus == 0，但在执行ws &gt;0之后!compareAndSetWaitStatus(p, ws,Node.SIGNAL)之前被取消，则CAS也会失败，满足compareAndSetWaitStatus(p, ws,Node.SIGNAL) == false</li></ul><p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了。</p><p>所以，大致流程下：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-6.png" alt></p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>前面我们讲解了锁框架的使用和实现原理，虽然比较复杂，但是收获还是很多的（主要是观摩大佬写的代码）这一部分我们就来讲一点轻松的。</p><p>前面我们说到，如果要保证<code>i++</code>的原子性，那么我们的唯一选择就是加锁，那么，除了加锁之外，还有没有其他更好的解决方法呢？JUC为我们提供了原子类，底层采用CAS算法，它是一种用法简单、性能高效、线程安全地更新变量的方式。</p><p>所有的原子类都位于<code>java.util.concurrent.atomic</code>包下。</p><h2 id="原子类介绍"><a href="#原子类介绍" class="headerlink" title="原子类介绍"></a>原子类介绍</h2><p>常用基本数据类，有对应的原子类封装：</p><ul><li>AtomicInteger：原子更新int</li><li>AtomicLong：原子更新long</li><li>AtomicBoolean：原子更新boolean</li></ul><p>那么，原子类和普通的基本类在使用上有没有什么区别呢？我们先来看正常情况下使用一个基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        System.out.println(i++);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们使用int类型对应的原子类，要实现同样的代码该如何编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>        System.out.println(i.getAndIncrement());  <span class="hljs-comment">//如果想实现i += 2这种操作，可以使用 addAndGet() 自由设置delta 值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将int数值封装到此类中（注意必须调用构造方法，它不像Integer那样有装箱机制），并且通过调用此类提供的方法来获取或是对封装的int值进行自增，乍一看，这不就是基本类型包装类嘛，有啥高级的。确实，还真有包装类那味，但是它可不仅仅是简单的包装，它的自增操作是具有原子性的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Runnable r = () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++)<br>                i.getAndIncrement();<br>            System.out.println(<span class="hljs-string">&quot;自增完成！&quot;</span>);<br>        &#125;;<br>        <span class="hljs-keyword">new</span> Thread(r).start();<br>        <span class="hljs-keyword">new</span> Thread(r).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        System.out.println(i.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">自增完成！<br>自增完成！<br><span class="hljs-number">200000</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>同样是直接进行自增操作，我们发现，使用原子类是可以保证自增操作原子性的，就跟我们前面加锁一样。怎么会这么神奇？我们来看看它的底层是如何实现的，直接从构造方法点进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialValue)</span> </span>&#123;<br>    value = initialValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它的底层是比较简单的，其实本质上就是封装了一个<code>volatile</code>类型的int值，这样能够保证可见性，在CAS操作的时候不会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        valueOffset = unsafe.objectFieldOffset<br>            (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最上面是和AQS采用了类似的机制，因为要使用CAS算法更新value的值，所以得先计算出value字段在对象中的偏移地址，CAS直接修改对应位置的内存即可（可见Unsafe类的作用巨大，很多的底层操作都要靠它来完成）</p><p>接着我们来看自增操作是怎么在运行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里调用了<code>unsafe.getAndAddInt()</code>，套娃时间到，我们接着看看Unsafe里面写了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">int</span> delta)</span> </span>&#123;  <span class="hljs-comment">//delta就是变化的值，++操作就是自增1</span><br>    <span class="hljs-keyword">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">//volatile版本的getInt()</span><br>      <span class="hljs-comment">//能够保证可见性</span><br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));  <span class="hljs-comment">//这里是开始cas替换int的值，每次都去拿最新的值去进行替换，如果成功则离开循环，不成功说明这个时候其他线程先修改了值，就进下一次循环再获取最新的值然后再cas一次，直到成功为止</span><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这是一个<code>do-while</code>循环，那么这个循环在做一个什么事情呢？感觉就和我们之前讲解的AQS队列中的机制差不多，也是采用自旋形式，来不断进行CAS操作，直到成功。</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-7.png" alt></p><p>可见，原子类底层也是采用了CAS算法来保证的原子性，包括<code>getAndSet</code>、<code>getAndAdd</code>等方法都是这样。原子类也直接提供了CAS操作方法，我们可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    AtomicInteger integer = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">10</span>);<br>    System.out.println(integer.compareAndSet(<span class="hljs-number">30</span>, <span class="hljs-number">20</span>));<br>    System.out.println(integer.compareAndSet(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>    System.out.println(integer);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想以普通变量的方式来设定值，那么可以使用<code>lazySet()</code>方法，这样就不采用<code>volatile</code>的立即可见机制了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicInteger integer = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>integer.lazySet(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>除了基本类有原子类以外，基本类型的数组类型也有原子类：</p><ul><li><p>AtomicIntegerArray：原子更新int数组</p></li><li><p>AtomicLongArray：原子更新long数组</p></li><li><p>AtomicReferenceArray：原子更新引用数组</p></li></ul><p>其实原子数组和原子类型一样的，不过我们可以对数组内的元素进行原子操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    AtomicIntegerArray array = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;);<br>    Runnable r = () -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>            array.getAndAdd(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    &#125;;<br>    <span class="hljs-keyword">new</span> Thread(r).start();<br>    <span class="hljs-keyword">new</span> Thread(r).start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    System.out.println(array.get(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>在JDK8之后，新增了<code>DoubleAdder</code>和<code>LongAdder</code>，在高并发情况下，<code>LongAdder</code>的性能比<code>AtomicLong</code>的性能更好，主要体现在自增上，它的大致原理如下：</p><p>在低并发情况下，和<code>AtomicLong</code>是一样的，对value值进行CAS操作，但是出现高并发的情况时，<code>AtomicLong</code>会进行大量的循环操作来保证同步，而<code>LongAdder</code>会将对value值的CAS操作分散为对数组<code>cells</code>中多个元素的CAS操作（内部维护一个Cell[] as数组，每个Cell里面有一个初始值为0的long型变量，在高并发时会进行分散CAS，就是不同的线程可以对数组中不同的元素进行CAS自增，这样就避免了所有线程都对同一个值进行CAS），只需要最后再将结果加起来即可。</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-8.png" alt></p><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    LongAdder adder = <span class="hljs-keyword">new</span> LongAdder();<br>    Runnable r = () -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>            adder.add(<span class="hljs-number">1</span>);<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        <span class="hljs-keyword">new</span> Thread(r).start();   <span class="hljs-comment">//100个线程</span><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    System.out.println(adder.sum());   <span class="hljs-comment">//最后求和即可</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于底层源码比较复杂，这里就不做讲解了。两者的性能对比（这里用到了CountDownLatch，建议学完之后再来看）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用AtomicLong的时间消耗：&quot;</span>+test2()+<span class="hljs-string">&quot;ms&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;使用LongAdder的时间消耗：&quot;</span>+test1()+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">100</span>);<br>        LongAdder adder = <span class="hljs-keyword">new</span> LongAdder();<br>        <span class="hljs-keyword">long</span> timeStart = System.currentTimeMillis();<br>        Runnable r = () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>                adder.add(<span class="hljs-number">1</span>);<br>            latch.countDown();<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>            <span class="hljs-keyword">new</span> Thread(r).start();<br>        latch.await();<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - timeStart;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">100</span>);<br>        AtomicLong atomicLong = <span class="hljs-keyword">new</span> AtomicLong();<br>        <span class="hljs-keyword">long</span> timeStart = System.currentTimeMillis();<br>        Runnable r = () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>                atomicLong.incrementAndGet();<br>            latch.countDown();<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>            <span class="hljs-keyword">new</span> Thread(r).start();<br>        latch.await();<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - timeStart;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了对基本数据类型支持原子操作外，对于引用类型，也是可以实现原子操作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String a = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    String b = <span class="hljs-string">&quot;World&quot;</span>;<br>    AtomicReference&lt;String&gt; reference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(a);<br>    reference.compareAndSet(a, b);<br>    System.out.println(reference.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>JUC还提供了字段原子更新器，可以对类中的某个指定字段进行原子操作（注意字段必须添加volatile关键字）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Student student = <span class="hljs-keyword">new</span> Student();<br>        AtomicIntegerFieldUpdater&lt;Student&gt; fieldUpdater =<br>                AtomicIntegerFieldUpdater.newUpdater(Student.class, <span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(fieldUpdater.incrementAndGet(student));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>了解了这么多原子类，是不是感觉要实现保证原子性的工作更加轻松了？</p><h2 id="ABA问题及解决方案"><a href="#ABA问题及解决方案" class="headerlink" title="ABA问题及解决方案"></a>ABA问题及解决方案</h2><p>我们来想象一下这种场景：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-9.png" alt></p><p>线程1和线程2同时开始对<code>a</code>的值进行CAS修改，但是线程1的速度比较快，将a的值修改为2之后紧接着又修改回1，这时线程2才开始进行判断，发现a的值是1，所以CAS操作成功。</p><p>很明显，这里的1已经不是一开始的那个1了，而是被重新赋值的1，这也是CAS操作存在的问题（无锁虽好，但是问题多多），它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为<code>ABA</code>问题。</p><p>那么如何解决这种<code>ABA</code>问题呢，JUC提供了带版本号的引用类型，只要每次操作都记录一下版本号，并且版本号不会重复，那么就可以解决ABA问题了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String a = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    String b = <span class="hljs-string">&quot;World&quot;</span>;<br>    AtomicStampedReference&lt;String&gt; reference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(a, <span class="hljs-number">1</span>);  <span class="hljs-comment">//在构造时需要指定初始值和对应的版本号</span><br>    reference.attemptStamp(a, <span class="hljs-number">2</span>);   <span class="hljs-comment">//可以中途对版本号进行修改，注意要填写当前的引用对象</span><br>    System.out.println(reference.compareAndSet(a, b, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));   <span class="hljs-comment">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，有关原子类的讲解就到这里。</p><h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>简单的讲完了，又该讲难一点的了。</p><p><strong>注意：</strong>本版块的重点在于探究并发容器是如何利用锁机制和算法实现各种丰富功能的，我们会忽略一些常规功能的实现细节（比如链表如何插入元素删除元素），而更关注并发容器应对并发场景算法上的实现（比如在多线程环境下的插入操作是按照什么规则进行的）</p><p>在单线程模式下，集合类提供的容器可以说是非常方便了，几乎我们每个项目中都能或多或少的用到它们，我们在JavaSE阶段，为各位讲解了各个集合类的实现原理，我们了解了链表、顺序表、哈希表等数据结构，那么，在多线程环境下，这些数据结构还能正常工作吗？</p><h2 id="传统容器线程安全吗"><a href="#传统容器线程安全吗" class="headerlink" title="传统容器线程安全吗"></a>传统容器线程安全吗</h2><p>我们来测试一下，100个线程同时向ArrayList中添加元素会怎么样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Runnable r = () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>                list.add(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>            <span class="hljs-keyword">new</span> Thread(r).start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外的话，肯定是会报错的：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Thread-0&quot;</span> Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Thread-2&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span>: <span class="hljs-number">73</span><br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.add</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">463</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(Main<span class="hljs-selector-class">.java</span>:<span class="hljs-number">18</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span>: <span class="hljs-number">105</span><br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.add</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">463</span>)<br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(Main<span class="hljs-selector-class">.java</span>:<span class="hljs-number">18</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br><span class="hljs-number">9700</span><br><br>Process finished with exit <span class="hljs-selector-tag">code</span> <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>那么我们来看看报的什么错，从栈追踪信息可以看出，是add方法出现了问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;   <span class="hljs-comment">//这一句出现了数组越界</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，同一时间其他线程也在疯狂向数组中添加元素，那么这个时候就有可能在<code>ensureCapacityInternal</code>（确认容量足够）执行之后，<code>elementData[size++] = e;</code>执行之前，其他线程插入了元素，导致size的值超出了数组容量。这些在单线程的情况下不可能发生的问题，在多线程下就慢慢出现了。</p><p>我们再来看看比较常用的HashMap呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> finalI = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++)<br>                    map.put(finalI * <span class="hljs-number">1000</span> + j, <span class="hljs-string">&quot;lbwnb&quot;</span>);<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(map.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">9926</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>经过测试发现，虽然没有报错，但是最后的结果并不是我们期望的那样，实际上它还有可能导致Entry对象出现环状数据结构，引起死循环。</p><p>所以，在多线程环境下，要安全地使用集合类，我们得找找解决方案了。</p><h2 id="并发容器介绍"><a href="#并发容器介绍" class="headerlink" title="并发容器介绍"></a>并发容器介绍</h2><p>怎么才能解决并发情况下的容器问题呢？我们首先想到的肯定是给方法前面加个<code>synchronzed</code>关键字，这样总不会抢了吧，在之前我们可以使用Vector或是Hashtable来解决，但是它们的效率实在是太低了，完全依靠锁来解决问题，因此现在已经很少再使它们了，这里也不会再去进行讲解。</p><p>JUC提供了专用于并发场景下的容器，比如我们刚刚使用的ArrayList，在多线程环境下是没办法使用的，我们可以将其替换为JUC提供的多线程专用集合类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();  <span class="hljs-comment">//这里使用CopyOnWriteArrayList来保证线程安全</span><br>        Runnable r = () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>                list.add(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>            <span class="hljs-keyword">new</span> Thread(r).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">10000</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们发现，使用了<code>CopyOnWriteArrayList</code>之后，再没出现过上面的问题。</p><p>那么它是如何实现的呢，我们先来看看它是如何进行<code>add()</code>操作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();   <span class="hljs-comment">//直接加锁，保证同一时间只有一个线程进行添加操作</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();  <span class="hljs-comment">//获取当前存储元素的数组</span><br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);   <span class="hljs-comment">//直接复制一份数组</span><br>        newElements[len] = e;   <span class="hljs-comment">//修改复制出来的数组</span><br>        setArray(newElements);   <span class="hljs-comment">//将元素数组设定为复制出来的数组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到添加操作是直接上锁，并且会先拷贝一份当前存放元素的数组，然后对数组进行修改，再将此数组替换（CopyOnWrite）接着我们来看读操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，<code>CopyOnWriteArrayList</code>对于读操作不加锁，而对于写操作是加锁的，类似于我们前面讲解的读写锁机制，这样就可以保证不丢失读性能的情况下，写操作不会出现问题。</p><p>接着我们来看对于HashMap的并发容器<code>ConcurrentHashMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> finalI = i;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++)<br>                map.put(finalI * <span class="hljs-number">100</span> + j, <span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    System.out.println(map.size());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">10000</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到这里的ConcurrentHashMap就没有出现之前HashMap的问题了。因为线程之间会争抢同一把锁，我们之前在讲解LongAdder的时候学习到了一种压力分散思想，既然每个线程都想抢锁，那我就干脆多搞几把锁，让你们每个人都能拿到，这样就不会存在等待的问题了，而JDK7之前，ConcurrentHashMap的原理也比较类似，它将所有数据分为一段一段地存储，先分很多段出来，每一段都给一把锁，当一个线程占锁访问时，只会占用其中一把锁，也就是仅仅锁了一小段数据，而其他段的数据依然可以被其他线程正常访问。</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-10.png" alt></p><p>这里我们重点讲解JDK8之后它是怎么实现的，它采用了CAS算法配合锁机制实现，我们先来回顾一下JDK8下的HashMap是什么样的结构：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-11.png" alt></p><p>HashMap就是利用了哈希表，哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。</p><p>又是基础不牢地动山摇环节，由于ConcurrentHashMap的源码比较复杂，所以我们先从最简单的构造方法开始下手：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-12.png" alt></p><p>我们发现，它的构造方法和HashMap的构造方法有很大的出入，但是大体的结构和HashMap是差不多的，也是维护了一个哈希表，并且哈希表中存放的是链表或是红黑树，所以我们直接来看<code>put()</code>操作是如何实现的，只要看明白这个，基本上就懂了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-comment">//有点小乱，如果看着太乱，可以在IDEA中折叠一下代码块，不然有点难受</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(); <span class="hljs-comment">//键值不能为空，基操</span><br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());    <span class="hljs-comment">//计算键的hash值，用于确定在哈希表中的位置</span><br>    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;   <span class="hljs-comment">//一会用来记录链表长度的，忽略</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="hljs-comment">//无限循环，而且还是并发包中的类，盲猜一波CAS自旋锁</span><br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();    <span class="hljs-comment">//如果数组（哈希表）为空肯定是要进行初始化的，然后再重新进下一轮循环</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">//如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))  <br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)   <span class="hljs-comment">//头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span><br>            tab = helpTransfer(tab, f);   <span class="hljs-comment">//帮助进行迁移，完事之后再来下一次循环</span><br>        <span class="hljs-keyword">else</span> &#123;     <span class="hljs-comment">//特殊情况都完了，这里就该是正常情况了，</span><br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;   <span class="hljs-comment">//在前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里直接把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span><br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">//头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span><br>                        ...实现细节略<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;   <span class="hljs-comment">//肯定不大于0，肯定也不是-1，还判断是不是TreeBin，所以不用猜了，肯定是红黑树，下面就是针对红黑树的情况进行操作</span><br>                      <span class="hljs-comment">//在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span><br>                        ...实现细节略<br>                    &#125;<br>                &#125;<br>            &#125;<br>          <span class="hljs-comment">//根据链表长度决定是否要进化为红黑树</span><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);   <span class="hljs-comment">//注意这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，它会优先考虑对哈希表进行扩容</span><br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>怎么样，是不是感觉看着挺复杂，其实也还好，总结一下就是：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-13.png" alt></p><p>我们接着来看看<code>get()</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;<br>    <span class="hljs-keyword">int</span> h = spread(key.hashCode());   <span class="hljs-comment">//计算哈希值</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// 如果头结点就是我们要找的，那直接返回值就行了</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>      <span class="hljs-comment">//要么是正在扩容，要么就是红黑树，负数只有这两种情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;<br>      <span class="hljs-comment">//确认无误，肯定在列表里，开找</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//没找到只能null了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上，ConcurrentHashMap的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了ConcurrentHashMap在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因。显然，这种加锁方式比JDK7的分段锁机制性能更好。</p><p>其实这里也只是简单地介绍了一下它的运行机制，ConcurrentHashMap真正的难点在于扩容和迁移操作，我们主要了解的是他的并发执行机制，有关它的其他实现细节，这里暂时不进行讲解。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>除了我们常用的容器类之外，JUC还提供了各种各样的阻塞队列，用于不同的工作场景。</p><p>阻塞队列本身也是队列，但是它是适用于多线程环境下的，基于ReentrantLock实现的，它的接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//入队，如果队列已满，返回false否则返回true（非阻塞）</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//入队，如果队列已满，阻塞线程直到能入队为止</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><br>    <span class="hljs-comment">//入队，如果队列已满，阻塞线程直到能入队、超时、中断为止，入队成功返回true否则false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><br>    <span class="hljs-comment">//出队，如果队列为空，阻塞线程直到能出队为止</span><br>    <span class="hljs-function">E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><br>    <span class="hljs-comment">//出队，如果队列为空，阻塞线程直到能出队、超时、中断为止，出队成功正常返回，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><br>    <span class="hljs-comment">//返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remainingCapacity</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br><br>  <span class="hljs-comment">//一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> E&gt; c, <span class="hljs-keyword">int</span> maxElements)</span></span>;<br></code></pre></td></tr></table></figure><p>比如现在有一个容量为3的阻塞队列，这个时候一个线程<code>put</code>向其添加了三个元素，第二个线程接着<code>put</code>向其添加三个元素，那么这个时候由于容量已满，会直接被阻塞，而这时第三个线程从队列中取走2个元素，线程二停止阻塞，先丢两个进去，还有一个还是进不去，所以说继续阻塞。</p><p>利用阻塞队列，我们可以轻松地实现消费者和生产者模式，还记得我们在JavaSE中的实战吗？</p><blockquote><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p></blockquote><p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒，窗口上只能放一个菜。</p><p>我们来看看，使用阻塞队列如何实现，这里我们就使用<code>ArrayBlockingQueue</code>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        BlockingQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">1</span>);<br>        Runnable supplier = () -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    String name = Thread.currentThread().getName();<br>                    System.err.println(time()+<span class="hljs-string">&quot;生产者 &quot;</span>+name+<span class="hljs-string">&quot; 正在准备餐品...&quot;</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                    System.err.println(time()+<span class="hljs-string">&quot;生产者 &quot;</span>+name+<span class="hljs-string">&quot; 已出餐！&quot;</span>);<br>                    queue.put(<span class="hljs-keyword">new</span> Object());<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        Runnable consumer = () -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    String name = Thread.currentThread().getName();<br>                    System.out.println(time()+<span class="hljs-string">&quot;消费者 &quot;</span>+name+<span class="hljs-string">&quot; 正在等待出餐...&quot;</span>);<br>                    queue.take();<br>                    System.out.println(time()+<span class="hljs-string">&quot;消费者 &quot;</span>+name+<span class="hljs-string">&quot; 取到了餐品。&quot;</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>                    System.out.println(time()+<span class="hljs-string">&quot;消费者 &quot;</span>+name+<span class="hljs-string">&quot; 已经将饭菜吃完了！&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) <span class="hljs-keyword">new</span> Thread(supplier, <span class="hljs-string">&quot;Supplier-&quot;</span>+i).start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) <span class="hljs-keyword">new</span> Thread(consumer, <span class="hljs-string">&quot;Consumer-&quot;</span>+i).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">time</span><span class="hljs-params">()</span></span>&#123;<br>        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span>+format.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">&quot;] &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，阻塞队列在多线程环境下的作用是非常明显的，一共有三种常用的阻塞队列：</p><ul><li>ArrayBlockingQueue：有界带缓冲阻塞队列（就是队列是有容量限制的，装满了肯定是不能再装的，只能阻塞，数组实现）</li><li>SynchronousQueue：无缓冲阻塞队列（相当于没有容量的ArrayBlockingQueue，因此只有阻塞的情况）</li><li>LinkedBlockingQueue：无界带缓冲阻塞队列（没有容量限制，也可以限制容量，也会阻塞，链表实现）</li></ul><p><strong>这里我们以 <code>ArrayBlockingQueue</code> 为例进行源码解读，我们先来看看构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity];<br>    lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);   <span class="hljs-comment">//底层采用锁机制保证线程安全性，这里我们可以选择使用公平锁或是非公平锁</span><br>    notEmpty = lock.newCondition();   <span class="hljs-comment">//这里创建了两个Condition（都属于lock）一会用于入队和出队的线程阻塞控制</span><br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看入队操作是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    <span class="hljs-comment">//可以看到这里也是使用了类里面的ReentrantLock进行加锁操作</span><br>    lock.lock();    <span class="hljs-comment">//保证同一时间只有一个线程进入</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (count == items.length)   <span class="hljs-comment">//直接看看队列是否已满，如果没满则直接入队，如果已满则返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            enqueue(e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    <span class="hljs-comment">//同样的，需要进行加锁操作</span><br>    lock.lockInterruptibly();    <span class="hljs-comment">//注意这里是可以响应中断的</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();    <span class="hljs-comment">//可以看到当队列已满时会直接挂起当前线程，在其他线程出队操作时会被唤醒</span><br>        enqueue(e);   <span class="hljs-comment">//直到队列有空位才将线程入队</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[takeIndex] != null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E x = (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)<br>        itrs.elementDequeued();<br>    notFull.signal();    <span class="hljs-comment">//出队操作会调用notFull的signal方法唤醒被挂起处于等待状态的线程</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看出队操作是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();    <span class="hljs-comment">//出队同样进行加锁操作，保证同一时间只能有一个线程执行</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">null</span> : dequeue();   <span class="hljs-comment">//如果队列不为空则出队，否则返回null</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();    <span class="hljs-comment">//可以响应中断进行加锁</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();    <span class="hljs-comment">//和入队相反，也是一直等直到队列中有元素之后才可以出队，在入队时会唤醒此线程</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E x)</span> </span>&#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[putIndex] == null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>    items[putIndex] = x;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    notEmpty.signal();    <span class="hljs-comment">//对notEmpty的signal唤醒操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可见，如果各位对锁的使用非常熟悉的话，那么在阅读这些源码的时候，就会非常轻松了。</p><p><strong>接着我们来看一个比较特殊的队列<code>SynchronousQueue</code>，它没有任何容量，也就是说正常情况下出队必须和入队操作成对出现，我们先来看它的内部，可以看到内部有一个抽象类Transferer，它定义了一个<code>transfer</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transferer</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 可以是put也可以是take操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 如果不是空，即作为生产者，那么表示会将传入参数元素e交给消费者</span><br><span class="hljs-comment">     *          如果为空，即作为消费者，那么表示会从生产者那里得到一个元素e并返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> 是否可以超时</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> 超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 不为空就是从生产者那里返回的，为空表示要么被中断要么超时。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> E <span class="hljs-title">transfer</span><span class="hljs-params">(E e, <span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看，有点迷惑，难不成还要靠这玩意去实现put和take操作吗？实际上它是直接以生产者消费者模式进行的，由于不需要依靠任何容器结构来暂时存放数据，所以我们可以直接通过<code>transfer</code>方法来对生产者和消费者之间的数据进行传递。</p><p>比如一个线程put一个新的元素进入，这时如果没有其他线程调用take方法获取元素，那么会持续被阻塞，直到有线程取出元素，而<code>transfer</code>正是需要等生产者消费者双方都到齐了才能进行交接工作，单独只有其中一方都需要进行等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();  <span class="hljs-comment">//判空</span><br>    <span class="hljs-keyword">if</span> (transferer.transfer(e, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">//直接使用transfer方法进行数据传递</span><br>        Thread.interrupted();    <span class="hljs-comment">//为空表示要么被中断要么超时</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有两个实现（公平和非公平模式），这里我们来看公平模式下的SynchronousQueue是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Transferer</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>     <span class="hljs-comment">//头结点（头结点仅作为头结点，后续节点才是真正等待的线程节点）</span><br>     <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> QNode head;<br>     <span class="hljs-comment">//尾结点</span><br>     <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> QNode tail;<br><br>    <span class="hljs-comment">/** 节点有生产者和消费者角色之分 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QNode</span> </span>&#123;<br>        <span class="hljs-keyword">volatile</span> QNode next;          <span class="hljs-comment">// 后继节点</span><br>        <span class="hljs-keyword">volatile</span> Object item;         <span class="hljs-comment">// 存储的元素</span><br>        <span class="hljs-keyword">volatile</span> Thread waiter;       <span class="hljs-comment">// 处于等待的线程，和之前的AQS一样的思路，每个线程等待的时候都会被封装为节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isData;         <span class="hljs-comment">// 是生产者节点还是消费者节点</span><br></code></pre></td></tr></table></figure><p>公平模式下，Transferer的实现是TransferQueue，是以先进先出的规则的进行的，内部有一个QNode类来保存等待的线程。</p><p>好了，我们直接上<code>transfer()</code>方法的实现（这里再次提醒各位，多线程环境下的源码分析和单线程的分析不同，我们需要时刻关注当前代码块的加锁状态，如果没有加锁，一定要具有多线程可能会同时运行的意识，这个意识在以后你自己处理多线程问题伴随着你，才能保证你的思路在多线程环境下是正确的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">E <span class="hljs-title">transfer</span><span class="hljs-params">(E e, <span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span> </span>&#123;   <span class="hljs-comment">//注意这里面没加锁，肯定会多个线程之间竞争</span><br>    QNode s = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> isData = (e != <span class="hljs-keyword">null</span>);   <span class="hljs-comment">//e为空表示消费者，不为空表示生产者</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        QNode t = tail;<br>        QNode h = head;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span> || h == <span class="hljs-keyword">null</span>)         <span class="hljs-comment">// 头结点尾结点任意为空（但是在构造的时候就已经不是空了）</span><br>            <span class="hljs-keyword">continue</span>;                       <span class="hljs-comment">// 自旋</span><br><br>        <span class="hljs-keyword">if</span> (h == t || t.isData == isData) &#123; <span class="hljs-comment">// 头结点等于尾结点表示队列中只有一个头结点，肯定是空，或者尾结点角色和当前节点一样，这两种情况下，都需要进行入队操作</span><br>            QNode tn = t.next;<br>            <span class="hljs-keyword">if</span> (t != tail)                  <span class="hljs-comment">// 如果这段时间内t被其他线程修改了，如果是就进下一轮循环重新来</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (tn != <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-comment">// 继续校验是否为队尾，如果tn不为null，那肯定是其他线程改了队尾，可以进下一轮循环重新来了</span><br>                advanceTail(t, tn);<span class="hljs-comment">// CAS将新的队尾节点设置为tn，成不成功都无所谓，反正这一轮肯定没戏了</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0</span>)        <span class="hljs-comment">// 超时返回null</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)<br>                s = <span class="hljs-keyword">new</span> QNode(e, isData);   <span class="hljs-comment">//构造当前结点，准备加入等待队列</span><br>            <span class="hljs-keyword">if</span> (!t.casNext(<span class="hljs-keyword">null</span>, s))        <span class="hljs-comment">// CAS添加当前节点为尾结点的下一个，如果失败肯定其他线程又抢先做了，直接进下一轮循环重新来</span><br>                <span class="hljs-keyword">continue</span>;<br><br>            advanceTail(t, s);              <span class="hljs-comment">// 上面的操作基本OK了，那么新的队尾元素就修改为s</span><br>            Object x = awaitFulfill(s, e, timed, nanos);   <span class="hljs-comment">//开始等待s所对应的消费者或是生产者进行交接，比如s现在是生产者，那么它就需要等到一个消费者的到来才会继续（这个方法会先进行自旋等待匹配，如果自旋一定次数后还是没有匹配成功，那么就挂起）</span><br>            <span class="hljs-keyword">if</span> (x == s) &#123;                   <span class="hljs-comment">// 如果返回s本身说明等待状态下被取消</span><br>                clean(t, s);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!s.isOffList()) &#123;           <span class="hljs-comment">// 如果s操作完成之后没有离开队列，那么这里将其手动丢弃</span><br>                advanceHead(t, s);          <span class="hljs-comment">// 将s设定为新的首节点(注意头节点仅作为头结点，并非处于等待的线程节点)</span><br>                <span class="hljs-keyword">if</span> (x != <span class="hljs-keyword">null</span>)              <span class="hljs-comment">// 删除s内的其他信息</span><br>                    s.item = s;<br>                s.waiter = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-keyword">null</span>) ? (E)x : e;   <span class="hljs-comment">//假如当前是消费者，直接返回x即可，x就是从生产者那里拿来的元素</span><br><br>        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-comment">// 这种情况下就是与队列中结点类型匹配的情况了（注意队列要么为空要么只会存在一种类型的节点，因为一旦出现不同类型的节点马上会被交接掉）</span><br>            QNode m = h.next;               <span class="hljs-comment">// 获取头结点的下一个接口，准备进行交接工作</span><br>            <span class="hljs-keyword">if</span> (t != tail || m == <span class="hljs-keyword">null</span> || h != head)<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// 判断其他线程是否先修改，如果修改过那么开下一轮</span><br><br>            Object x = m.item;<br>            <span class="hljs-keyword">if</span> (isData == (x != <span class="hljs-keyword">null</span>) ||    <span class="hljs-comment">// 判断节点类型，如果是相同的操作，那肯定也是有问题的</span><br>                x == m ||                   <span class="hljs-comment">// 或是当前操作被取消</span><br>                !m.casItem(x, e)) &#123;         <span class="hljs-comment">// 上面都不是？那么最后再进行CAS替换m中的元素，成功表示交接成功，失败就老老实实重开吧</span><br>                advanceHead(h, m);          <span class="hljs-comment">// dequeue and retry</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            advanceHead(h, m);              <span class="hljs-comment">// 成功交接，新的头结点可以改为m了，原有的头结点直接不要了</span><br>            LockSupport.unpark(m.waiter);   <span class="hljs-comment">// m中的等待交接的线程可以继续了，已经交接完成</span><br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-keyword">null</span>) ? (E)x : e;  <span class="hljs-comment">// 同上，该返回什么就返回什么</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，总结为以下流程：</p><p><img src="/2022/07/28/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/image-15.png" alt></p><p>对于非公平模式下的SynchronousQueue，则是采用的栈结构来存储等待节点，但是思路也是与这里的一致，需要等待并进行匹配操作，各位如果感兴趣可以继续了解一下非公平模式下的SynchronousQueue实现。</p><p>在JDK7的时候，基于SynchronousQueue产生了一个更强大的TransferQueue，它保留了SynchronousQueue的匹配交接机制，并且与等待队列进行融合。</p><p>我们知道，SynchronousQueue并没有使用锁，而是采用CAS操作保证生产者与消费者的协调，但是它没有容量，而LinkedBlockingQueue虽然是有容量且无界的，但是内部基本都是基于锁实现的，性能并不是很好，这时，我们就可以将它们各自的优点单独拿出来，揉在一起，就成了性能更高的LinkedTransferQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    LinkedTransferQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedTransferQueue&lt;&gt;();<br>    queue.put(<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-comment">//插入时，会先检查是否有其他线程等待获取，如果是，直接进行交接，否则插入到存储队列中</span><br>   queue.put(<span class="hljs-string">&quot;2&quot;</span>);  <span class="hljs-comment">//不会像SynchronousQueue那样必须等一个匹配的才可以</span><br>    queue.forEach(System.out::println);   <span class="hljs-comment">//直接打印所有的元素，这在SynchronousQueue下只能是空，因为单独的入队或出队操作都会被阻塞</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，<code>LinkedTransferQueue</code>其实就是一个多了存储队列的<code>SynchronousQueue</code> 我们依然可以像阻塞队列那样获取队列中所有元素的值。</p><p>接着我们来了解一些其他的队列：</p><ul><li><p>PriorityBlockingQueue - 是一个支持优先级的阻塞队列，元素的获取顺序按优先级决定。</p></li><li><p>DelayQueue - 它能够实现延迟获取元素，同样支持优先级。</p></li></ul><p>我们先来看<code>PriorityBlockingQueue</code>优先级阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    PriorityBlockingQueue&lt;Integer&gt; queue =<br>            <span class="hljs-keyword">new</span> PriorityBlockingQueue&lt;&gt;(<span class="hljs-number">10</span>, Integer::compare);   <span class="hljs-comment">//可以指定初始容量（可扩容）和优先级比较规则，这里我们使用升序</span><br>    queue.add(<span class="hljs-number">3</span>);<br>    queue.add(<span class="hljs-number">1</span>);<br>    queue.add(<span class="hljs-number">2</span>);<br>    System.out.println(queue);    <span class="hljs-comment">//注意保存顺序并不会按照优先级排列，所以可以看到结果并不是排序后的结果</span><br>    System.out.println(queue.poll());   <span class="hljs-comment">//但是出队顺序一定是按照优先级进行的</span><br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的重点是<code>DelayQueue</code>它能实现延时出队，也就是说当一个元素插入后，如果没有超过一定时间，那么是无法让此元素出队的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueue</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Delayed</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br></code></pre></td></tr></table></figure><p>可以看到此类只接受Delayed的实现类作为元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Delayed</span>&gt; </span>&#123;  <span class="hljs-comment">//注意这里继承了Comparable，它支持优先级</span><br><br>    <span class="hljs-comment">//获取剩余等待时间，正数表示还需要进行等待，0或负数表示等待结束</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getDelay</span><span class="hljs-params">(TimeUnit unit)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们手动实现一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Delayed</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> time;   <span class="hljs-comment">//延迟时间，这里以毫秒为单位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> priority;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> startTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, <span class="hljs-keyword">int</span> priority, String data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.time = TimeUnit.SECONDS.toMillis(time);   <span class="hljs-comment">//秒转换为毫秒</span><br>        <span class="hljs-keyword">this</span>.priority = priority;<br>        <span class="hljs-keyword">this</span>.startTime = System.currentTimeMillis();   <span class="hljs-comment">//这里我们以毫秒为单位</span><br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> leftTime = time - (System.currentTimeMillis() - startTime); <span class="hljs-comment">//计算剩余时间 = 设定时间 - 已度过时间(= 当前时间 - 开始时间)</span><br>        <span class="hljs-keyword">return</span> unit.convert(leftTime, TimeUnit.MILLISECONDS);   <span class="hljs-comment">//注意进行单位转换，单位由队列指定（默认是纳秒单位）</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Delayed o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Test)<br>            <span class="hljs-keyword">return</span> priority - ((Test) o).priority;   <span class="hljs-comment">//优先级越小越优先</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在主方法中尝试使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    DelayQueue&lt;Test&gt; queue = <span class="hljs-keyword">new</span> DelayQueue&lt;&gt;();<br>    queue.add(<span class="hljs-keyword">new</span> Test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;2号&quot;</span>));   <span class="hljs-comment">//1秒钟延时</span><br>    queue.add(<span class="hljs-keyword">new</span> Test(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;1号&quot;</span>));   <span class="hljs-comment">//1秒钟延时，优先级最高</span><br><br>    System.out.println(queue.take());    <span class="hljs-comment">//注意出队顺序是依照优先级来的，即使一个元素已经可以出队了，依然需要等待优先级更高的元素到期</span><br>    System.out.println(queue.take());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来研究一下DelayQueue是如何实现的，首先来看<code>add()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> offer(e);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        q.offer(e);   <span class="hljs-comment">//注意这里是向内部维护的一个优先级队列添加元素，并不是DelayQueue本身存储元素</span><br>        <span class="hljs-keyword">if</span> (q.peek() == e) &#123;   <span class="hljs-comment">//如果入队后队首就是当前元素，那么直接进行一次唤醒操作（因为有可能之前就有其他线程等着take了）</span><br>            leader = <span class="hljs-keyword">null</span>;<br>            available.signal();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    offer(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到无论是哪种入队操作，都会加锁进行，属于常规操作。我们接着来看<code>take()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;   <span class="hljs-comment">//出队也要先加锁，基操</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">//无限循环，常规操作</span><br>            E first = q.peek();    <span class="hljs-comment">//获取队首元素</span><br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)     <span class="hljs-comment">//如果为空那肯定队列为空，先等着吧，等有元素进来</span><br>                available.await();<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">long</span> delay = first.getDelay(NANOSECONDS);    <span class="hljs-comment">//获取延迟，这里传入的时间单位是纳秒</span><br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> q.poll();     <span class="hljs-comment">//如果获取到延迟时间已经小于0了，那说明ok，可以直接出队返回</span><br>                first = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//这里用leader来减少不必要的等待时间，如果不是null那说明有线程在等待，为null说明没有线程等待</span><br>                    available.await();   <span class="hljs-comment">//如果其他线程已经在等元素了，那么当前线程直接进永久等待状态</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    Thread thisThread = Thread.currentThread();<br>                    leader = thisThread;    <span class="hljs-comment">//没有线程等待就将leader设定为当前线程</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        available.awaitNanos(delay);     <span class="hljs-comment">//获取到的延迟大于0，那么就需要等待延迟时间，再开始下一次获取</span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-keyword">null</span> &amp;&amp; q.peek() != <span class="hljs-keyword">null</span>)<br>            available.signal();   <span class="hljs-comment">//当前take结束之后唤醒一个其他永久等待状态下的线程</span><br>        lock.unlock();   <span class="hljs-comment">//解锁，完事</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，有关并发容器的讲解就到这里。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JUC笔记（一）并发编程基础</title>
    <link href="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><h2 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h2><p>有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全的情况，也就不存在临界区的问题。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>多个任务在同一个CPU核上，按细分的时间片段轮流（交替）执行，从逻辑上来看那些任务是“同时进行”。</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-1.png" alt></p><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>我们知道，使用<code>synchronized</code>，一定是和某个对象相关联的，比如我们要对某一段代码加锁，那么我们就需要提供一个对象来作为锁本身：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (Main.class) &#123;<br>        <span class="hljs-comment">//这里使用的是Main类的Class对象作为锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看，它变成字节码之后会用到哪些指令：</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-2.png" alt></p><p>其中最关键的就是<code>monitorenter</code>指令了，可以看到之后也有<code>monitorexit</code>与之进行匹配（注意这里有2个），<code>monitorenter</code>和<code>monitorexit</code>分别对应加锁和释放锁，在执行<code>monitorenter</code>之前需要尝试获取锁，每个对象都有一个<code>monitor</code>监视器与之对应，而这里正是去获取对象监视器的所有权，一旦<code>monitor</code>所有权被某个线程持有，那么其他线程将无法获得（管程模型的一种实现）。</p><p>在代码执行完成之后，我们可以看到，一共有两个<code>monitorexit</code>在等着我们，那么为什么这里会有两个呢，按理说<code>monitorenter</code>和<code>monitorexit</code>不应该一一对应吗，这里为什么要释放锁两次呢？</p><p>首先我们来看第一个，这里在释放锁之后，会马上进入到一个goto指令，跳转到15行，而我们的15行对应的指令就是方法的返回指令，其实正常情况下只会执行第一个<code>monitorexit</code>释放锁，在释放锁之后就接着同步代码块后面的内容继续向下执行了。而第二个，其实是用来处理异常的，可以看到，它的位置是在12行，如果程序运行发生异常，那么就会执行第二个<code>monitorexit</code>，并且会继续向下通过<code>athrow</code>指令抛出异常，而不是直接跳转到15行正常运行下去。</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-3.png" alt></p><p>实际上<code>synchronized</code>使用的锁就是存储在Java对象头中的，我们知道，对象是存放在堆内存中的，而每个对象内部，都有一部分空间用于存储对象头信息，而对象头信息中，则包含了Mark Word用于存放<code>hashCode</code>和对象的锁信息，在不同状态下，它存储的数据结构有一些不同。</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-4.png" alt></p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>在JDK6之前，<code>synchronized</code>一直被称为重量级锁，<code>monitor</code>依赖于底层操作系统的Lock实现，Java的线程是映射到操作系统的原生线程上，切换成本较高。而在JDK6之后，锁的实现得到了改进。</p><p>我们先从最原始的重量级锁开始，我们说了，每个对象都有一个monitor与之关联，在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ObjectMonitor() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录个数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;<br>    _object       = <span class="hljs-literal">NULL</span>;<br>    _owner        = <span class="hljs-literal">NULL</span>;<br>    _WaitSet      = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = <span class="hljs-literal">NULL</span> ;<br>    _succ         = <span class="hljs-literal">NULL</span> ;<br>    _cxq          = <span class="hljs-literal">NULL</span> ;<br>    FreeNext      = <span class="hljs-literal">NULL</span> ;<br>    _EntryList    = <span class="hljs-literal">NULL</span> ; <span class="hljs-comment">//处于等待锁block状态的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个等待锁的线程都会被封装成ObjectWaiter对象，进入到如下的重量级锁机制：</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-5.png" alt></p><p>ObjectWaiter首先会进入 Entry Set等着，当线程获取到对象的<code>monitor</code>后进入 The Owner 区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>count</code>加1，若线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p><p>虽然这样的设计思路非常合理，但是在大多数应用上，每一个线程占用同步代码块的时间并不是很长，我们完全没有必要将竞争中的线程挂起然后又唤醒，并且现代CPU基本都是多核心运行的，我们可以采用一种新的思路来实现锁。</p><p>在JDK1.4.2时，引入了自旋锁（JDK6之后默认开启），它不会将处于等待状态的线程挂起，而是通过循环的方式，不断检测是否能够获取锁，由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行，这就是自旋锁。当然，仅仅是在等待时间非常短的情况下，自旋锁的表现会很好，但是如果等待时间太长，由于循环是需要处理器继续运算的，所以这样只会浪费处理器资源，因此自旋锁的等待时间是有限制的，默认情况下为10次，如果失败，那么会采用重量级锁机制。</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-6.png" alt></p><p>在JDK6之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么这次自旋也是有可能成功的，所以会允许自旋更多次。当然，如果某个锁经常都自旋失败，那么有可能将不再采用自旋策略，而是直接使用重量级锁。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><blockquote><p>从JDK 1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁。</p></blockquote><p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗（并不是为了代替重量级锁，实际上就是赌同一时间只有一个线程在占用资源），包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。它不像是重量级锁那样，需要向操作系统申请互斥量。它的运作机制如下：</p><p>在即将开始执行同步代码块中的内容时，会首先检查对象的Mark Word，查看锁对象是否被其他线程占用，如果没有任何线程占用，那么会在当前线程所处的栈帧中建立一个名为锁记录（Lock Record）的空间，用于复制并存储对象目前的Mark Word信息（官方称为Displaced Mark Word）。</p><p>接着，虚拟机将使用CAS操作将对象的Mark Word更新为轻量级锁状态（数据结构变为指向Lock Record的指针，指向的是当前的栈帧）</p><blockquote><p>CAS（Compare And Swap）是一种无锁算法，它并不会为对象加锁，而是在执行的时候，看看当前数据的值是不是我们预期的那样，如果是，那就正常进行替换，如果不是，那么就替换失败。比如有两个线程都需要修改变量<code>i</code>的值，默认为10，现在一个线程要将其修改为20，另一个要修改为30，如果他们都使用CAS算法，那么并不会加锁访问<code>i</code>，而是直接尝试修改<code>i</code>的值，但是在修改时，需要确认<code>i</code>是不是10，如果是，表示其他线程还没对其进行修改，如果不是，那么说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p><p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p></blockquote><p>如果CAS操作失败了的话，那么说明可能这时有线程已经进入这个同步代码块了，这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那说明的确是被其他线程占用了，这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-7.png" alt></p><p>解锁过程同样采用CAS算法，如果对象的MarkWord仍然指向线程的锁记录，那么就用CAS操作把对象的MarkWord复制到栈帧中的Displaced Mark Word进行交换。如果替换失败，说明其他线程尝试过获取该锁，在释放锁的同时，需要唤醒被挂起的线程。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁相比轻量级锁更纯粹，干脆就把整个同步都消除掉，不需要再进行CAS操作了。它的出现主要是得益于人们发现某些情况下某个锁频繁地被同一个线程获取，这种情况下，我们可以对轻量级锁进一步优化。</p><p>偏向锁实际上就是专门为单个线程而生的，当某个线程第一次获得锁时，如果接下来都没有其他线程获取此锁，那么持有锁的线程将不再需要进行同步操作。</p><p>可以从之前的MarkWord结构中看到，偏向锁也会通过CAS操作记录线程的ID，如果一直都是同一个线程获取此锁，那么完全没有必要在进行额外的CAS操作。当然，如果有其他线程来抢了，那么偏向锁会根据当前状态，决定是否要恢复到未锁定或是膨胀为轻量级锁。</p><p>如果我们需要使用偏向锁，可以添加<code>-XX:+UseBiased</code>参数来开启。</p><p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态，因为Hash是需要被保存的，而偏向锁的Mark Word数据结构，无法保存Hash值；如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁，并将哈希值存放在<code>monitor</code>（有预留位置保存）中。</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-8.png" alt></p><h2 id="锁消除、锁优化"><a href="#锁消除、锁优化" class="headerlink" title="锁消除、锁优化"></a>锁消除、锁优化</h2><p>锁消除和锁粗化都是在运行时的一些优化方案</p><p><strong>锁消除：</strong>比如我们某段代码虽然加了锁，但是在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下，完全不需要任何加锁机制，所以锁会被消除。</p><p><strong>锁粗化：</strong>是我们代码中频繁地出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，所以虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p><h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>注意这里提到的内存模型和我们在JVM中介绍的内存模型不在同一个层次，JVM中的内存模型是虚拟机规范对整个内存区域的规划，而Java内存模型，是在JVM内存模型之上的抽象模型，具体实现依然是基于JVM内存模型实现的。</p><h2 id="Javav内存模型"><a href="#Javav内存模型" class="headerlink" title="Javav内存模型"></a>Javav内存模型</h2><p>我们在<code>计算机组成原理</code>中学习过，在我们的CPU中，一般都会有高速缓存，而它的出现，是为了解决内存的速度跟不上处理器的处理速度的问题，所以CPU内部会添加一级或多级高速缓存来提高处理器的数据获取效率，但是这样也会导致一个很明显的问题，因为现在基本都是多核心处理器，每个处理器都有一个自己的高速缓存，那么又该怎么去保证每个处理器的高速缓存内容一致呢？</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-9.png" alt></p><p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p><p>而Java也采用了类似的模型来实现支持多线程的内存模型：</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-10.png" alt></p><p>JMM（Java Memory Model）内存模型规定如下：</p><ul><li>变量全部存储在主内存（注意这里包括下面提到的变量，指的都是<strong>会出现竞争的变量，包括成员变量、静态变量</strong>等，而<strong>对于局部变量这种属于线程私有的变量，不包括在内</strong>）</li><li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li><li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li></ul><p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作，操作完成之后，也需要从工作副本中将结果拷贝回主内存中，具体的操作就是<code>Save</code>（保存）和<code>Load</code>（加载）操作。</p><p>那么各位肯定会好奇，这个内存模型，结合之前JVM所讲的内容，具体是怎么实现的呢？</p><ul><li>主内存：对应堆中存放对象实例的部分</li><li>工作内存：对应线程的虚拟机栈的部分区域，虚拟机可能会对这部分内存进行优化，将其放在CPU的寄存器或是高速缓存中。比如在访问数组时，由于数组是一段连续的内存空间，所以可以将一部分连续空间放入到CPU高速缓存中，那么之后如果我们顺序读取这个数组，那么大概率是直接缓存命中</li></ul><p>前面我们提到，在CPU中可能会遇到缓存不一致的问题，而在 Java 中同样也会遇到缓存不一致的问题，比如下面这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) i++;<br>            System.out.println(<span class="hljs-string">&quot;线程1结束&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) i++;<br>            System.out.println(<span class="hljs-string">&quot;线程2结束&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-comment">//等上面两个线程结束</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">线程<span class="hljs-number">2</span>结束<br>线程<span class="hljs-number">1</span>结束<br><span class="hljs-number">120018</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到这里是两个线程同时对变量<code>i</code>各自进行100000次自增操作，但是实际得到的结果并不是我们所期望的那样。</p><p><strong>那么为什么会这样呢？在之前学习了JVM之后，相信各位应该已经知道，自增操作实际上并不是由一条指令完成的（注意一定不要理解为一行代码就是一个指令完成的）：</strong></p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-11.png" alt></p><p>包括变量<code>i</code>的获取、修改、保存，都是被拆分为一个一个的操作完成的，那么这个时候就有可能出现在修改完后保存之前，另一条线程也保存了，但是当前线程是毫不知情的。</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-12.png" alt></p><p>所以说，我们当时在JavaSE阶段讲解这个问题的时候，是通过<code>synchronized</code>关键字添加同步代码块解决的，当然，我们后面还会讲解另外的解决方案（原子类）</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>在编译或执行时，为了优化程序的执行效率，编译器或处理器常常会对指令进行重排序，有以下情况：</p><ul><li>编译器重排序：Java编译器通过对Java代码语义的理解，根据优化规则对代码指令进行重排序</li><li>机器指令级别的重排序：现代处理器很高级，能够自主判断和变更机器指令的执行顺序</li></ul><p>指令重排序能够在不改变结果（单线程）的情况下，优化程序的运行效率，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    System.out.println(a + b);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们其实可以交换赋值语句的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;<br>    System.out.println(a + b);<br>&#125;<br></code></pre></td></tr></table></figure><p>即使发生交换，但是我们程序最后的运行结果是不会变的，当然这里只通过代码的形式演示，实际上JVM在执行字节码指令时也会进行优化，可能两个指令并不会按照原有的顺序进行。</p><p>虽然单线程下指令重排确实可以起到一定程度的优化作用，但是在多线程下，似乎会导致一些问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>                &#125;   <br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            a = <span class="hljs-number">1</span>;<br>            b = <span class="hljs-number">1</span>;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码，在正常情况下，按照我们的正常思维，是不可能输出<code>A</code>的，因为只要b等于1，那么a肯定也是1才对，因为a是在b之前完成的赋值。但是，如果进行了重排序，那么就有可能，a和b的赋值顺序发生交换，b先被赋值为1，而恰巧这个时候，线程1开始判定b是不是1了，这时a还没来得及被赋值为1，可能线程1就已经走到打印输出<code>B</code>那里去了，所以，是有可能输出<code>A</code>的。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p><strong>并发编程的三个重要特性</strong></p><ol><li><strong>原子性</strong> : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><p>我们之前说了，如果多线程访问同一个变量，那么这个变量会被线程拷贝到自己的工作内存中进行操作，而不是直接对主内存中的变量本体进行操作，下面这个操作看起来是一个有限循环，但是是无限的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (a == <span class="hljs-number">0</span>);<br>            System.out.println(<span class="hljs-string">&quot;线程结束！&quot;</span>);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;正在修改a的值...&quot;</span>);<br>        a = <span class="hljs-number">1</span>;   <span class="hljs-comment">//很明显，按照我们的逻辑来说，a的值被修改那么另一个线程将不再循环</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现程序一直在运行并未结束。实际上这就是我们之前说的，虽然我们主线程中修改了a的值，但是另一个线程并不知道a的值发生了改变，所以循环中依然是使用旧值在进行判断，因此，普通变量是不具有可见性的。</p><p>要解决这种问题，我们第一个想到的肯定是加锁，同一时间只能有一个线程使用，这样总行了吧，确实，这样的话肯定是可以解决问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (a == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (Main.class)&#123;&#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;线程结束！&quot;</span>);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;正在修改a的值...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (Main.class)&#123;<br>            a = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，除了硬加一把锁的方案，我们也可以使用<code>volatile</code>关键字来解决，此关键字的第一个作用，就是保证变量的可见性。当写一个<code>volatile</code>变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，并且这个写操作会导致其他线程中的<code>volatile</code>变量缓存无效，这样，另一个线程修改了这个变量时，当前线程会立即得知，并将工作内存中的变量更新为最新的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-comment">//添加volatile关键字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (a == <span class="hljs-number">0</span>);<br>            System.out.println(<span class="hljs-string">&quot;线程结束！&quot;</span>);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;正在修改a的值...&quot;</span>);<br>        a = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果还真的如我们所说的那样，使用 <code>volatile</code> 关键字后，当a发生改变时，循环立即结束。</p><p>当然，虽然说<code>volatile</code>能够保证可见性，但是不能保证原子性，要解决我们上面的<code>i++</code>的问题，以我们目前所学的知识，还是只能使用加锁来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Runnable r = () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) a++;<br>            System.out.println(<span class="hljs-string">&quot;任务完成！&quot;</span>);<br>        &#125;;<br>        <span class="hljs-keyword">new</span> Thread(r).start();<br>        <span class="hljs-keyword">new</span> Thread(r).start();<br><br>        <span class="hljs-comment">//等待线程执行完成</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不对啊，<code>volatile</code>不是能在改变变量的时候其他线程可见吗，那为什么还是不能保证原子性呢？还是那句话，自增操作是被瓜分为了多个步骤完成的，虽然保证了可见性，但是只要手速够快，依然会出现两个线程同时写同一个值的问题（比如线程1刚刚将a的值更新为100，这时线程2可能也已经执行到更新a的值这条指令了，已经刹不住车了，所以依然会将a的值再更新为一次100）</p><p>那要是真的遇到这种情况，那么我们不可能都去写个锁吧？后面，我们会介绍原子类来专门解决这种问题。</p><p>最后一个功能就是<code>volatile</code>会禁止指令重排，也就是说，如果我们操作的是一个<code>volatile</code>变量，它将不会出现重排序的情况。那么它是怎么解决的重排序问题呢？若用volatile修饰共享变量，在编译时，会在指令序列中插入<code>内存屏障</code>来禁止特定类型的处理器重排序</p><blockquote><p>内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ol><li><p>保证特定操作的顺序</p></li><li><p>保证某些变量的内存可见性（volatile的内存可见性，其实就是依靠这个实现的）</p></li></ol><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序。</p><p><img src="/2022/07/27/JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/image-13.png" alt></p></blockquote><div class="table-container"><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在Store2及其后的写操作执行前，保证Load1的读操作已读取结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证load1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td></tr></tbody></table></div><p>所以<code>volatile</code>能够保证，之前的指令一定全部执行，之后的指令一定都没有执行，并且前面语句的结果对后面的语句可见。</p><p>最后我们来总结一下<code>volatile</code>关键字的三个特性：</p><ul><li><p>保证可见性</p></li><li><p>不保证原子性</p></li><li><p>防止指令重排</p></li></ul><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p>经过我们前面的讲解，相信各位已经了解了JMM内存模型以及重排序等机制带来的优点和缺点，综上，JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，来向各位程序员做一些保证，只要我们是按照原则进行编程，那么就能够保持并发编程的正确性。具体如下：</p><ul><li><strong>程序次序规则：</strong>同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。<ul><li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求。</li></ul></li><li><strong>监视器锁规则：</strong>对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。<ul><li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li></ul></li><li><strong>volatile变量规则：</strong>对一个volatile变量的写操作happens-before后续对这个变量的读操作。<ul><li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li></ul></li><li><strong>线程启动规则：</strong>主线程A启动线程B，线程B中可以看到主线程在启动B之前的操作。<ul><li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li></ul></li><li><strong>线程加入规则：</strong>如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回。</li><li><strong>传递性规则：</strong>如果A happens-before B，B happens-before C，那么A happens-before C。</li></ul><p>那么我们来从happens-before原则的角度，来解释一下下面的程序结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        a = <span class="hljs-number">10</span>;<br>        b = a + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>          <span class="hljs-keyword">if</span>(b &gt; <span class="hljs-number">10</span>) System.out.println(a); <br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们定义以上出现的操作：</p><ul><li><strong>A：</strong>将变量<code>a</code>的值修改为<code>10</code></li><li><strong>B：</strong>将变量<code>b</code>的值修改为<code>a + 1</code></li><li><strong>C：</strong>主线程启动了一个新的线程，并在新的线程中获取<code>b</code>，进行判断，如果为<code>true</code>那么就打印<code>a</code></li></ul><p>首先我们来分析，由于是同一个线程，并且<strong>B</strong>是一个赋值操作且读取了<strong>A</strong>，那么按照<strong>程序次序规则</strong>，A happens-before B，接着在B之后，马上执行了C，按照<strong>线程启动规则</strong>，在新的线程启动之前，当前线程之前的所有操作对新的线程是可见的，所以 B happens-before C，最后根据<strong>传递性规则</strong>，由于A happens-before B，B happens-before C，所以A happens-before C，因此在新的线程中会输出<code>a</code>修改后的结果<code>10</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JDK 监控和故障处理工具</title>
    <link href="/2022/07/26/JDK-%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/07/26/JDK-%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类文件结构与类加载机制</title>
    <link href="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、类文件结构"><a href="#一、类文件结构" class="headerlink" title="一、类文件结构"></a>一、类文件结构</h1><h2 id="类文件信息"><a href="#类文件信息" class="headerlink" title="类文件信息"></a>类文件信息</h2><p>下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。<code>.class</code>文件的二进制格式可以使用 WinHex 工具查看</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-1.png" alt></p><p>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java">ClassFile &#123;<br>    u4             magic; <span class="hljs-comment">//Class 文件的标志</span><br>    u2             minor_version;<span class="hljs-comment">//Class 的次版本号</span><br>    u2             major_version;<span class="hljs-comment">//Class 的主版本号</span><br>    u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span><br>    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<span class="hljs-comment">//常量池</span><br>    u2             access_flags;<span class="hljs-comment">//Class 的访问标记</span><br>    u2             this_class;<span class="hljs-comment">//当前类</span><br>    u2             super_class;<span class="hljs-comment">//父类</span><br>    u2             interfaces_count;<span class="hljs-comment">//接口</span><br>    u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br>    u2             fields_count;<span class="hljs-comment">//Class 文件的字段属性</span><br>    field_info     fields[fields_count];<span class="hljs-comment">//一个类可以有多个字段</span><br>    u2             methods_count;<span class="hljs-comment">//Class 文件的方法数量</span><br>    method_info    methods[methods_count];<span class="hljs-comment">//一个类可以有个多个方法</span><br>    u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>    attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过分析 <code>ClassFile</code> 的内容，我们便可以知道 class 文件的组成。</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-2.png" alt></p><p>可以通过 IDEA 插件 <code>jclasslib</code> 来更直观的查看 Class 文件结构。</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-3.png" alt></p><p>使用 <code>jclasslib</code> 不光可以查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</p><p>下面介绍一下Class 文件结构涉及到的一些组件。</p><h3 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u4             magic; <span class="hljs-comment">//Class 文件的标志</span><br></code></pre></td></tr></table></figure><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong></p><p>每一个Java Class文件都是以0x CAFEBABE开头的。Java这么做的原因就是为了快速判断一个文件是不是有可能为class文件，以及这个class文件有没有受损（文件受损，文件开头受损的可能性最大）。</p><h3 id="Class-文件版本号（Minor-amp-Major-Version）"><a href="#Class-文件版本号（Minor-amp-Major-Version）" class="headerlink" title="Class 文件版本号（Minor&amp;Major Version）"></a>Class 文件版本号（Minor&amp;Major Version）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             minor_version;<span class="hljs-comment">//Class 的次版本号</span><br>u2             major_version;<span class="hljs-comment">//Class 的主版本号</span><br></code></pre></td></tr></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是<strong>次版本号</strong>，第 7 和第 8 位是<strong>主版本号</strong>。</p><p>每当 Java 发布大版本（比如 JDK8，JDK9）的时候，主版本号都会加 1。你可以使用 <code>javap -v</code> 命令来快速查看 Class 文件的版本号信息。其中<code>52</code>代表的是<code>JDK8</code>编译的字节码文件</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span><br>cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<span class="hljs-comment">//常量池</span><br></code></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。</p><ul><li><p>字面量比较接近于 Java 语言层面的的常量概念</p><ul><li>如文本字符串</li><li>声明为 final 的常量值等。</li></ul></li><li><p>符号引用则属于编译原理方面的概念</p><ul><li><p>类和接口的全限定名</p></li><li><p>字段的名称和描述符</p></li><li><p>方法的名称和描述符</p></li></ul></li></ul><p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">标志（tag）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CONSTANT_utf8_info</td><td style="text-align:center">1</td><td style="text-align:center">UTF-8 编码的字符串</td></tr><tr><td style="text-align:center">CONSTANT_Integer_info</td><td style="text-align:center">3</td><td style="text-align:center">整形字面量</td></tr><tr><td style="text-align:center">CONSTANT_Float_info</td><td style="text-align:center">4</td><td style="text-align:center">浮点型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Long_info</td><td style="text-align:center">５</td><td style="text-align:center">长整型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Double_info</td><td style="text-align:center">６</td><td style="text-align:center">双精度浮点型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Class_info</td><td style="text-align:center">７</td><td style="text-align:center">类或接口的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_String_info</td><td style="text-align:center">８</td><td style="text-align:center">字符串类型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Fieldref_info</td><td style="text-align:center">９</td><td style="text-align:center">字段的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_Methodref_info</td><td style="text-align:center">10</td><td style="text-align:center">类中方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_InterfaceMethodref_info</td><td style="text-align:center">11</td><td style="text-align:center">接口中方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_NameAndType_info</td><td style="text-align:center">12</td><td style="text-align:center">字段或方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_MothodType_info</td><td style="text-align:center">16</td><td style="text-align:center">标志方法类型</td></tr><tr><td style="text-align:center">CONSTANT_MethodHandle_info</td><td style="text-align:center">15</td><td style="text-align:center">表示方法句柄</td></tr><tr><td style="text-align:center">CONSTANT_InvokeDynamic_info</td><td style="text-align:center">18</td><td style="text-align:center">表示一个动态方法调用点</td></tr></tbody></table></div><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p><h3 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             access_flags;<span class="hljs-comment">//Class 的访问标记</span><br></code></pre></td></tr></table></figure><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p><p>类访问和属性修饰符:</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-4.png" alt></p><p>比如我们这里的Main类，它是一个普通的class类型，并且访问权限为public，那么它的访问标志值是这样计算的：</p><p><code>ACC_PUBLIC | ACC_SUPER = 0x0001 | 0x0020 = 0x0021</code>（这里进行的是按位或运算），可以看到和下面的结果是一致的</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-5.png" alt></p><h3 id="当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             this_class;<span class="hljs-comment">//当前类</span><br>u2             super_class;<span class="hljs-comment">//父类</span><br>u2             interfaces_count;<span class="hljs-comment">//接口</span><br>u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br></code></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p><h3 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             fields_count;<span class="hljs-comment">//Class 文件的字段属性</span><br>field_info     fields[fields_count];<span class="hljs-comment">//一个类可以有多个字段</span><br></code></pre></td></tr></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-6.png" alt></p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值:</strong></p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-7.png" alt></p><h3 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             methods_count;<span class="hljs-comment">//Class 文件的方法数量</span><br>method_info    methods[methods_count];<span class="hljs-comment">//一个类可以有个多个方法</span><br></code></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-8.png" alt></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-9.png" alt></p><blockquote><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p></blockquote><h3 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br></code></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p><p>与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>JVM 实际上并不是面向寄存器架构的，而是面向操作数栈，所以大多数指令都是不带参数的。</p><p>以当前的Main类中的main方法进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> a = i++;<br>    <span class="hljs-keyword">int</span> b = ++i;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，main方法中首先是定义了一个int类型的变量 i ，并赋值为10，然后变量a接收<code>i++</code>的值，变量b接收<code>++i</code>的值。</p><p>首先可以查看本地变量表中的信息：</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-10.png" alt></p><p>再查看编译成字节码后的方法信息：</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-11.png" alt></p><ul><li>首先第一句，bipush，将10送至操作数栈顶。</li><li>接下来将操作数栈顶的数值存进1号本地变量，也就是变量 i 中。</li><li>接着将变量 i 中的值又丢向操作数栈顶</li><li>这里使用iinc指令，将1号本地变量的值增加1（结束之后 i 的值就是11了）</li><li>接着将操作数栈顶的值（操作数栈顶的值是10）存入2号本地变量（这下彻底知道 i++ 到底干了啥才会先返回后自增了吧，从原理角度来说，实际上 i 是先自增了的，但由于这里取的是操作数栈中的值，所以说就得到了 i 之前的值)</li><li>接着往下，我们看到 ++i 是先直接将 i 的值自增1</li><li>然后再将其值推向操作数栈顶</li></ul><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-12.png" alt></p><p>而从结果来看，<code>i++</code>操作确实是先返回再自增的，而字节码指令层面来说，却是截然相反的，只是结果一致罢了。</p><h1 id="二、类加载机制"><a href="#二、类加载机制" class="headerlink" title="二、类加载机制"></a>二、类加载机制</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>首先，要加载一个类，一定是出于某种目的的，比如我们要运行我们的Java程序，那么就必须要加载主类才能运行主类中的主方法。</p><p>一般在这些情况下，如果类没有被加载，那么就会被自动加载：</p><p>使用new关键字创建对象时<br>使用某个类的静态成员（包括方法和字段）的时候（<strong>当然，final类型的静态字段有可能在编译的时候被放到了当前类的常量池中，这种情况下是不会触发自动加载的</strong>）<br>使用反射对类信息进行获取的时候（之前的数据库驱动就是这样的）<br>加载一个类的子类时<br>加载接口的实现类，且接口带有default的方法默认实现时</p><p>比如这种情况，那么需要用到另一个类中的成员字段，所以就必须将另一个类加载之后才能访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Test.str);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我被初始化了！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String str = <span class="hljs-string">&quot;lbwnb&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-13.png" alt></p><p>如果将静态成员变量用final来修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Test.str);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我被初始化了！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String str = <span class="hljs-string">&quot;lbwnb&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-14.png" alt></p><p>按照正常逻辑来说，既然要用到其他类中的字段，那么肯定需要加载其他类，但是这里我们结果发现，并没有对Test类进行加载。</p><p>很明显，这里使用的是<code>ldc</code>指令从常量池中将字符串取出并推向操作数栈顶，也就是说，在编译阶段，整个Test.str直接被替换为了对应的字符串（因为final不可能发生改变的，编译就会进行优化，直接来个字符串比你去加载类在获取快得多不是吗，反正结果都一样），所以说编译之后，实际上跟Test类半毛钱关系都没有了。</p><p>通过查看字节码文件也能发现上述结果：</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-15.png" alt></p><p>所以说，当你在某些情况下疑惑为什么类加载了或是没有加载时，可以从字节码指令的角度去进行分析，一般情况下，只要遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这些指令时，都会进行类加载。</p><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-16.png" alt></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段相当于是对加载的类进行一次规范校验（因为一个类并不一定是由我们使用 IDEA 编译出来的，有可能是直接使用ASM框架写），如果说类的任何地方不符合虚拟机规范，那么这个类是不会验证通过的，如果没有验证机制，那么一旦出现危害虚拟机的操作，整个程序会出现无法预料的后果。<br><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-17.png" alt></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111</li></ol><p><strong>基本数据类型的零值</strong></p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-18.png" alt></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><blockquote><p>说明： <code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p></blockquote><p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 <code>new</code> 、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条直接码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li><li>当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java提供了类加载器，以便我们自己可以更好地控制类加载，我们可以自定义类加载器，也可以使用官方自带的类加载器去加载类。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。</p><p>也就是说，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个Class文件，也是不同的，只有两个类来自同一个Class文件并且是由同一个类加载器加载的，才能判断为是同一个。默认情况下，所有的类都是由JDK自带的类加载器进行加载。</p><p>比如，我们先创建一个Test类用于测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们自己实现一个ClassLoader来加载我们的Test类，同时使用官方默认的类加载器来加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>        Class&lt;?&gt; testClass1 = Main.class.getClassLoader().loadClass(<span class="hljs-string">&quot;com.test.Test&quot;</span>);<br>        CustomClassLoader customClassLoader = <span class="hljs-keyword">new</span> CustomClassLoader();<br>        Class&lt;?&gt; testClass2 = customClassLoader.loadClass(<span class="hljs-string">&quot;com.test.Test&quot;</span>);<br><br>       <span class="hljs-comment">//看看两个类的类加载器是不是同一个</span><br>        System.out.println(testClass1.getClassLoader());<br>        System.out.println(testClass2.getClassLoader());<br><br>      <span class="hljs-comment">//看看两个类是不是长得一模一样</span><br>        System.out.println(testClass1);<br>        System.out.println(testClass2);<br><br>      <span class="hljs-comment">//两个类是同一个吗？</span><br>        System.out.println(testClass1 == testClass2);<br>      <br>      <span class="hljs-comment">//能成功实现类型转换吗？</span><br>        Test test = (Test) testClass2.newInstance();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">try</span> (FileInputStream stream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;./target/classes/&quot;</span>+name.replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>)+<span class="hljs-string">&quot;.class&quot;</span>))&#123;<br>                <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[stream.available()];<br>                stream.read(data);<br>                <span class="hljs-keyword">if</span>(data.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.loadClass(name);<br>                <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.loadClass(name);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span>.Launcher<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">18</span>b4aac2<br>com<span class="hljs-selector-class">.test</span>.Main<span class="hljs-variable">$CustomClassLoader</span>@<span class="hljs-number">74</span>a14482<br>class com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><br>class com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><br>false<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassCastException</span>: com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span> cannot be cast to com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Test</span><br>at com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span><span class="hljs-selector-class">.main</span>(Main<span class="hljs-selector-class">.java</span>:<span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure><p>通过结果我们发现，即使两个类是同一个Class文件加载的，只要类加载器不同，那么这两个类就是不同的两个类。</p><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><h3 id="BootstrapClassLoader-启动类加载器"><a href="#BootstrapClassLoader-启动类加载器" class="headerlink" title="BootstrapClassLoader(启动类加载器)"></a>BootstrapClassLoader(启动类加载器)</h3><p>最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p><h3 id="ExtensionClassLoader-扩展类加载器"><a href="#ExtensionClassLoader-扩展类加载器" class="headerlink" title="ExtensionClassLoader(扩展类加载器)"></a>ExtensionClassLoader(扩展类加载器)</h3><p>主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</p><h3 id="AppClassLoader-应用程序类加载器"><a href="#AppClassLoader-应用程序类加载器" class="headerlink" title="AppClassLoader(应用程序类加载器)"></a>AppClassLoader(应用程序类加载器)</h3><p>面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p><p><img src="/2022/07/26/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-19.png" alt></p><p>每个类加载都有一个父类加载器，我们通过下面的程序来验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Main.class.getClassLoader());   <span class="hljs-comment">//查看当前类的类加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent());  <span class="hljs-comment">//父加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent().getParent());  <span class="hljs-comment">//爷爷加载器</span><br>        System.out.println(String.class.getClassLoader());   <span class="hljs-comment">//String类的加载器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">sun.misc.Launcher$AppClassLoader@18b4aac2<br>sun.misc.Launcher$ExtClassLoader@4554617c<br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code>， <code>ExtClassLoader</code>的父类加载器为 null，<strong>null 并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。</p><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。</p><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>            <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过</span><br>            Class&lt;?&gt; c = findLoadedClass(name);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//父加载器不为空，调用父加载器loadClass()方法处理</span><br>                        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span><br>                        c = findBootstrapClassOrNull(name);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                   <span class="hljs-comment">//抛出异常说明父类加载器无法完成加载请求</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                    <span class="hljs-comment">//自己尝试加载</span><br>                    c = findClass(name);<br><br>                    <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                    sun.misc.PerfCounter.getFindClasses().increment();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolve) &#123;<br>                resolveClass(c);<br>            &#125;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>双亲委派机制的好处？</strong></p><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p><p><strong>如果我们不想用双亲委派模型怎么办？</strong></p><p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、对象存活判定算法"><a href="#一、对象存活判定算法" class="headerlink" title="一、对象存活判定算法"></a>一、对象存活判定算法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li>每个对象都包含一个<strong>引用计数器</strong>，用于存放引用计数（被引用的次数）</li><li>每当有一个地方引用此对象时，引用计数 <code>+1</code></li><li>当引用失效（离开了局部变量的作用域、引用被设定为null）时，引用计数 <code>-1</code></li><li>当引用计数为 <code>0</code> 时，表示此对象不能再被使用，因为没有任何途径可以得到此对象的引用了</li></ul><p><strong>虽然这个方法简单高效，但是主流的虚拟机并没有选择这个算法来管理内存，主要原因是它很难解决对象之间相互循环引用的问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountingGc</span> </span>&#123;<br>    Object instance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReferenceCountingGc objA = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>        ReferenceCountingGc objB = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>        objA.instance = objB;<br>        objB.instance = objA;<br>        objA = <span class="hljs-keyword">null</span>;<br>        objB = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述代码所示：除了对象 <code>objA</code> 和 <code>objB</code>相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致他们的引用计数器的值永远都不为 <code>0</code> ，但是实际上此对象已经欸有任何用途了，导致引用计数器无法通知 GC 回收器 回收他们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-1.png" alt></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象（其实就是方法中的局部变量）</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-2.png" alt="image-2"></p><p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。比如某个方法中的局部变量引用，在方法执行完成返回之后：</p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-3.png" alt="image-3"></p><p>这样就<strong>能很好地解决我们刚刚提到的循环引用问题</strong>，我们再来重现一下出现循环引用的情况：</p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-4.png" alt="image-4"></p><p>可以看到，对象1和对象2依然是存在循环引用的，但是他们各自的GC Roots都断开时，就会变成下面这样：</p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-5.png" alt="image-5"></p><p>所以，我们最后进行一下总结：如果某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的。</p><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法</p><p><strong>（只有重写了<code>finalize</code> 方法且未执行过的对象才满足执行条件）</strong>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><p>当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-6.png" alt></p><blockquote><p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK 9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p></blockquote><h1 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h1><h2 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h2><p>实际上，如果我们对堆中的每一个对象都依次判断是否需要回收，这样的效率其实是很低的，那么有没有更好地回收机制呢？第一步，我们可以对堆中的对象进行分代管理。</p><p>比如某些对象，在多次垃圾回收时，都未被判定为可回收对象，我们完全可以将这一部分对象放在一起，并让垃圾收集器减少回收此区域对象的频率，这样就能很好地提高垃圾回收的效率了。</p><p>因此，Java虚拟机将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<code>永久代</code>（其中永久代是HotSpot虚拟机特有的概念，在JDK8之前方法区实际上就是采用的永久代作为实现，而在JDK8之后，方法区由元空间实现，并且使用的是本地内存，容量大小取决于物理机实际大小，之后会详细介绍）这里我们主要讨论的是新生代和老年代。</p><p>不同的分代内存回收机制也存在一些不同之处，在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1，老年代的GC评率相对较低，永久代一般存放类信息等（其实就是方法区的实现）如图所示：</p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-7.png" alt></p><ul><li><p>新生代：</p><ul><li><p>Eden用来分配新对象，满了时会触发Minor GC。</p></li><li><p>From Survivor是上次Minor GC后存活的对象。</p></li><li><p>To Survivor是用于下次Minor GC时存放存活的对象。</p></li></ul></li><li><p>老年代：</p><ul><li>用于存放存活时间比较长的对象，大的对象，当容量满时会触发Major GC（Full GC）</li></ul></li></ul><p><strong>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</strong></p><ul><li><p>部分收集 (Partial GC)：</p><ul><li><p>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</p><ul><li>触发条件：新生代的Eden区内容已满时</li></ul></li><li><p>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</p></li><li><p>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</p></li></ul></li><li><p>整堆收集 (Full GC)：</p><ul><li>收集整个 Java 堆和方法区。<ul><li>触发条件1：每次晋升到老年代的对象平均大小 超过 老年代剩余空间</li><li>触发条件2：Minor GC 后存活的对象 超过 老年代剩余空间</li><li>触发条件3：永久代内存不足（JDK 8 之前）</li><li>触发条件4：手动调用 <code>System.gc()</code> 方法</li></ul></li></ul></li></ul><h2 id="空间分配担保机制"><a href="#空间分配担保机制" class="headerlink" title="空间分配担保机制"></a>空间分配担保机制</h2><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间</p><p>我们可以思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代Eden区仍然存在大量的对象（因为GC之后存活对象会进入到一个Survivor区，但是很明显这时已经超出Survivor区的容量了，肯定是装不下的）那么现在该怎么办？</p><p>这时就需要用到空间分配担保机制了，可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保（当然老年代也得装得下才行）在现实生活中，贷款会指定担保人，就是当借款人还不起钱的时候由担保人来还钱。</p><p>当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象。</p><p>那既然新生代装不下就丢给老年代，那如果老年代也装不下新生代的数据呢？这时，老年代肯定担保人是当不成了，那么这样的话，首先会判断一下当前老年代的剩余空间 <code>是否大于</code> 之前的每次垃圾回收进入老年代的平均大小，如果大于，那么说明也许可以放得下（不过也仅仅是也许，依然有可能放不下，因为判断的实际上只是平均值，万一这一次对象突然非常大呢），否则，会先来一次Full GC，进行一次大规模垃圾回收，来尝试腾出空间，再次判断老年代是否有空间存放，如果还是装不下，直接抛出OOM错误，摆烂。<br><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-8.png" alt></p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p><strong>一般用于老年代</strong></p><p><code>标记-清除</code>算法是最早且最简单的一种垃圾回收算法，在整个垃圾回收过程中总共分为两步：</p><ol><li>标记需要回收的对象</li><li>将第一步标记的对象进行统一的回收</li></ol><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-9.png" alt></p><p>标记-清除算法存在以下问题：</p><ol><li><p><strong>效率不稳定</strong></p><p>如果Java堆中包含有大量的需要回收的对象，那么使用该回收算法的时候就需要去标记大量的对象，然后再去对标记的对象进行回收，导致该回收算法的效率会随着对象数量的增长而降低。</p></li><li><p><strong>内存碎片化</strong></p><p>通过上图可以看到，当完成对象回收之后，未使用的内存区域呈现无规律的随机分布，这就造成了内存碎片化的问题，如果当前Java程序中需要实例化一个大对象，但是由于内存碎片化的问题导致无法分配一个连续的大内存空间，就会导致提前又触发一次垃圾回收。</p></li></ol><p><strong>使用标记-清除算法的垃圾收集器：CMS 垃圾收集器</strong></p><blockquote><p>标记清除算法常被使用在老年代中，因为老年代中的对象大部分都不会被清理掉，只存在于少部分的对象会被清理，所以在老年代中不会存在标记大量对象并清除的情况。</p></blockquote><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p><strong>一般用于新生代</strong></p><p><code>标记-复制</code>算法是在标记-清除的基础上提出的。标记复制算法中将内存区域划分为两块大小一致的区域，每次只使用其中一块，当这一块的内存用完了之后就将还存活的对象复制到另一块区域上去，然后将当前块的内存空间一次性清理掉，假设内存分为A和B两块，首先使用A内存，B作为保留，则标记复制算法步骤如下：</p><ol><li>在A中标记需要回收的对象</li><li>将A中存活的对象复制到B中</li><li>将A的内存空间一次性全部清理掉</li></ol><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-10.png" alt></p><p>标记-复制算法存在以下问题：</p><ol><li>将原有的内存区域划分为两块，且每次只能使用其中一块，则可使用内存相比标记-清除算法缩小了50%，空间浪费太大</li><li>如果内存中存活的对象太多，在复制过程中需要复制大量的存活对象，会导致效率低下、额外开销大</li></ol><p><strong>使用标记-复制算法的垃圾收集器：Serial New，Parallel New，Parallel Scanvage 垃圾收集器</strong></p><blockquote><p>标记-复制算法适用于Java堆中的新生代部分的垃圾回收，因为在新生代区域中，正常情况下能够存活下来的对象只有极少数，这样复制算法就不存在大量复制对象的情况</p><p>针对于空间浪费问题，将新生代区域划分为一块较大的Eden区域和两块较小的Survivor区域，每次分配对象时使用Eden和其中一块Survivor，当发生垃圾回收时，将Eden中和Survivor中存活的对象复制到另一块Survivor中，然后将Eden和已使用过的Survivor内存空间直接清理掉，下一轮分配对象时使用Eden和之前保存了存活对象的那一块Survivor，依次循环</p><p>HotSpot虚拟机默认的Eden和Survivor的大小比例为8:1，Eden占新生代80%，两个Survivor各占10%，这样每次可使用的内存空间就是90%，比标记复制算法默认的等分50%要多得多。</p></blockquote><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><strong>一般用于老年代</strong></p><p><code>标记-整理</code>算法又是在标记-清除和标记-复制两种算法的基础上提出的<strong>（为了解决：在老年代中大部分对象都会存活下来，所以不适合标记复制算法，而且使用标记清除算法又会造成大量内存碎片）</strong>。标记整理算法的标记步骤和标记清除算法一致，但是在标记之后不会直接进行清除，而是首先将存活的对象向内存空间的一端进行移动，将所有存活的对象都连续的放在一起，然后直接清理掉边界以外的内存，标记整理算法步骤如下：</p><ol><li>标记需要回收的对象</li><li>将存活的对象向内存空间的一端移动</li><li>直接清理掉边界以外的内存</li></ol><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-11.png" alt></p><p>标记-整理算法存在以下问题：</p><ol><li>由于需要移动对象，停顿时间会比较长，垃圾回收时的延迟会高一些。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿（被称为“Stop The World”）。</li></ol><p><strong>使用标记-复制算法的垃圾收集器：Parallel Old，Serial Old 垃圾收集器</strong></p><h1 id="三、垃圾收集器"><a href="#三、垃圾收集器" class="headerlink" title="三、垃圾收集器"></a>三、垃圾收集器</h1><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p>Serial（串行）收集器是最基本、最悠久的垃圾收集器。是一个单线程收集器，它的单线程“<strong>单线程</strong>”的意义并不仅仅是只会使用一条垃圾收集线程区完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-12.png" alt></p><p>Serial 收集器的优点：</p><ol><li>简单且高效（与其他收集器的单线程相比）</li><li>没有线程交互的开销，自然可以获得很高的单线程收集效率。在Client模式下（一般用于一些桌面级图形化界面应用程序）的新生代中，默认的垃圾收集器就是Serial收集器</li></ol><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。</p><p>它主要有两大用途：</p><ol><li>在 JDK1.5 及以前的版本中与 Parallel Scavenge 收集器搭配使用</li><li>作为 CMS 收集器的后备方案</li></ol><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为（控制参数、收集算法、回收策略等）和 Serial 收集器完全一样。<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-13.png" alt></p><p>ParNew 收集器的优点：</p><ol><li>是许多运行在Server模式下的虚拟机的首要选择</li><li>除了Serial收集器外，只有它能与CMS收集器配合工作</li></ol><h2 id="Parallel-Scavenge-Parallel-Old-收集器"><a href="#Parallel-Scavenge-Parallel-Old-收集器" class="headerlink" title="Parallel Scavenge / Parallel Old 收集器"></a>Parallel Scavenge / Parallel Old 收集器</h2><p><strong>Parallel Scavenge是一个面向新生代的垃圾收集器，采用标记-复制算法，多线程收集器</strong></p><p>关注点是吞吐量（高效率的利用CPU），所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。而CMS 等垃圾收集器的关注点更多的是压缩用户线程的停顿时间（提高用户体验）</p><p>它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案。</p><p><strong>Parallel Old是一个面向老年代的垃圾收集器，采用标记-整理算法，多线程收集器</strong></p><blockquote><p>在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器</p><p>目前 JDK 8 采用的就是这种 Parallel Scavenge + Parallel Old 的垃圾回收方案。</p></blockquote><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-14.png" alt></p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常注重压缩用户线程的停顿时间（提高用户体验）是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ol><li><strong>初始标记：</strong>暂停用户线程，标记出直接与 GC Roots 相连的对象，速度很快；</li><li><strong>并发标记：</strong>从 GC Roots 直接相连的对象开始遍历整个对象图的过程，耗时较长，但不需要暂停用户线程，可以与 GC 线程并发运行；</li><li><strong>重新标记：</strong>暂停用户线程，修正并发标记期间因为用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，暂停时间比初始标记阶段长一点；</li><li><strong>并发清除：</strong>直接将所有标记好的无用的对象进行删除，因为这些对象在程序中用不到了，可以与用户线程并发运行</li></ol><p><img src alt><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-15.png" alt="image-15"></p><p>优点：</p><ol><li>并发收集</li><li>低停顿</li></ol><p>缺点：</p><ol><li>对CPU资源敏感</li><li>无法处理浮动数据</li><li>使用“标记-清除”算法会产生大量的空间碎片</li></ol><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</strong></p><p>在 JDK 7 时走上历史舞台，并在 JDK 9 时正式取代了 JDK 8 默认的 Parallel Scavenge + Parallel Old 的垃圾回收方案</p><p>我们知道，我们的垃圾回收分为<code>Minor GC</code>、<code>Major GC</code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器巧妙地绕过了这些约定，它将整个Java堆划分成<code>2048</code>个大小相同的独立<code>Region块</code>，每个<code>Region块</code>的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region块</code>大小相同，且在JVM的整个生命周期内不会发生改变。</p><p>那么分出这些<code>Region</code>有什么意义呢？每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个Humongous区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。<br><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-16.png" alt></p><p>它的回收过程与CMS大体类似：</p><ol><li><strong>初始标记：</strong>暂停用户线程，标记与 GC Roots直接相连的对象，并修改TAMS指针的值，让下一阶段你用户线程并发运行时能够正确的在可用的Region中分配新对象。虽然要暂停用户线程，但耗时很短，并且是在进行Minor GC的时候同步完成，所以G1收集器在这个阶段实际并没有额外的停顿；</li><li><strong>并发标记：</strong>从GC Roots开始对堆中的对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象，这个阶段耗时较长，但可与用户线程并发执行；</li><li><strong>最终标记：</strong>暂停用户线程，用户处理并发标记阶段漏标的那部分对象；</li><li><strong>筛选回收：</strong>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及到存活对象的移动，所以必须暂停用户线程，由多个收集器线程并行完成的</li></ol><p><img src="/2022/07/25/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-17.png" alt></p><h1 id="四、引用类型"><a href="#四、引用类型" class="headerlink" title="四、引用类型"></a>四、引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>在Java中，如果变量是一个对象类型的，那么它实际上存放的是对象的引用，但如果是一个基本类型，那么存放的就是基本类型的值。实际上我们平时代码中类似于 <code>Object o = new Object()</code>这样的引用类型，细分之后就是 <code>强引用</code></p><p>如果方法中存在这样的 <code>强引用</code> 类型，当需要回收强引用所执行的对象时，要么此方法运行结束，要么引用连接断开，否则被引用的对象时无法被判定为可回收的。</p><p>所以，当 JVM 内存不足时，宁愿抛出 OOM 使程序异常终止，也不会随意回收具有强引用的“存活”对象。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>当 JVM 内存空间足够时，软引用的对象不会被系统回收。当内存空间不足时，软引用的对象才有可能被系统回收。通常用于内存敏感的程序中。</p><p>我们可以通过以下方式来创建一个软引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//强引用写法：Object obj = new Object();</span><br>        <span class="hljs-comment">//软引用写法：</span><br>        SoftReference&lt;Object&gt; reference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> Object());<br>        <span class="hljs-comment">//使用get方法就可以获取到软引用所指向的对象了</span><br>        System.out.println(reference.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到软引用还存在一个带队列的构造方法，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p>这里我们来进行一个测试，首先我们需要设定一下参数，来限制最大堆内存为10M，并且打印GC日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+PrintGCDetails -Xms10M -Xmx10M<br></code></pre></td></tr></table></figure><p>接着运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReferenceQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br>        SoftReference&lt;Object&gt; reference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> Object(), queue);<br>        System.out.println(reference);<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) list.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;lbwnb&quot;</span>));<br>        &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;<br>            System.out.println(<span class="hljs-string">&quot;发生了内存溢出！&quot;</span>+t.getMessage());<br>            System.out.println(<span class="hljs-string">&quot;软引用对象：&quot;</span>+reference.get());<br>            System.out.println(queue.poll());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">ref</span><span class="hljs-operator">.</span><span class="hljs-variable">SoftReference</span><span class="hljs-operator">@</span><span class="hljs-number">232204</span><span class="hljs-variable">a1</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">3943</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">501</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">3943</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2362</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0050615</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">3714</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">496</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5574</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">4829</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0049642</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.03</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">3318</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">7652</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">7711</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0059440</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.03</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">--</span><span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">11807</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">15870</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0078912</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.05</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">11262</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">10104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">11264</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15870</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">10104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0587856</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.24</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.06</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">4096</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">1535</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">10104</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">11242</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">11264</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">14200</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">12777</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0608198</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.25</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.06</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">3965</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3896</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">11242</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">11242</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">11264</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15207</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">15138</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0972088</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.58</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.10</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">3896</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3896</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">11242</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">11225</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">11264</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15138</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">15121</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">15872</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3207</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.1028222</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.63</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.10</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br>发生了内存溢出！<span class="hljs-variable">Java</span> <span class="hljs-variable">heap</span> <span class="hljs-variable">space</span><br>软引用对象：<span class="hljs-variable">null</span><br><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">ref</span><span class="hljs-operator">.</span><span class="hljs-variable">SoftReference</span><span class="hljs-operator">@</span><span class="hljs-number">232204</span><span class="hljs-variable">a1</span><br><span class="hljs-variable">Heap</span><br> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">4608</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">4048</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bfb00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007c0000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007c0000000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">4096</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">98</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bfb00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bfef40a8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bff00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bff80000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007c0000000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">11264</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">11225</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bf000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007bfb00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007bfb00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">11264</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">99</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bf000000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bfaf64a8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000007bfb00000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3216</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4500</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><br>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">352</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span><br><br></code></pre></td></tr></table></figure><p>可以看到，当内存不足时，软引用所指向的对象被回收了，所以<code>get()</code>方法得到的结果为null，并且软引用对象本身被丢进了队列中。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用的级别比软引用还低，在进行垃圾回收时，不管当前内存空间是否充足，都会回收它的内存。</p><p>我们可以像这样创建一个弱引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WeakReference&lt;Object&gt; reference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> Object());<br>        System.out.println(reference.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法和软引用是差不多的，但是如果我们在这之前手动进行一次GC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> Object());<br>        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> Object());<br><br>        <span class="hljs-comment">//手动GC</span><br>        System.gc();<br><br>        System.out.println(<span class="hljs-string">&quot;软引用对象：&quot;</span>+softReference.get());<br>        System.out.println(<span class="hljs-string">&quot;弱引用对象：&quot;</span>+weakReference.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，弱引用对象直接就被回收了，而软引用对象没有被回收。同样的，它也支持ReferenceQueue，和软引用用法一致，这里就不多做介绍了。</p><p><code>WeakHashMap</code>正是一种类似于弱引用的HashMap类，如果Map中的Key没有其他引用那么此Map会自动丢弃此键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer a = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br><br>        WeakHashMap&lt;Integer, String&gt; weakHashMap = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();<br>        weakHashMap.put(a, <span class="hljs-string">&quot;yyds&quot;</span>);<br>        System.out.println(weakHashMap);<br><br>        a = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        <br>        System.out.println(weakHashMap);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，当变量a的引用断开后，这时只有WeakHashMap本身对此对象存在引用，所以在GC之后，这个键值对就自动被舍弃了。所以说这玩意，就挺适合拿去做缓存的。</p><h2 id="虚引用（鬼引用）"><a href="#虚引用（鬼引用）" class="headerlink" title="虚引用（鬼引用）"></a>虚引用（鬼引用）</h2><p>虚引用相当于没有引用，随时都有可能会被回收。</p><p>看看它的源码，非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns this reference object&#x27;s referent.  Because the referent of a</span><br><span class="hljs-comment">     * phantom reference is always inaccessible, this method always returns</span><br><span class="hljs-comment">     * &lt;code&gt;null&lt;/code&gt;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  &lt;code&gt;null&lt;/code&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a new phantom reference that refers to the given object and</span><br><span class="hljs-comment">     * is registered with the given queue.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span><br><span class="hljs-comment">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span><br><span class="hljs-comment">     * method will always return null and, since it does not have a queue, it</span><br><span class="hljs-comment">     * will never be enqueued.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> referent the object the new phantom reference will refer to</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> q the queue with which the reference is to be registered,</span><br><span class="hljs-comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhantomReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, q);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说我们无论调用多少此<code>get()</code>方法得到的永远都是<code>null</code>，因为虚引用本身就不算是个引用，相当于这个对象不存在任何引用，并且只能使用带队列的构造方法，主要用于跟踪对象被垃圾回收的状态，以便对象被回收时可以接到通知。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存区域</title>
    <link href="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <url>/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、运行时数据区"><a href="#一、运行时数据区" class="headerlink" title="一、运行时数据区"></a>一、运行时数据区</h1><h2 id="JVM的内存区域是如何划分的？"><a href="#JVM的内存区域是如何划分的？" class="headerlink" title="JVM的内存区域是如何划分的？"></a>JVM的内存区域是如何划分的？</h2><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-1.png" alt></p><p>内存区域一共分为5个区域，其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，我们的JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​    程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器；</p><p>​    字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而让线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><blockquote><p><strong>注意</strong>：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域</p><p>程序计数器的生命周期随着线程的创建而创建，随着线程的结束而死亡</p></blockquote><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>​    Java虚拟机栈是JVM运行时数据区域的一个核心，除了Native方法外，其他所有的Java方法都是通过Java虚拟机栈来实现的；</p><p>​    方法调用的数据需要通过Java虚拟机栈进行传递，每次方法时调用都会有一个对应的栈帧被压入栈，每个方法调用结束后，都会有一个栈帧被弹出；</p><p>​    栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作</p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-2.png" alt></p><ul><li><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（byte、short、int、long、float、double、char、boolean）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</li><li><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中</li><li><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。在Java源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保证在Class 文件的常量池里。当一个方法要调用其他方法时，需要将常量池中指向方法的符号引用转换为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用</li></ul><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-3.png" alt></p><ul><li><strong>方法出口</strong> Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></li></ul><blockquote><p><strong>注意</strong>：Java虚拟机栈可能出现以下两种错误：</p><ul><li><p><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p></li><li><p><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p></li></ul><p>Java虚拟机栈的生命周期随着线程的创建而创建，随着线程的结束而死亡</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​    和Java虚拟机栈发挥的作用相似，区别是：<strong>虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈是为虚拟机使用Native方法服务</strong></p><p>​    本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>​    方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><blockquote><p>在 HotSpot 虚拟机中将 Java 虚拟机栈 和 本地方法栈 合二为一</p><p>本地方法栈的生命周期随着线程的创建而创建，随着线程的结束而死亡</p></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>​    堆是Java虚拟机管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例和数组，几乎所有的对象实例和数组都在这里分配内存</strong></p><blockquote><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p></blockquote><p>​    Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代(Young Generation)</li><li>老年代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-4.png" alt></p><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong></p><blockquote><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。（和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值）</li><li>……</li></ol></blockquote><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​    方法区是各个线程共享的内存区域，在虚拟机启动时创建。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、JIT代码缓存等数据</strong>。</p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-5.png" alt></p><p>​    <strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的是与Java堆进行区分。</strong></p><p>​    <strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。</p><blockquote><p><strong>注意</strong>：永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p></blockquote><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-6.png" alt></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><blockquote><p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java">-XX:PermSize=N <span class="hljs-comment">//方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的初始（和最小大小）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure><p>与永久代很大的不同就是，元空间如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​    Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>​    字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。</p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><blockquote><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p></blockquote><p><strong>具备动态性，运行时也可以添加新的常量入池（例如调用String的intern()方法时，如果常量池没有相应的字符串，会将它添加到常量池）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String a = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String b = <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.println(a==b);  <span class="hljs-comment">//true</span><br>        String c = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        System.out.println(a==c);  <span class="hljs-comment">//false</span><br>        System.out.println(a==c.intern());  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>​    字符串常量池是JVM为了提升性能和减少内存消耗而针对字符串（String类）专门开辟的一块区域，<strong>主要目的是为了避免字符串的重复创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br>String aa = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br>String bb = <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。</p><p><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></p><ul><li><strong>JDK1.6 字符串常量池存放在永久代。</strong></li></ul><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-7.png" alt="image-7"></p><ul><li><strong>JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</strong></li></ul><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-8.png" alt></p><p><strong>JDK1.8 放弃永久代，采用元空间。</strong></p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-9.png" alt></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（堆外内存）并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。需要我们自行去申请和释放，而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>申请堆外内存操作类：<code>Unsafe</code>，如同它的名字一样，虽然提供了申请堆外内存的操作类，但实际上它是不安全的，只有当你完全了解并掌握了底层原理且能够合理控制堆外内存，才能安全地使用堆外内存。</p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然作为内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h1 id="二、HotSpot-虚拟机对象"><a href="#二、HotSpot-虚拟机对象" class="headerlink" title="二、HotSpot 虚拟机对象"></a>二、HotSpot 虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>对象创建的流程图如下：</p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-10.png" alt></p><ol><li><p><strong>类加载检查</strong></p><p>虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化。如果没有，则必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存</strong></p><p>在<code>类加载检查</code>通过后，虚拟机将为新生对象<code>分配内存</code>。对象所需的内存大小在类加载完成后便可确定， 为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 ”<strong>指针碰撞</strong>“ 和 ”<strong>空闲列表</strong>“ 两种。</p><blockquote><p>具体分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的 GC 收集器是否带有压缩整理功能决定</p></blockquote><ul><li>指针碰撞：<ul><li>原理：用过的内存全部整合到一边，没用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动，调整内存大小位置即可。</li><li>适用场景：堆内存规整（即没有内存碎片）的情况</li><li>使用指针碰撞的 GC 收集器：Serial、ParNew</li></ul></li><li>空闲列表：<ul><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录。</li><li>适用场景：堆内存不规整的情况</li><li>使用空闲列表的 GC 收集器：CMS</li></ul></li></ul><p><strong>分配内存的并发问题</strong>：在实际开发过程中，创建对象是很频繁的，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机保证线程安全的方式有“<strong>CAS+失败重试</strong>”和“<strong>TLAB</strong>”两种。</p><ul><li>CAS+失败重试：CAS是乐观锁的一种实现方式。乐观锁是指（每次不加锁而假设没有冲突的去完成某项操作，如果因为冲突失败就重试，直到成功为止）。<strong>虚拟机采用 CAS+失败重试 的方式保证了更新操作的原子性</strong></li><li>TLAB：为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中剩余内存或者内存已耗尽时，再采用 CAS 的方式进行内存分配</li></ul></li><li><p><strong>初始化零值</strong></p><p>在<code>内存分配</code>完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包含对象头），<strong>主要目的是为了保证对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</strong></p></li><li><p><strong>设置对象头</strong></p><p>在<code>初始化零值</code>完成后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息都存放在对象头中。除此之外，根据虚拟机当前运行状态的不同，例如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li><p><strong>执行 init 方法</strong></p><p>在上面操作都完成后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p></li></ol><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在内存中存储布局主要分为对象头，实例数据和对齐填充三部分。</p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-11.png" alt></p><ul><li><p><strong>对象头</strong></p><p>对象头主要包含对象自身的<strong>运行时数据</strong>(也就是图中Mark Word)，<strong>类型指针</strong>(图中的Class Pointer，指向对象所属的类)。如果对象是数组，还需要包含数组长度(否则无法确定数组对象的大小)。</p><ul><li><strong>Mark Word</strong>：存储对象自身的运行时数据，例如hashCode，GC分代年龄，锁状态标志，线程持有的锁等等。在32位系统占4字节，在64位系统中占8字节。</li><li><strong>Class Pointer</strong>：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在开启了指针压缩时，占4字节。（默认是开启的）</li><li><strong>Length</strong>：如果是数组对象，还有一个保存数组长度的空间，占4个字节。</li></ul></li><li><p><strong>实例数据</strong></p><p>保存对象的非静态成员变量数据。<strong>实例数据存储的是真正的有效数据，即各个字段的值</strong>。无论是子类中定义的，还是从父类继承下来的都需要记录。这部分数据的存储顺序受到虚拟机的分配策略以及字段在类中的定义顺序的影响。</p></li><li><p><strong>对齐填充</strong></p><p>因为HotSpot虚拟机的自动内存管理系统要求对象起始地址是8字节的整数倍，所以任何对象的大小必须是8字节的整数倍，而对象头部分一般是8字节的倍数，如果实例数据部分不是8字节的整数倍，需要对齐填充来补全。<strong>对齐填充部分仅仅起到占位符的作用</strong></p></li></ul><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>句柄</strong>、<strong>直接指针</strong></p><ul><li><p><strong>句柄</strong></p><p>如果使用句柄，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-12.png" alt></p></li><li><p><strong>直接指针</strong></p><p>如果使用直接指针，那么 reference 中存储的直接就是对象的地址</p><p><img src="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-13.png" alt></p></li></ul><p>两种方式的对比：</p><ul><li><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中实例数据的指针，而 reference 本身不需要修改；</p></li><li><p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。<strong>HotSpot采用此方式</strong></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>后端面试</title>
    <link href="/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java-SE基础（上）"><a href="#一、Java-SE基础（上）" class="headerlink" title="一、Java SE基础（上）"></a>一、Java SE基础（上）</h1><h2 id="1、运算符（上）"><a href="#1、运算符（上）" class="headerlink" title="1、运算符（上）"></a>1、运算符（上）</h2><p><strong>简介：短路运算符 和 位运算</strong></p><ul><li><p>考点：计算机基础运算知识</p></li><li><p>运算符 &amp;和&amp;&amp; 以及 |和|| 的区别</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp; 按位与操作</span><br>两个二进制数同时为<span class="hljs-number">1</span>时，结果才为<span class="hljs-number">1</span><br><span class="hljs-number">1</span><span class="hljs-meta">&amp;1 = 1</span><br><span class="hljs-number">1</span><span class="hljs-meta">&amp;0 = 0</span><br><span class="hljs-number">0</span><span class="hljs-meta">&amp;1 = 0</span><br><span class="hljs-number">0</span><span class="hljs-meta">&amp;0 = 0</span><br><span class="hljs-string">| 按位或操作</span><br>两个二进制数中有一个为<span class="hljs-number">1</span>时，结果就为<span class="hljs-number">1</span><br><span class="hljs-number">1</span><span class="hljs-string">|1 = 1</span><br><span class="hljs-number">1</span><span class="hljs-string">|0 = 1</span><br><span class="hljs-number">0</span><span class="hljs-string">|1 = 1</span><br><span class="hljs-number">0</span><span class="hljs-string">|0 = 0</span><br><br><span class="hljs-meta">&amp;和| 称为位运算符</span><br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;和&amp;&amp;</span><br>区别：<span class="hljs-meta">&amp;两边都要运算，而&amp;&amp;先算左侧，若左侧为false，那么右侧将不再运算。判断语句中推荐使用&amp;&amp; 效率更高。</span><br><br><span class="hljs-string">|和||</span><br>区别：<span class="hljs-string">|要对所有条件进行判断，而||只要满足左侧的条件，那么右侧将不再运算。</span><br><br><span class="hljs-meta">&amp;&amp;和|| 称为短路运算符 在判断语句中常见</span><br></code></pre></td></tr></table></figure></li><li><p>用最有效的方法计算 2乘以8</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing">答案：<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">3</span><br>原理：将一个数m左移n位，相当于m乘以<span class="hljs-number">2</span>的n次方，位运算是CPU直接支持的，所以效率高。<br><br>常见的JDK源码里面的<span class="hljs-keyword">HashMap</span>的默认容量为<span class="hljs-number">16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br>直接二进制操作，表示<span class="hljs-number">1</span>左移<span class="hljs-number">4</span>位，变<span class="hljs-number">10000</span>，转为十进制就是<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2、运算符（下）"><a href="#2、运算符（下）" class="headerlink" title="2、运算符（下）"></a>2、运算符（下）</h2><p><strong>简介：异或运算</strong></p><ul><li><p>考点：计算机基础运算知识</p></li><li><p>写个方法，传递两个非0的int数值进去，实现变量交换的方式，有几种方式？（不借助第三个临时变量）</p><ul><li><p>方式一：数学等量代换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d&quot;</span>, a, b);<br>        a = a + b; <span class="hljs-comment">// a1 = a + b</span><br>        b = a - b; <span class="hljs-comment">// b = a1 - b = (a + b) -b 即 b = a</span><br>        a = a - b; <span class="hljs-comment">// a = a1 - b = (a + b) - (a) 即 a = b</span><br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\na=%d,b=%d&quot;</span>, a, b);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式二：异或运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap02</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d&quot;</span>, a, b);<br>        a = a ^ b; <span class="hljs-comment">// a1 = a^b</span><br>        b = b ^ a; <span class="hljs-comment">// b = b^a1 = b^a^b = a</span><br>        a = a ^ b; <span class="hljs-comment">// a = a1^b = a^b^a = b</span><br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\na=%d,b=%d&quot;</span>, a, b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3、类型"><a href="#3、类型" class="headerlink" title="3、类型"></a>3、类型</h2><p><strong>简介：Java数据类型划分</strong></p><ul><li><p>考点：Java基础类型的划分和运算</p></li><li><p>说下Java数据类型分类</p><ul><li>基础数据类型：byte、short、int、long、float、double、char、boolean</li><li>引用数据类型：其他都是引用类型</li></ul></li><li><p>运算</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">定义变量 int i = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> i++; 和 <span class="hljs-keyword">return</span> ++i; 返回结果是什么<br>    <span class="hljs-number">5</span>              <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li><li><p>== 和 equals 的区别</p><ul><li>基本数据类型比较<ul><li>用 == 判断是否相等</li></ul></li><li>引用数据类比较<ul><li>== 比较的是内存地址是否一样，不同对象的内存地址不一样</li><li>equals 比较的是具体的内容</li></ul></li></ul></li></ul><h2 id="4、try-catch-finally"><a href="#4、try-catch-finally" class="headerlink" title="4、try-catch-finally"></a>4、try-catch-finally</h2><p><strong>简介：try-catch-finally异常处理模块的返回值问题</strong></p><ul><li><p>考点：编码规范和执行逻辑</p></li><li><p>下面代码的 try-catch-finally 语句，try里面有个return，finally里面也有return，结果会返回什么？为什么？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">finally</span> 中的 <span class="hljs-keyword">return</span> 值会覆盖 <span class="hljs-keyword">try</span> 和 <span class="hljs-keyword">catch</span> 中的 <span class="hljs-keyword">return</span> 值。在正常情况（即程序正常执行<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span>语句块，不会在语句中出现退出程序、线程终止等特殊情况）下，都会执行<span class="hljs-keyword">finally</span>语句块，如果<span class="hljs-keyword">finally</span>中有<span class="hljs-keyword">return</span>，则程序会走<span class="hljs-keyword">finally</span>中的<span class="hljs-keyword">return</span>，如果没有，则先执行<span class="hljs-keyword">try</span>或者<span class="hljs-keyword">catch</span>中的<span class="hljs-keyword">return</span>，将其存入临时栈中，执行完<span class="hljs-keyword">finally</span>语句后最终返回临时栈中的值。<br><br><span class="hljs-keyword">public</span> static int test1() &#123;<br>        int i = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = i / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> --i;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            --i;<br>            <span class="hljs-keyword">return</span> i--;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            --i;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//返回值是9</span><br><span class="hljs-keyword">catch</span>中执行到<span class="hljs-keyword">return</span>语句时，不会真正的<span class="hljs-keyword">return</span>，即只是会计算<span class="hljs-keyword">return</span>中的表达式，之后将本应返回的结果（本题为<span class="hljs-number">9</span>）保存在一个临时栈中，接着执行<span class="hljs-keyword">finally</span>中的语句，最后才会从临时栈中取出之前的结果返回。<br><br><span class="hljs-keyword">public</span> static int test2() &#123;<br>        int i = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = i / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> --i;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            --i;<br>            <span class="hljs-keyword">return</span> i--;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            --i;<br>            <span class="hljs-keyword">return</span> i--;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//返回值是7</span><br><span class="hljs-keyword">catch</span>和<span class="hljs-keyword">finally</span>都包含<span class="hljs-keyword">return</span>，会执行<span class="hljs-keyword">catch</span>里面的<span class="hljs-keyword">return</span>语句，但并不返回。最终<span class="hljs-keyword">return</span>的是<span class="hljs-keyword">finally</span>里面的值。<br></code></pre></td></tr></table></figure></li></ul><h2 id="5、try-with-resource"><a href="#5、try-with-resource" class="headerlink" title="5、try-with-resource"></a>5、try-with-resource</h2><p><strong>简介：JDK9新特性 try-with-resource</strong></p><ul><li><p>考点：变成基础和是否有学习新知识</p></li><li><p>有了解新版的JDK处理IO流吗？编写下基础代码, 从一个txt文本里面，拷贝里面的内容到另外一个txt文本里面</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">JDK7之后的写法，JDK9⼜进⾏了改良，但是变化不⼤，记住下⾯的写法即可<br>需要关闭的资源只要实现了java<span class="hljs-selector-class">.lang</span>.AutoCloseable，就可以⾃动被关闭<br><span class="hljs-function"><span class="hljs-title">try</span><span class="hljs-params">()</span></span>⾥⾯可以定义多个资源，它们的关闭顺序是在try()中后定义的资源先关闭<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span> (<br>                FileInputStream fis = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;C:/Users/LiuPeng/Desktop/test.txt&quot;</span>);<br>                BufferedInputStream bis = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedInputStream</span>(fis);<br>                FileOutputStream fos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileOutputStream</span>(<span class="hljs-string">&quot;C:/Users/LiuPeng/Desktop/copy.txt&quot;</span>);<br>                BufferedOutputStream bos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedOutputStream</span>(fos);<br>        ) &#123;<br>            <span class="hljs-keyword">int</span> size;<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span> ((size = bis.<span class="hljs-built_in">read</span>(buf)) != <span class="hljs-number">-1</span>) &#123;<br>                bos.<span class="hljs-built_in">write</span>(buf, <span class="hljs-number">0</span>, size);<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (Exception e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="6、文件API和递归算法"><a href="#6、文件API和递归算法" class="headerlink" title="6、文件API和递归算法"></a>6、文件API和递归算法</h2><p><strong>简介：常见的文件API掌握，熟悉递归算法</strong></p><ul><li><p>考点：文件API使用，简单递归逻辑代码编写、代码编写规范、简洁性</p></li><li><p>代码编写需求：找出某目录下的所有子目录及子文件并打印到控制台上</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//找出某目录下的所有子目录及子文件并打印到控制台上</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; paths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-built_in">getAllFIlePaths</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-built_in">File</span></span>(<span class="hljs-string">&quot;C:\\IDEA\\IdeaProjects\\back-end interview&quot;</span>), paths);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> path : paths) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(path);<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAllFIlePaths</span><span class="hljs-params">(<span class="hljs-built_in">File</span> filePath, List&lt;<span class="hljs-keyword">String</span>&gt; paths)</span> </span>&#123;<br><br>        <span class="hljs-built_in">File</span>[] files = filePath.<span class="hljs-built_in">listFiles</span>();<br>        <span class="hljs-keyword">if</span> (files == null) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">File</span> file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">isDirectory</span>()) &#123;<br>                paths.<span class="hljs-built_in">add</span>(file.<span class="hljs-built_in">getPath</span>());<br>                <span class="hljs-built_in">getAllFIlePaths</span>(file, paths);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                paths.<span class="hljs-built_in">add</span>(file.<span class="hljs-built_in">getPath</span>());<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二、Java-SE基础（下）"><a href="#二、Java-SE基础（下）" class="headerlink" title="二、Java SE基础（下）"></a>二、Java SE基础（下）</h1><h2 id="1、字符串"><a href="#1、字符串" class="headerlink" title="1、字符串"></a>1、字符串</h2><p><strong>简介：常用字符串的考查点</strong></p><ul><li><p>下面这句话中创建了几个对象？</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;abc&quot;</span>); <br></code></pre></td></tr></table></figure><p>创建一个对象：常量池存在，则直接new一个对象在堆内存</p><p>创建两个对象：常量池不存在，则一个在常量池，一个在堆内存，堆内存对象是常量池对象的一个拷贝副本。</p></li><li><p>下面代码是比较什么？输出结果是什么？为什么？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;abc&quot;</span>); <br><span class="hljs-keyword">String</span> str2 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">String</span> str3 = <span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(str1 == str2); <span class="hljs-comment">//false</span><br>System.out.<span class="hljs-built_in">println</span>(str2 == str3); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>== 比较的 str1 和 str2 对象的内存地址，由于 str1 指向的是堆内存的地址，str2 看到 “abc” 已经在常量池存在，就不会再新建，所以 str2 指向了常量池的内存地址，所以 == 判断结果输出false，两者不相等</p><p>在上面把 “abc” 同时赋值给了 str2 和 str3 两个字符串对象，指向的都是同一个常量池的内存地址，所以第二个打印语句中的 == 比较输出结果是 true</p></li><li><p>下面代码的输出结果是什么？如果需要两个都为true，应该如何修改？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str1 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">String</span> str2 = str1 + <span class="hljs-string">&quot;c&quot;</span>;  <span class="hljs-comment">//变量 + 常量 = 来自堆</span><br><span class="hljs-keyword">String</span> str3 = <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>; <span class="hljs-comment">//常量 + 常量 = 来自常量池</span><br>System.out.<span class="hljs-built_in">println</span>(str2 == <span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">//false</span><br>System.out.<span class="hljs-built_in">println</span>(str3 == <span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>String str2 = str1 + “c”;  //变量 + 常量 = 来自堆。任何数据和字符串进行加号（+）运算，最终得到是一个拼接的新的字符串。拼接的原理是由 StringBuilder 或者 StringBuffe r类和里面的 append 方法实现拼接，然后调用 toString() 把拼接的对象转换成字符串对象，最后把得到字符串对象的地址赋值给变量。</p><p>“ab” , ”c” 两个本来就是字符串常量，进行+符号拼接之后变成了 “abc” ，“abc” 本身就是字符串常量（Java中有常量优化机制），所以常量池立马会创建一个 “abc” 的字符串常量对象，在进行str3 ==  ”abc” ,这个时候，常量池存在 “abc” 。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">如果需要使第一个输出语句为<span class="hljs-literal">true</span>，则需要把变量改为常量即可<br>fianl <span class="hljs-keyword">String</span> str1 = <span class="hljs-string">&quot;ab&quot;</span>;<br>在<span class="hljs-keyword">String</span>前再加一个<span class="hljs-keyword">final</span>是固定了它的指引，让他不会再指向别的地址。当加上<span class="hljs-keyword">final</span>以后，这个值其实就已经在常量池中存在了，当调用这个变量时会把这个变量时，程序会把它当成一个常量来对待。<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、字符串相关构建类"><a href="#2、字符串相关构建类" class="headerlink" title="2、字符串相关构建类"></a>2、字符串相关构建类</h2><p><strong>简介：常用字符串相关构建类的使用和区别</strong></p><ul><li><p>常用类的掌握情况</p></li><li><p>String，StringBuffer和StringBuilder之间的区别是什么？分别在哪些场景下使用？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">三者都是<span class="hljs-keyword">final</span>修饰的， 不允许被继承<br>在本质都是<span class="hljs-keyword">char</span>[]字符数组实现<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span>是不可变对象，任何对<span class="hljs-built_in">String</span>改变都是会产生一个新的<span class="hljs-built_in">String</span>对象<br><span class="hljs-built_in">StringBuffer</span>和StringBuilder是可变的，对应的字符串的改变不会产生新的对象<br><br><span class="hljs-built_in">StringBuffer</span>的读写方法都使用了synchronized修饰，同一时间只有一个线程进行操作，所以是线程安全的，效率相对较低<br>StringBuilder因为没有加锁，不具备多线程安全，但效率更高<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">使用场景：<br>    操作少量的数据用<span class="hljs-built_in">String</span>，但是经常改变内容且操作数据多的情况下最好不要用 <span class="hljs-built_in">String</span> ，因为每次都生成中间对象导致性能会降低<br><br>多线程下操作大量的字符串，且需要保证线程安全 则用<span class="hljs-built_in">StringBuffer</span><br>    <br>    单线程下操作大量的字符串，在业务允许的情况下，虽然线程不安全但是不影响，则用StringBuilder<br></code></pre></td></tr></table></figure></li></ul><h2 id="3、面向对象"><a href="#3、面向对象" class="headerlink" title="3、面向对象"></a>3、面向对象</h2><p><strong>简介：面向对象思想OOP</strong></p><ul><li><p>考点：面向对象思想OOP的理解</p></li><li><p>面向对象的四大特性是什么？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">抽象<br>关键词<span class="hljs-keyword">abstract</span>声明的类叫作抽象类，<span class="hljs-keyword">abstract</span>声明的⽅法叫抽象⽅法<br>⼀个类⾥包含了⼀个或多个抽象⽅法，类就必须指定成抽象类<br>抽象⽅法属于⼀种特殊⽅法，只含有⼀个声明，没有⽅法体<br>抽象支付 pay(金额，订单号)，具体实现则可以是微信支付，支付宝支付，银行卡支付<br><br>封装<br>把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口<br>在java中通过关键字<span class="hljs-keyword">private</span>，<span class="hljs-keyword">protected</span>和<span class="hljs-keyword">public</span>实现封装<br>适当的封装可以让代码更容易理解和维护，也加强了代码的安全性<br><br>继承<br>从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsPay</span></span>&#123;<br><br>&#125;<br>        <br>WeixinPay <span class="hljs-keyword">extends</span> AbsPay&#123;<br><br>&#125;<br>        <br>AliPay <span class="hljs-keyword">extends</span> AbsPay&#123;<br><br>&#125;<br><br>多态<br>多个不同的对象对同一消息作出响应。同一消息根据不同的对象而采用各种不同的方法<br>优点：减少耦合、灵活可拓展<br>⼀般是继承类或者重写⽅法实现<br></code></pre></td></tr></table></figure></li></ul><h2 id="4、接口"><a href="#4、接口" class="headerlink" title="4、接口"></a>4、接口</h2><p><strong>简介：JDK8 接口新特性</strong></p><ul><li><p>考点：基础是否扎实和是否了解语言的新特性</p></li><li><p>Overload和Override的区别？</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">重载<span class="hljs-keyword">Overload</span>：表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同，参数个数或类型不同（同名不同参）<br>重写<span class="hljs-keyword">Override</span>：表示子类中的方法可以与父类中的某个方法的名称和参数完全相同（同名同参）<br></code></pre></td></tr></table></figure></li><li><p>接口是否可以继承接口？接口是否支持多继承？类是否支持多继承？接口里面是否可以有方法实现？</p><ul><li>接口里可以有静态方法和方法体</li><li>接口中所有的方法必须是抽象方法（JDK8之后就不是）</li><li>接口不是被类继承了，而是要被类实现</li><li>接口支持多继承, 类不支持多个类继承</li></ul><p>⼀个类只能继承⼀个类，但是能实现多个接口；一个接口能继承另⼀个或多个接口，接口的继承也使⽤extends关键字，和类继承⼀样</p></li><li><p>JDK8的接口新特性有哪些？</p><ul><li>interface中可以有static方法，但必须有方法实现体，该方法只属于该接口，只能通过接口名直接调用该方法</li><li>接口中新增default关键字修饰的方法，default方法只能定义在接口中，可以在子类或子接口中被重写，default定义的方法必须有方法体</li></ul></li></ul><h1 id="三、Java集合List"><a href="#三、Java集合List" class="headerlink" title="三、Java集合List"></a>三、Java集合List</h1><h2 id="1、Java集合List基础（上）"><a href="#1、Java集合List基础（上）" class="headerlink" title="1、Java集合List基础（上）"></a>1、Java集合List基础（上）</h2><p><strong>简介：Java集合LIst常见基础面试题</strong></p><ul><li>考点：List的基础知识点掌握、对应实现的区别、线程安全、使用场景</li><li>Vector、ArrayList、LinkedList的联系和区别？各自的使用场景？<ul><li>线程安全：<ul><li>Vector：底层是数组实现，线程安全，操作时使用synchronized进行加锁</li><li>ArrayList：底层是数组实现，线程不安全，查询和修改快，增加和删除慢</li><li>LinkedList：底层是双向链表实现，线程不安全，查询和修改慢，增加和删除快</li></ul></li><li>使用场景：<ul><li>Vector：很少使用了</li><li>ArrayList：查询和修改场景多时</li><li>LinkedList：增加和删除场景多时</li></ul></li></ul></li></ul><h2 id="2、Java集合List基础（下）"><a href="#2、Java集合List基础（下）" class="headerlink" title="2、Java集合List基础（下）"></a>2、Java集合List基础（下）</h2><p><strong>简介：基于List基础篇进行追问</strong></p><ul><li>考点：List的掌握情况（追问系列）</li><li>如果需要保证线程安全，ArrayList应该如何做？（以下方式基于JDK8实现）<ul><li>方式一：Collections.synchronizedList(new ArrayList&lt;&gt;()); 使用synchronized加锁</li><li>方式二：new CopyOnWriteArrayList&lt;&gt;(); 使用ReentrantLock加锁</li><li>方式三：自己写个包装类，根据业务一般是add/update/remove加锁</li></ul></li></ul><h2 id="3、CopyOnWriteArrayList"><a href="#3、CopyOnWriteArrayList" class="headerlink" title="3、CopyOnWriteArrayList"></a>3、CopyOnWriteArrayList</h2><p><strong>简介：基于CopyOnWriteArrayList进行追问</strong></p><ul><li>考点：CopyOnWriteArrayList的掌握情况（追问系列）</li><li>了解CopyOnWriteArrayList吗？和Collections.synchronizedList实现线程安全有什么区别？使用场景是怎样的？<ul><li>CopyOnWriteArrayList：执行修改操作时，会拷贝一份新的数组进行操作（add、set、remove等），代价很高，在执行完修改后将原来集合指向新的集合来完成修改操作，源码里的ReentrantLock可重入锁来保证不会有多个线程同时拷贝一份数组<ul><li>场景：适用于读多写少的并发场景（读操作不需要加锁）</li></ul></li><li>Collections.synchronizedList：线程安全的原因是因为它几乎在每个方法中都使用了synchronized同步锁<ul><li>场景：写操作性能比CopyOnWriteArrayList好，但是读操作性能不如CopyOnWriteArrayList</li></ul></li></ul></li><li>CopyOnWriteArrayList的设计思想是怎样的？有什么缺点？<ul><li>设计思想：读写分离+最终一致性</li><li>缺点：内存占用问题，写时复制机制，内存里面会同时驻扎两个对象的内存（旧的对象和新写入的对象），如果对象过大则容易发生Young GC和Full GC</li></ul></li></ul><h2 id="4、List集合扩容机制"><a href="#4、List集合扩容机制" class="headerlink" title="4、List集合扩容机制"></a>4、List集合扩容机制</h2><p><strong>简介：基于List进行追问，扩容机制</strong></p><ul><li>考点：List集合扩容机制</li><li>说下List的扩容机制是怎样的？<ul><li>扩容可分为两种情况：<ul><li>第一种情况，当ArrayList的容量为0时，此时添加元素的话，需要扩容，三种构造方法创建的ArrayList在扩容时略有不同：<ol><li>无参构造，创建ArrayList后容量为0，添加第一个元素后，容量变为10，此后若需要扩容，则正常扩容。</li><li>传容量构造，当参数为0时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</li><li>传列表构造，当列表为空时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</li></ol></li><li>第二种情况，当ArrayList的容量大于0，并且ArrayList已满的时候，此时添加元素的话，进行正常扩容，每次扩容到原来的1.5倍。</li></ul></li></ul></li></ul><h2 id="5、手写ArrayList（上）"><a href="#5、手写ArrayList（上）" class="headerlink" title="5、手写ArrayList（上）"></a>5、手写ArrayList（上）</h2><p><strong>简介：基于List进行追问，代码实战</strong></p><ul><li><p>考点：源码设计思想、代码编写规范</p></li><li><p>设计一个简单的ArrayList【需要包含 构造函数(无参和有参)、add(e)、 扩容机制】</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//判断当前集合类是否被并发修改，即迭代器并发修改的fail-fast机制</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-built_in">int</span> modCount = <span class="hljs-number">0</span>;<br>  <br>   <span class="hljs-comment">//默认的容量大小（常量）</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br>  <br>   <span class="hljs-comment">//定义的空数组（final修饰，大小固定为0）</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span>[] EMPTY_ELEMENTDATA = &#123;&#125;;<br>  <br>   <span class="hljs-comment">//定义的不可被序列化的数组，实际存储元素的数组</span><br>   <span class="hljs-keyword">transient</span> <span class="hljs-keyword">Object</span>[] elementData;<br>  <br>   <span class="hljs-comment">//数组中元素的个数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>;<br>  <br>   <span class="hljs-keyword">public</span> MyArrayList() &#123;<br>       <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>   &#125;<br>  <br>   <span class="hljs-keyword">public</span> MyArrayList(<span class="hljs-built_in">int</span> initialCapacity) &#123;<br>       <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[initialCapacity];<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数异常&quot;</span>);<br>       &#125;<br>   &#125;<br>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-built_in">add</span>(<span class="hljs-keyword">Object</span> e) &#123;<br>       <span class="hljs-comment">//判断容量</span><br>       ensureCapacityInternal(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>);<br>       <span class="hljs-comment">//使用下标赋值，尾部插入</span><br>       elementData[<span class="hljs-built_in">size</span>++] = e;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br>  <br>   <span class="hljs-comment">//计算容量+确保容量</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ensureCapacityInternal(<span class="hljs-built_in">int</span> minCapacity) &#123;<br>       <span class="hljs-comment">//用于并发判断</span><br>       modCount++;<br>  <br>       <span class="hljs-comment">//如果是初次扩容，则使用默认的容量</span><br>       <span class="hljs-keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<br>           minCapacity = Math.<span class="hljs-built_in">max</span>(DEFAULT_CAPACITY, minCapacity);<br>       &#125;<br>       <span class="hljs-comment">//判断是否需要扩容，所需的最少容量 大于 现在数组的长度 则需要扩容</span><br>       <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">int</span> oldCapacity = elementData.length;<br>           <span class="hljs-built_in">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>           <span class="hljs-comment">//如果新容量 &lt; 所需最小容量 ，则所需最小容量赋给新容量</span><br>           <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>               newCapacity = minCapacity;<br>           &#125;<br>           <span class="hljs-comment">//创建数组</span><br>           <span class="hljs-keyword">Object</span>[] objects = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[newCapacity];<br>           <span class="hljs-comment">//将旧的数组拷贝到新的数组中</span><br>           System.arraycopy(elementData, <span class="hljs-number">0</span>, objects, <span class="hljs-number">0</span>, elementData.length);<br>           <span class="hljs-comment">//修改引用</span><br>           elementData = objects;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="6、手写ArrayList（下）"><a href="#6、手写ArrayList（下）" class="headerlink" title="6、手写ArrayList（下）"></a>6、手写ArrayList（下）</h2><p><strong>简介：基于List进行追问，代码实战</strong></p><ul><li><p>考点：源码设计思想、代码编写规范</p></li><li><p>设计一个简单的ArrayList【remove(index)、get(index) 、indexOf(o) ,set(int index,Object o)】</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">private <span class="hljs-type">void</span> range<span class="hljs-keyword">Check</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &gt; size || <span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span>) &#123;<br>           throw <span class="hljs-built_in">new</span> IndexOutOfBoundsException(&quot;数组越界&quot;);<br>       &#125;<br>   &#125;<br>  <br>   //根据索引删除元素<br>   <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>       range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br>  <br>       //用于并发判断<br>       modCount++;<br>  <br>       <span class="hljs-keyword">Object</span> oldValue = elementData[<span class="hljs-keyword">index</span>];<br>       //计算要删除的位置后面还有多少个元素<br>       <span class="hljs-type">int</span> numMoved = size - <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">System</span>.arraycopy(elementData, <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>, elementData, <span class="hljs-keyword">index</span>, numMoved);<br>       &#125;<br>       //将多出的位置设置为空，没有引用对象，GC可以回收，如果不为空，将多保存一个引用，可能会造成内存泄露<br>       elementData[<span class="hljs-comment">--size] = null;</span><br>       <span class="hljs-keyword">return</span> oldValue;<br>   &#125;<br>  <br>   //通过索引获取对象<br>   <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>       range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br>       <span class="hljs-keyword">return</span> elementData[<span class="hljs-keyword">index</span>];<br>   &#125;<br>  <br>   //判断对象所在的位置<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> indexOf(<span class="hljs-keyword">Object</span> o) &#123;<br>       <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>               <span class="hljs-keyword">if</span> (elementData[i] == <span class="hljs-keyword">null</span>) &#123;<br>                   <span class="hljs-keyword">return</span> i;<br>               &#125;<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>               <span class="hljs-keyword">if</span> (o.equals(elementData[i])) &#123;<br>                   <span class="hljs-keyword">return</span> i;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br>  <br>   //根据索引修改元素<br>   <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">set</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-keyword">Object</span> e) &#123;<br>       range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br>       <span class="hljs-keyword">Object</span> oldValue = elementData[<span class="hljs-keyword">index</span>];<br>       elementData[<span class="hljs-keyword">index</span>] = e;<br>       <span class="hljs-keyword">return</span> oldValue;<br>   &#125;<br>   <br>   //获取数组实际大小<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> size() &#123;<br>       <span class="hljs-keyword">return</span> this.size;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="四、Java集合Map"><a href="#四、Java集合Map" class="headerlink" title="四、Java集合Map"></a>四、Java集合Map</h1><h2 id="1、Java集合Map基础（上）"><a href="#1、Java集合Map基础（上）" class="headerlink" title="1、Java集合Map基础（上）"></a>1、Java集合Map基础（上）</h2><p><strong>简介：Java集合Map常见基础面试题</strong></p><ul><li>考点：Map相关基础知识掌握情况</li><li>了解Map吗？用过哪些Map的实现？<ul><li>HashMap、Hashtable、TreeMap、LinkedHashMap、ConcurrentHashMap</li></ul></li><li>说下HashMap和Hashtable的区别？<ul><li>HashMap：底层是基于<strong>数组+链表+[ JDK8 红黑树]</strong>，非线程安全，默认容量是16，允许有null的键和值</li><li>Hashtable：底层是基于哈希表，线程安全（加了synchronized），默认容量是11，不允许有null的键和值</li></ul></li></ul><h2 id="2、hashCode和equals"><a href="#2、hashCode和equals" class="headerlink" title="2、hashCode和equals"></a>2、hashCode和equals</h2><p><strong>简介：在对象的比较、排重中hashcode和equals经常需要重写，也是map和set里面常用知识</strong></p><ul><li><p>考点：hashcode和equals掌握情况</p></li><li><p>介绍下对象的hashCode()和equals()，使用场景？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php">hashcode<br>顶级类<span class="hljs-keyword">Object</span>里面的方法，所有的类都是继承<span class="hljs-keyword">Object</span>,返回是一个<span class="hljs-keyword">int</span>类型的数值<br>根据一定的hash规则(存储地址，字段，长度等)，映射成一个数值，即散列值<br><br>equals<br>顶级类<span class="hljs-keyword">Object</span>里面的方法，所有的类都是继承<span class="hljs-keyword">Object</span>,返回是一个<span class="hljs-keyword">boolean</span>类型<br>根据自定义的匹配规则，用于匹配两个对象是否一样，一般逻辑如下<br>    <span class="hljs-comment">//判断地址是否一样</span><br>    <span class="hljs-comment">//非空判断和Class类型判断</span><br>    <span class="hljs-comment">//强转</span><br>    <span class="hljs-comment">//对象里面的字段一一匹配</span><br>    <br>使用场景：对象比较、或者集合容器里面排重、比较、排序<br></code></pre></td></tr></table></figure></li><li><p>代码实战：编写一个User对象，重写hashcode和equals方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">private</span> int age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Date</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setAge</span>(<span class="hljs-params">int age</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Date</span> <span class="hljs-function"><span class="hljs-title">getTime</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">Date</span> time</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.time = time;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age, time);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        User user = (User) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(name, user.name) &amp;&amp; age == user.age &amp;&amp; Objects.equals(time, user.time);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3、Java集合Map基础（下）"><a href="#3、Java集合Map基础（下）" class="headerlink" title="3、Java集合Map基础（下）"></a>3、Java集合Map基础（下）</h2><p><strong>简介：Java集合Map常见基础面试题</strong></p><ul><li><p>考点：Map相关基础知识掌握情况</p></li><li><p>HashMap和TreeMap之间如何选择？使用场景？</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">HashMap:</span> 散列桶(数组+链表+[JDK8红黑树])，可以实现快速的存储和检索，但缺点是包含无序的元素，适用于在Map中插入、删除和定位元素<br><br><span class="hljs-symbol">TreeMap:</span>使用存储结构是一个平衡二叉树-&gt;红黑树，可以自定义排序规则，向TreeMap的构造方法中传入Comparator对象来覆盖元素的默认排序规则<br>能便捷的实现内部元素的各种排序，但是性能一般比HashMap差，适用于自然排序或者自定义排序<br>(微信支付签名工具类就用TreeMap这个类)<br></code></pre></td></tr></table></figure></li><li><p>Set和Map的关系</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">核心是不会保存重复的元素，存储一组唯一的对象<br><br><span class="hljs-built_in">Set</span>的每一种实现都是对应<span class="hljs-built_in">Map</span>里面的一种封装<br><br>HashSet对应的就是HashMap<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashSet</span>(<span class="hljs-params"></span>)</span> &#123;<br>map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br><br>TreeSet对应的就是TreeMap<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">TreeSet</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,<span class="hljs-built_in">Object</span>&gt;());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>常见Map的排序规则是怎样的？</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">添加顺序：<span class="hljs-variable">LinkedHashMap</span><br>自然排序：<span class="hljs-variable">TreeMap</span><br>自定义排序：<span class="hljs-function"><span class="hljs-title">TreeMap</span>(<span class="hljs-variable">Comparator</span> <span class="hljs-variable">comparator</span>)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4、Java集合Map进阶"><a href="#4、Java集合Map进阶" class="headerlink" title="4、Java集合Map进阶"></a>4、Java集合Map进阶</h2><p><strong>简介：Java集合Map面试题进阶</strong></p><ul><li>考点：Map基础知识点的进阶</li><li>如果需要线程安全，且效率高的Map，应该如何做？<ul><li>方式一：concurrent包下的ConcurrentHashMap，不仅满足线程安全而且效率比Hashtable高</li><li>方式二：Collections.synchronizedMap(new HashMap&lt;&gt;());包装后返回的map是加了互斥锁的</li></ul></li></ul><h2 id="5、HashMap（上）"><a href="#5、HashMap（上）" class="headerlink" title="5、HashMap（上）"></a>5、HashMap（上）</h2><p><strong>简介：深入底层HashMap实现原理</strong></p><ul><li><p>考点：是否掌握HashMap的底层实现</p></li><li><p>介绍下HashMap的工作原理？</p><p>HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry接口）实现，HashMap 通过 put &amp; get 方法存储和获取。</p><p>存储对象时，将 K/V 键值传给 put() 方法：</p><p>①、<br>调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；</p><p>②、<br>调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；</p><p>③、<br>i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；</p><p>ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；</p><p>iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。</p><p>（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）</p><p>获取对象时，将 K 传给 get() 方法：<br>①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；<br>②、顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。</p><p>hashCode是定位的，存储位置；equals是定性的，比较两者是否相等。</p></li></ul><p>  HashMap调用Put(K key,V value)添加一个键值对的具体过程如下图所示：</p><p>  <img src="后端面试/image-1.png" alt="image-1"></p><p>  说明：</p><ol><li>size表示HashMap中K-V的实际数量，注意这个size不是数组的长度</li><li>threshold（临界值）= capacity（容量）* loadFactor（加载因子）这个值是当前已经占用数组长度的最大值，size超过这个临界值就会重新 resize()扩容 ，扩容后的HashMap容量是之前的2倍</li></ol><ul><li><p>能否解释下什么是Hash碰撞？常见的解决办法有哪些，HashMap采用哪种方法？</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Hash</span>碰撞：两个不同的<span class="hljs-built_in">Key</span>值经过计算后，得到的<span class="hljs-built_in">Hash</span>值相同，要放到相同的<span class="hljs-variable">bucket</span>中<br><br>解决方法：拉链法、开放地址法、再哈希法<br><br><span class="hljs-variable">HashMap</span>采用的拉链法<br></code></pre></td></tr></table></figure></li></ul><h2 id="6、HashMap（下）"><a href="#6、HashMap（下）" class="headerlink" title="6、HashMap（下）"></a>6、HashMap（下）</h2><p><strong>简介：深入底层HashMap实现原理</strong></p><ul><li><p>考点：是否掌握HashMap的底层实现</p></li><li><p>为什么HashMap底层要采用 数组+链表+红黑树</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">数组：<span class="hljs-variable">transient</span> <span class="hljs-variable">Node</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span><span class="hljs-variable">V</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">table</span><span class="hljs-operator">;</span>根据对象的<span class="hljs-variable">key</span>的<span class="hljs-variable">hash</span>值确定对象在哪个<span class="hljs-variable">bucket</span><br>链表：解决<span class="hljs-built_in">Hash</span>冲突，将<span class="hljs-built_in">Hash</span>值一样的对象存在一个链表中<br>红黑树：当位于同一个链表中的元素较多，即<span class="hljs-variable">hash</span>值相等的元素较多时，通过<span class="hljs-variable">key</span>值在链表中依次查找的效率很低。因此引入红黑树是为了提升查询效率，从原来的<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>到<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logn</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树而是当长度达到8才开始？<ul><li>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</li><li>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</li></ul></li></ul><h2 id="7、ConcurrentHashMap"><a href="#7、ConcurrentHashMap" class="headerlink" title="7、ConcurrentHashMap"></a>7、ConcurrentHashMap</h2><p><strong>简介：并发包里面ConcurrentHashMap面试题</strong></p><ul><li><p>考点：是否掌握并发包下的ConcurrentHashMap基础和原理</p></li><li><p>为什么 ConcurrentHashMap 比 HashTable 效率要高？</p><ul><li>HashTable：<ul><li>使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞</li></ul></li><li>ConcurrentHashMap：<ul><li>JDK1.7版本：ConcurrentHashMap的数据结构是由 Segment数组+HashEntry数组+链表组成。对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。Segment类继承ReentrantLock来保证线程安全。</li><li>JDK1.8版本：摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用CAS（读）和synchronized（写）来操作，锁粒度更细。</li></ul></li></ul></li><li><p>ConcurrentHashMap的put的核心逻辑（JDK8以上版本）</p><p><img src="后端面试/image-2.png" alt="image-2"></p></li></ul><h1 id="五、并发编程基础"><a href="#五、并发编程基础" class="headerlink" title="五、并发编程基础"></a>五、并发编程基础</h1><h2 id="1、进程、线程、协程"><a href="#1、进程、线程、协程" class="headerlink" title="1、进程、线程、协程"></a>1、进程、线程、协程</h2><p><strong>简介：是否掌握进程、线程、协程的区别</strong></p><ul><li><p>考点：是否掌握进程、线程、协程的区别</p></li><li><p>能否解释下什么是否掌握进程、线程、协程之间有什么联系和区别？</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">进程：进程是计算机中已运行程序的实体，是操作系统资源分配的最小单位<br><br>线程：线程是在进程中执行的一个任务，是<span class="hljs-variable">CPU</span>调度和执行的最小单位<br><br>协程：又称为微线程，是一种用户态的轻量级线程，协程不像线程和进程需要进行系统内核上的上下文切换，协程的上下文切换是由用户自己决定的，有自己的上下文，所以说是轻量级的线程，协程也称之为用户级别的线程，一个线程可以多个协程<span class="hljs-operator">,</span>线程进程都是同步机制，而协程则是异步<br><br>联系：一个进程至少有一个线程，一个进程可以有多个线程，多个线程可共享数据。<br><br>区别：进程和线程的本质区别在于是否单独占有内存地址空间及其它系统资源（比如<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>）<br>进程单独占有一定的内存地址空间；线程共享所属进程占有的内存地址空间和资源<br></code></pre></td></tr></table></figure></li><li><p>协程对于多线程的优缺点是什么？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">优点：<br>    非常快速的上下文切换，不用系统内核的上下文切换，减小开销<br>    单线程即可实现高并发，单核CPU可以支持上万的协程<br>    由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁<br>缺点：<br>    协程无法利用多核资源，本质也是个单线程<br>    协程需要和进程配合才能运行在多CPU上<br>    目前<span class="hljs-keyword">java没成熟的第三方库，存在风险</span><br><span class="hljs-keyword"></span>    调试<span class="hljs-built_in">debug</span>存在难度，不利于发现问题<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、并发、并行、串行"><a href="#2、并发、并行、串行" class="headerlink" title="2、并发、并行、串行"></a>2、并发、并行、串行</h2><p><strong>简介：是否知道并发、并行、串行的区别</strong></p><ul><li><p>考点：计算机基础中并发、并行、串行的概念</p></li><li><p>说下并发、并行、串行的区别，最好举例说明</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">并发：多个任务在同一个CPU核上，按细分的时间片段轮流（交替）执行，从逻辑上来看那些任务是“同时进行”。【两个人用一台电脑】<br><br>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。【两个人分配了两台电脑】<br><br>串行：有<span class="hljs-built_in">n</span>个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全的情况，也就不存在临界区的问题。【两个人排队使用一台电脑】<br></code></pre></td></tr></table></figure><p><img src="后端面试/image-3.png" alt="image-3"></p></li></ul><h2 id="3、Java多线程的实现方式"><a href="#3、Java多线程的实现方式" class="headerlink" title="3、Java多线程的实现方式"></a>3、Java多线程的实现方式</h2><p><strong>简介：Java多线程的实现方式和区别</strong></p><ul><li><p>考点：Java多线程基础知识</p></li><li><p>Java里面实现多线程有哪几种方式，比较常用的是哪些？</p><ol><li><p>继承Thread类</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Thread类本质上也是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start<span class="hljs-literal">()</span>方法。start<span class="hljs-literal">()</span>方法是一个native方法，它将启动一个新线程，并执行run<span class="hljs-literal">()</span>方法<br>优点：代码编写简单直接操作<br>缺点：没返回值，继承一个类后，没法继承其他的类，拓展性差<br><br>public <span class="hljs-keyword">class</span> ThreadDemo01 extends Thread&#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;继承Thread类实现多线程，线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>&#125;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    ThreadDemo01 threadDemo01 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo01()</span>;<br>    threadDemo01.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;demo01&quot;</span>)</span>;<br>    threadDemo01.start<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现Runnable接口<strong>【常用】</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">实现Runnable接口并实现其中的run<span class="hljs-literal">()</span>方法，然后通过构造Thread实例，传入Runnable实现类，然后调用Thread的start<span class="hljs-literal">()</span>方法即可开启一个新线程<br>优点：线程类可以实现多个接口，可以再继承一个类<br>缺点：没返回值，不能直接启动，需要通过构造一个Thread实例再传入Runnable实现类进去启动<br><br>public <span class="hljs-keyword">class</span> ThreadDemo02 implements Runnable&#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;实现Runnable接口实现多线程，线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>&#125;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    ThreadDemo02 threadDemo02 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo02()</span>;<br>    Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">threadDemo02</span>)</span>;<br>    thread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;demo02&quot;</span>)</span>;<br>    thread.start<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>匿名内部类</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">JDK8之后采用lambda表达式<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>Thread thread = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;匿名内部类实现多线程，线程名称：&quot;</span> + Thread.currentThread().getName());</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">thread</span>.<span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-string">&quot;demo03&quot;</span>)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">thread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;主线程名称：&quot;</span> + Thread.currentThread().getName())</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>实现Callable接口通过FutureTask包装器</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs livescript">首先需要一个实现Callable接口的实例，然后实现该接口的唯一方法call逻辑，接着把Callable实例包装成FutureTask传递给Thread实例启动新线程。FutureTask本质上也实现了Runnable接口，所以同样可以用来构造Thread实例。<br>优点：有返回值，拓展性高<br>缺点：JDK5以后才支持，需要重写call方法，结合多个类比如FutureTask和Thread类<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-title">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Object</span>&gt; &#123;</span><br>    @Override<br>    public <span class="hljs-built_in">Object</span> call() throws Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;实现Callable接口实现多线程，线程名称：&quot;</span>+Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是返回值&quot;</span>;<br>    &#125;<br>&#125;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br><br><span class="hljs-regexp">// MyTask myTask = new MyTask();</span><br><span class="hljs-regexp">//</span> FutureTask&lt;<span class="hljs-built_in">Object</span>&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myTask);<br><br>FutureTask&lt;<span class="hljs-built_in">Object</span>&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;实现Callable接口实现多线程，线程名称：&quot;</span> + Thread.currentThread().getName());</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是返回值&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Thread</span> <span class="hljs-title">thread</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(futureTask)</span>;</span><br><span class="hljs-function"><span class="hljs-title">thread</span>.<span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-string">&quot;demo04&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">thread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;主线程名称：&quot;</span> + Thread.currentThread().getName())</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(futureTask.get())</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">        //阻塞等待中被中断，则抛出</span><br><span class="hljs-function">        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(ExecutionException e)</span> &#123;</span><br><span class="hljs-function">        //执行过程发送异常被抛出</span><br><span class="hljs-function">        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>通过线程池<strong>【常用】</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">自定义Runnable接口，实现run方法，创建线程池，调用执行方法并传入对象<br>优点：安全、性能高，因为复用了线程<br>缺点：JDK5以后才支持，需要结合Runnable进行使用<br><br>public <span class="hljs-keyword">class</span> ThreadDemo05 implements Runnable&#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;通过线程池实现多线程，线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>&#125;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(3)</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo05()</span>);<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    <span class="hljs-comment">//关闭线程池</span><br>    executorService.shutdown<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4、Java线程的状态"><a href="#4、Java线程的状态" class="headerlink" title="4、Java线程的状态"></a>4、Java线程的状态</h2><p><strong>简介：线程有几种状态有哪些，分别解释下</strong></p><ul><li><p>考点：是否掌握线程常见的状态</p></li><li><p>操作系统中的线程状态有哪些？</p><ol><li><strong>新建状态 NEW</strong>: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</li><li><strong>就绪状态 RUNNABLE</strong>: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li><li><strong>运行状态: RUNNING</strong> 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li><li><strong>阻塞状态: BLOCKED</strong>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，该线程会释放占⽤的所有资源，JVM会把该线程放入“等待池”中。进⼊这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被 唤醒，wait是object类的方法</li><li>同步阻塞：线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)，则JVM会把该线程放入“锁池”中。</li><li>其他阻塞：运⾏的线程执行 sleep() 或 join() 发出了 I/O请求时，JVM会把该线程置为阻塞状 态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态，sleep是Thread类的方法。</li></ul></li><li><strong>死亡状态: TERMINATED</strong> 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li></ol><p><img src="后端面试/image-4.png" alt="image-4"></p></li><li><p>Java中Thread对象的状态有哪些？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">public enum State &#123;<br>    NEW,<span class="hljs-regexp">//</span>新建态<br>    RUNNABLE,<span class="hljs-regexp">//</span>运行态<br>    BLOCKED,<span class="hljs-regexp">//</span>阻塞态<br>    WAITING,<span class="hljs-regexp">//</span>等待态<br>    TIMED_WAITING,<span class="hljs-regexp">//</span>有时间限制的等待态<br>    TERMINATED;<span class="hljs-regexp">//</span>死亡态<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="后端面试/image-5.png" alt="image-5"></p></li></ul><ol><li><p>NEW 新建态：</p><p>处于NEW状态的线程此时尚未启动，还没调用Thread实例的start()方法。</p></li><li><p>RUNNABLE 运行态：</p><p>表示当前线程正在运行中。处于RUNNABLE状态的线程可能在Java虚拟机中运行，也有可能在等待其他系统资源（比如I/O）。</p><p>Java线程的<strong>RUNNABLE</strong>状态其实是包括了传统操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态的</p></li><li><p>BLOCKED 阻塞态：</p><p>线程没有申请到synchronize同步锁，就会处于阻塞状态，等待锁的释放以进入同步区。</p></li><li><p>WAITING 等待态：处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</p><p>调用如下3个方法会使线程进入等待状态：</p><ul><li>Object.wait()：使当前线程处于等待状态直到另一个线程调用notify唤醒它；</li><li>Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait()方法；</li><li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。</li></ul></li><li><p>TIMED_WAITING 超时等待态：</p><p>线程等待一个具体的时间，时间到后会被自动唤醒。</p><p>调用如下方法会使线程进入超时等待状态：</p><ul><li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li><li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li><li>Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li><li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li></ul></li><li><p>TERMINATED 终止：</p><p>此时线程已执行完毕。</p></li></ol><h2 id="5、Java线程的常见方法"><a href="#5、Java线程的常见方法" class="headerlink" title="5、Java线程的常见方法"></a>5、Java线程的常见方法</h2><p><strong>简介：Java线程常见的方法</strong></p><ul><li><p>考点：常见线程的API操作是否熟悉</p></li><li><p>是否了解多线程开发里面常用的方法，sleep/yield/join wait/notify/notifyAll, 分别解释下</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">sleep</span><br>属于线程Thread的方法<br>让线程暂缓执行，等待时间结束后再恢复<br>交出CPU使用权，不会释放锁<br>进入阻塞状态TIMED_WAITING，睡眠结束后变为就绪状态RUNNABLE<br><br>yield<br>属于线程Thread的方法<br>暂停当前线程的对象，去执行其他线程<br>交出CPU使用权，不会释放锁，和<span class="hljs-keyword">sleep</span>类似<br>让相同优先级的线程轮流执行，但是不保证每个线程都一定能轮到<br>不会让线程进入阻塞状态，而是直接变为就绪状态，但是保留了CPU的执⾏资格，所以有可能cpu下次进⾏线程调度还会让这个线程获取到执⾏权继续执⾏<br><br><span class="hljs-keyword">join</span><br>属于线程Thread的方法<br>在主线程上运行调用该方法，会让主线程休眠，不会释放已经持有的对象锁<br>让调用<span class="hljs-keyword">join</span>方法的线程先执行完毕，再执行其他线程<br>类似让救护车、警车优先通行<br><br><span class="hljs-keyword">wait</span><br>属于Object的方法<br>当前线程调用对象的<span class="hljs-keyword">wait</span>方法，会释放锁，进入线程的等待队列<br>需要依靠notify、notifyAll唤醒，或者<span class="hljs-keyword">wait</span>(timeout)自动唤醒<br><br>notify<br>属于Object的方法<br>唤醒在对象监视器上等待的单个线程，选择是任意的<br><br>notifyAll<br>属于Object的方法<br>唤醒在对象监视器上等待的全部线程<br></code></pre></td></tr></table></figure></li></ul><h2 id="6、Java线程的转换流程图"><a href="#6、Java线程的转换流程图" class="headerlink" title="6、Java线程的转换流程图"></a>6、Java线程的转换流程图</h2><p><strong>简介：线程有几种状态和API，画出转换流程图</strong></p><ul><li><p>考点：常见线程状态和API结合考查</p></li><li><p>画下线程的状态转换图和这些转换过程常用的api也标记下</p><p><img src="后端面试/image-6.png" alt=""></p></li></ul><h2 id="7、Java并发编程核心知识点（一）"><a href="#7、Java并发编程核心知识点（一）" class="headerlink" title="7、Java并发编程核心知识点（一）"></a>7、Java并发编程核心知识点（一）</h2><p><strong>简介：并发编程常见知识点考查</strong></p><ul><li><p>考点：并发编程常见知识点考查</p></li><li><p>平时业务代码里面使用过多线程吗，能举例几个多线程的业务场景吗？</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">异步任务：用户注册、记录日志<br>定时任务：定时备份日志、备份数据库<br>分布式计算：Hadoop处理任务MapReduce，<span class="hljs-literal">master</span>-worker<br>服务器编程：Socket网络编程，一个连接一个线程<br></code></pre></td></tr></table></figure></li><li><p>你知道有哪些非线程安全的数据结构吗？</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">HashMap</span>、ArrayList、LinkedList<br></code></pre></td></tr></table></figure></li><li><p>在Java中有哪些方法可以用来保证线程安全？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">加锁：<span class="hljs-keyword">synchronized</span>、ReentrantLock<br>使用线程安全类（原子类AtomicXXX、并发容器、同步容器）CopyOnWriteArrayList/ConcurrentHashMap等<br>ThreadLocal本地私有变量/信号量Semaphore等<br>使用<span class="hljs-keyword">volatile</span>声明变量（要使 <span class="hljs-keyword">volatile</span> 变量提供理想的线程安全性，必须同时满足两个条件：①对变量的写操作不依赖于当前值。②该变量没有包含在具有其他变量的不变式中。）<br></code></pre></td></tr></table></figure></li></ul><h2 id="8、Java并发编程核心知识点（二）"><a href="#8、Java并发编程核心知识点（二）" class="headerlink" title="8、Java并发编程核心知识点（二）"></a>8、Java并发编程核心知识点（二）</h2><p><strong>简介：并发编程常见知识点考查</strong></p><ul><li><p>考点：并发编程常见知识点考查</p></li><li><p>了解volatile关键字不？能否解释下它和synchronized有什么大的区别？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">volatile</span>是轻量级的<span class="hljs-keyword">synchronized</span>，保证被<span class="hljs-keyword">volatile</span>修饰的共享变量对所有线程总是可⻅的（可见性），也就是当⼀个线程修改了⼀个被<span class="hljs-keyword">volatile</span>修饰共享变量的值，新值总是可以被其他线程⽴即得知，避免出现脏读现象。<br><br><span class="hljs-keyword">volatile</span>：保证可见性，但不能保证原子性<br><span class="hljs-keyword">synchronized</span>：保证可见性，也保证原子性<br><br>使用场景：<br><span class="hljs-number">1</span>、不能修饰写入操作依赖当前值的变量；比如num++、num=num+<span class="hljs-number">1</span>，不是原子操作，虽然肉眼看上去是，但在JVM字节码层面不是原子操作<br><span class="hljs-number">2</span>、由于禁止了指令重排，所以JVM相关的优化没有了，效率会偏弱<br></code></pre></td></tr></table></figure></li><li><p>为什么会出现脏读现象？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JAVA内存模型简称JMM</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">JMM规定所有的变量存在主内存中，每个线程都有自己的工作内存,线程对变量的操作都在工作内存中进行，不能直接对主内存就行操作</span><br><span class="hljs-keyword"></span><br>使用volatile修饰变量<br>每次读取前必须从主内存获取到最新的值<br>每次写入需要立刻写到主内存中<br></code></pre></td></tr></table></figure><p><img src="后端面试/image-7.png" alt="image-7"></p></li></ul><h2 id="9、Java并发编程核心知识点（三）"><a href="#9、Java并发编程核心知识点（三）" class="headerlink" title="9、Java并发编程核心知识点（三）"></a>9、Java并发编程核心知识点（三）</h2><p><strong>简介：并发编程常见知识点考查：指令重排、happens-before</strong></p><ul><li><p>考点：并发编程常见知识点考查</p></li><li><p>你说volatile可以避免指令重排，能否解释下什么是指令重排？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">指令重排序分两类：编译器重排序、运行时重排序<br><br>JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(在不改变程序结果的前提下)<br><br>例子：<br><span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span> <span class="hljs-comment">//1</span><br><span class="hljs-built_in">int</span> b = <span class="hljs-number">4</span> <span class="hljs-comment">//2</span><br><span class="hljs-built_in">int</span> c =<span class="hljs-number">5</span> <span class="hljs-comment">//3 </span><br><span class="hljs-built_in">int</span> h = a*b*c <span class="hljs-comment">//4</span><br><br>定义顺序 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span><br>计算顺序 <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span> 和 <span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> 结果都是一样<br><br>虽然指令重排序可以提高执行效率，但是多线程上可能会影响结果，有什么解决办法？<br><br>解决办法：内存屏障<br>解释：内存屏障就是一类同步屏障指令，是CPU或者编译器在对内存随机访问的操作中的一个同步点，只有在此点之前的所有读写操作都执行后才可以执行此点之后的操作<br></code></pre></td></tr></table></figure></li><li><p>知道 happens-before吗，能否简单解释下？</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">先行发生原则，<span class="hljs-variable">volatile</span>的内存可见性就提现了该原则之一<br><br>例子：<br><span class="hljs-operator">//</span>线程<span class="hljs-variable">A</span>操作<br><span class="hljs-variable">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br><br><span class="hljs-operator">//</span>线程<span class="hljs-variable">B</span>操作<br><span class="hljs-variable">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-variable">k</span><span class="hljs-operator">;</span><br><br><span class="hljs-operator">//</span>线程<span class="hljs-built_in">C</span>操作<br><span class="hljs-variable">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><br>分析：<br>假设线程<span class="hljs-variable">A</span>中的操作“<span class="hljs-variable">k</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>”先行发生于线程<span class="hljs-variable">B</span>的操作“<span class="hljs-variable">j</span><span class="hljs-operator">=</span><span class="hljs-variable">k</span>”，那确定在线程<span class="hljs-variable">B</span>的操作执行后，变量<span class="hljs-variable">j</span>的值一定等于<span class="hljs-number">1</span>，依据有两个：一是先行发生原则，“<span class="hljs-variable">k</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>”的结果可以被观察到；二是第三者线程<span class="hljs-built_in">C</span>还没出现，线程<span class="hljs-variable">A</span>操作结束之后没有其他线程会修改变量<span class="hljs-variable">k</span>的值。<br><br>但是考虑线程<span class="hljs-built_in">C</span>出现了，保持线程<span class="hljs-variable">A</span>和线程<span class="hljs-variable">B</span>之间的先行发生关系，线程<span class="hljs-built_in">C</span>出现在线程<span class="hljs-variable">A</span>和线程<span class="hljs-variable">B</span>的操作之间，但是线程<span class="hljs-built_in">C</span>与线程<span class="hljs-variable">B</span>没有先行发生关系，那<span class="hljs-variable">j</span>的值会是多少？答案是<span class="hljs-number">1</span>和<span class="hljs-number">2</span>都有可能，因为线程<span class="hljs-built_in">C</span>对变量<span class="hljs-variable">k</span>的影响可能会被线程<span class="hljs-variable">B</span>观察到，也可能不会，所以线程<span class="hljs-variable">B</span>就存在读取到不符合预期数据的风险，不具备多线程安全性<br><br>先行发生的八大原则：<br><span class="hljs-number">1</span>、程序次序规则（<span class="hljs-variable">Program</span> <span class="hljs-built_in">Order</span> <span class="hljs-built_in">Rule</span>）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作；<br><span class="hljs-number">2</span>、管程锁定规则（<span class="hljs-built_in">Monitor</span> <span class="hljs-variable">Lock</span> <span class="hljs-built_in">Rule</span>）：一个<span class="hljs-variable">unlock</span>操作先行发生于后面对同一个锁的<span class="hljs-variable">lock</span>操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后；<br><span class="hljs-number">3</span>、<span class="hljs-variable">volatile</span>变量规则（<span class="hljs-variable">Volatile</span> <span class="hljs-variable">Variable</span> <span class="hljs-built_in">Rule</span>）：对一个<span class="hljs-variable">volatile</span>变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后；<br><span class="hljs-number">4</span>、线程启动规则（<span class="hljs-built_in">Thread</span> <span class="hljs-variable">Start</span> <span class="hljs-built_in">Rule</span>）：<span class="hljs-built_in">Thread</span>对象的<span class="hljs-variable">start</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法先行发生于此线程的每一个动作；<br><span class="hljs-number">5</span>、线程终止规则（<span class="hljs-built_in">Thread</span> <span class="hljs-variable">Termination</span> <span class="hljs-built_in">Rule</span>）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过<span class="hljs-built_in">Thread</span><span class="hljs-string">::join</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法是否结束、<span class="hljs-built_in">Thread</span><span class="hljs-string">::isAlive</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>的返回值等手段检测线程是否已经终止执行；<br><span class="hljs-number">6</span>、线程中断规则（<span class="hljs-built_in">Thread</span> <span class="hljs-variable">Interruption</span> <span class="hljs-built_in">Rule</span>）：对线程<span class="hljs-variable">interrupt</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过<span class="hljs-built_in">Thread</span><span class="hljs-string">::interrupted</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法检测到是否有中断发生；<br><span class="hljs-number">7</span>、对象终结规则（<span class="hljs-variable">Finalizer</span> <span class="hljs-built_in">Rule</span>）：一个对象的初始化完成（构造函数执行结束）先行发生于它的<span class="hljs-variable">finalize</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法的开始；<br><span class="hljs-number">8</span>、传递性（<span class="hljs-variable">Transitivity</span>）：如果操作<span class="hljs-variable">A</span>先行发生于操作<span class="hljs-variable">B</span>，操作<span class="hljs-variable">B</span>先行发生于操作<span class="hljs-built_in">C</span>，那就可以得出操作<span class="hljs-variable">A</span>先行发生于操作<span class="hljs-built_in">C</span>的结论。<br></code></pre></td></tr></table></figure></li></ul><h1 id="六、并发编程进阶"><a href="#六、并发编程进阶" class="headerlink" title="六、并发编程进阶"></a>六、并发编程进阶</h1><h2 id="1、并发编程三要素"><a href="#1、并发编程三要素" class="headerlink" title="1、并发编程三要素"></a>1、并发编程三要素</h2><p><strong>简介: 常见的并发编程三要素</strong></p><ul><li><p>考点：考查是否知道并发编程三要素</p></li><li><p>并发编程三要素是否知道，能否分别解释下，举个简单的例子？</p><p>并发编程三要素分别是：原子性、可见性、有序性</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs gradle">原子性：<br>在⼀个操作中cpu不可以在中途暂停然后再调度，即不能被中断操作，要么全部执⾏完成，要么都不执⾏。就好⽐转账，从账户A向账户B转<span class="hljs-number">1000</span>元，那么必然包括<span class="hljs-number">2</span>个操作：从账户A减去<span class="hljs-number">1000</span>元，往账户B加上<span class="hljs-number">1000</span>元。两个操作必须全部完成。<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> calc() &#123;<br><span class="hljs-keyword">count</span>++; <span class="hljs-comment">//非原子性，除非用原子类，即java.util.concurrent.atomic里的原子变量类</span><br>&#125;<br><br>操作步骤：<br><span class="hljs-number">1</span>：将 <span class="hljs-keyword">count</span> 从主存读到⼯作内存中的副本中<br><span class="hljs-number">2</span>：进行+<span class="hljs-number">1</span>的运算<br><span class="hljs-number">3</span>：将结果写⼊⼯作内存<br><span class="hljs-number">4</span>：将⼯作内存的值刷回主存(什么时候刷⼊由操作系统决定，不确定的)<br><br>解决办法：<br>解决办法是可以用<span class="hljs-keyword">synchronized</span>或Lock(比如ReentrantLock)来把这个多步操作“变成”原子操作，但是不能用<span class="hljs-keyword">volatile</span>，因为前面有说到<span class="hljs-keyword">volatile</span>不能修饰有依赖值的情况。<br><br>核心思想：<br>把一个方法或者代码块看做一个整体，保证是一个不可分割的整体。<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 并发编程三要素之原子性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @author LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> demo01 &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//使用synchronized，保证方法被锁住</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> calc01() &#123;<br>        <span class="hljs-keyword">count</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">//使用lock，保证代码块被锁住，每个对象都是有锁，只有获得这个锁才可以进行对应的操作</span><br>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> calc02() &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">count</span>++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>  <br>&#125;<br>关键字：<span class="hljs-keyword">synchronized</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">有序性：<br>程序执行的顺序按照代码的先后顺序执行，因为处理器可能会对指令进行重排序<br>JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(在不改变程序结果的前提下)<br><br>int a = <span class="hljs-number">3</span> <span class="hljs-regexp">//</span><span class="hljs-number">1</span><br>int b = <span class="hljs-number">4</span> <span class="hljs-regexp">//</span><span class="hljs-number">2</span><br>int c =<span class="hljs-number">5</span> <span class="hljs-regexp">//</span><span class="hljs-number">3</span> <br>int h = a*b*c <span class="hljs-regexp">//</span><span class="hljs-number">4</span><br><br>上面的例子 执行顺序<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> 和 <span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> 结果都是一样，指令重排序可以提高执行效率，但是多线程上可能会影响结果<br><br>假如下面的场景，正常是顺序处理<br><span class="hljs-regexp">//</span>线程<span class="hljs-number">1</span><br>before();<span class="hljs-regexp">//</span>处理初始化工作，处理完成后才可以正式运行下面的run方法<br>flag = true; <span class="hljs-regexp">//</span>标记资源处理好了，如果资源没处理好，此时程序就可能出现问题<br><span class="hljs-regexp">//</span>线程<span class="hljs-number">2</span><br><span class="hljs-keyword">while</span>(flag)&#123;<br>    run(); <span class="hljs-regexp">//</span>核心业务代码<br>&#125;<br><br>指令重排序后，导致顺序换了，程序出现问题，且难排查<br><br><span class="hljs-regexp">//</span>线程<span class="hljs-number">1</span><br>flag = true; <span class="hljs-regexp">//</span>标记资源处理好了，如果资源没处理好，此时程序就可能出现问题<br><span class="hljs-regexp">//</span>线程<span class="hljs-number">2</span><br><span class="hljs-keyword">while</span>(flag)&#123;<br>    run(); <span class="hljs-regexp">//</span>核心业务代码<br>&#125;<br>before();<span class="hljs-regexp">//</span>处理初始化工作，处理完成后才可以正式运行下面的run方法<br><br>关键字：volatile、synchronized<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart">可见性：<br>一个线程A对共享变量的修改,另一个线程B能够立刻看到<br><br><span class="hljs-comment">// 线程 A 执行</span><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 线程 A 执行</span><br><span class="hljs-built_in">num</span>++;<br><span class="hljs-comment">// 线程 B 执行</span><br>System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num的值：&quot;</span> + <span class="hljs-built_in">num</span>);<br><br>线程A执行 <span class="hljs-built_in">num</span>++ 后再执行线程 B，线程 B可能有<span class="hljs-number">2</span>个结果，可能是<span class="hljs-number">0</span>和<span class="hljs-number">1</span>。<br><br>原因是 <span class="hljs-built_in">num</span>++ 在线程A中执行运算，并没有立刻更新到主内存当中，而线程B就去主内存当中读取并打印，此时打印的就是<span class="hljs-number">0</span>；<br>也可能线程A执行完成更新到主内存了,线程B的值是<span class="hljs-number">1</span>。<br>所以需要保证线程的可见性<br><br>关键字：volatile、synchronized、<span class="hljs-keyword">final</span><br></code></pre></td></tr></table></figure><p>volatile本身就包含了禁止指令重排序的语义，而synchronized关键字是由“⼀个变量在同⼀时刻只允许⼀条线程对其进行lock操作”这条规则明确的。</p><p>synchronized关键字同时满足以上三种特性，但是volatile关键字不满足原子性。</p><p>在某些情况下，volatile的同步机制的性能确实要优于锁(使⽤synchronized关键字或 java.util.concurrent包⾥⾯的锁)，因为volatile的总开销要比锁低。 </p><p>我们判断使用volatile还是加锁的唯⼀依据就是volatile的语义能否满足使用的场景(原子性)</p></li></ul><h2 id="2、常见进程-线程调度算法"><a href="#2、常见进程-线程调度算法" class="headerlink" title="2、常见进程/线程调度算法"></a>2、常见进程/线程调度算法</h2><p><strong>简介: 常见的进程、线程间调度算法</strong></p><ul><li><p>考点：考查是否知道常见进程和线程间的调度算法</p></li><li><p>说下你知道的调度算法，比如进程间的调度？</p><ol><li><p>先来先服务调度算法：</p><p>​    按照作业/进程到达的先后顺序进行调度，即：优先考虑在系统中等待时间最长的作业</p><p>​    排在长进程后的短进程的等待时间长，不利于短作业/进程</p></li><li><p>短作业优先调度算法：</p><p>​    短进程/作业（要求服务时间最短）在实际情况中占有很大比例，为了使他们优先执行</p><p>​    对长作业不友好</p></li><li><p>高响应比优先调度算法：</p><p>​    在每次调度时，先计算各个作业的优先权；</p><p>​    优先权=响应比=（等待时间+要求服务时间）/要求服务时间=总响应时间/要求服务时间</p><p>​    选择优先权高的进行服务，需要计算优先权信息，增加了系统的开销</p></li><li><p>时间片轮转调度算法：</p><p>​    轮流为的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p><p>​    由于高频率的进程切换，会增加开销，且不区分任务的紧急程度</p></li><li><p>优先级调度算法：</p><p>​    根据任务的紧急程度进行调度，高优先级的先处理，低优先级的慢处理</p><p>​    如果高优先级任务很多且持续产生，那么低优先级的就可能很慢才被处理</p></li></ol></li><li><p>常见的线程间的调度算法是怎样的？Java是哪种？</p><p>​    线程调度是指系统为线程分配CPU使用权的过程，主要分为两种：</p><ol><li><p>协同式线程调度（分时调度）：</p><p>线程执行时间由线程本身来控制，线程把自己的工作执行完成后，要主动通知系统切换到另外一个线程上。</p><ul><li>好处：实现简单，且切换操作对线程自己是可知的，没有线程同步问题</li><li>坏处：线程执行时间是不可控的，如果一个线程有问题，可能一直堵塞在那里</li></ul></li><li><p>抢占式线程调度：</p><p>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中的Thread.yield()可以让出执行时间，但无法获取执行时间），线程执行时间是可控，也不会有一个线程导致整个进程堵塞</p></li></ol><p><strong>Java线程调度就是采取抢占式调度</strong>，优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那就随机选择一个线程。</p></li></ul><p>如果希望某些线程多分配一些时间，而某些线程少分配一些时间，可以通过设置优先级来完成。Java线程的优先级可以指定整数1到10，当多个线程运行时，VM一般会优先运行高优先级的线程（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）</p><p>在两个线程同时处于就绪Runnable状态时，优先级越高的线程越容易被执行。但不是优先级高就一定会先执行，只是机会越大而已。</p><p>有人会说 wait、notify不就是线程本身控制的么？</p><p>其实不是，wait是可以让出执行时间，notify之后无法获取执行时间，随机等待队列里面获取而已</p><h2 id="3、java多线程里面常用的锁"><a href="#3、java多线程里面常用的锁" class="headerlink" title="3、java多线程里面常用的锁"></a>3、java多线程里面常用的锁</h2><ul><li><p>考点：考查对常见的锁是否掌握</p></li><li><p>你日常开发里面用过java里面有哪些锁？分别解释下？</p><ul><li><p>悲观锁：</p><p>​    当线程去操作数据的时候，总认为别的线程会去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞，比如synchronized</p><p>​    悲观锁适用于<strong>写操作多</strong>的场景</p></li><li><p>乐观锁：</p><p>​    每次去拿数据的时候都认为别人不会修改，只有更新的时候会判断别人是否更新了数据，通过版本来判断，如果数据被更改了就拒绝更新，比如CAS（但严格来说并不是锁，而是通过原子性来保证数据的同步，比如数据库的乐观锁，通过版本控制来实现，CAS不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响）</p><p>​    乐观锁适用于<strong>读操作多</strong>的场景，乐观锁的吞吐量会比悲观锁多</p></li><li><p>公平锁：</p><p>​    指多个线程按照申请锁的顺序来获取锁，简单来说，一个线程组里能保证每个线程都能拿到锁，比如ReentrantLock（底层是同步队列 FIFO:First Input First Output来实现）</p></li><li><p>非公平锁：</p><p>​    获取锁的方式是随机的，保证不了每个线程都能拿到锁，比如synchronized、ReentrantLock</p><p>​    非公平锁<strong>性能高于</strong>公平锁，更能重复利用CPU的时间</p></li><li><p>可重入锁：</p><p>​    也叫递归锁，指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，不会发生死锁，比如synchronized、ReentrantLock</p><p>​    可重入锁能在一定程度上<strong>避免死锁</strong></p></li><li><p>不可重入锁：</p><p>​    若当前线程执行某个方法时已经获取了该锁，那么在方法中尝试再次获取锁时就无法获取而是被阻塞</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>&#123;<br><span class="hljs-comment">//获取锁 TODO</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>&#123;<br><span class="hljs-comment">//获取锁 TODO</span><br>    <span class="hljs-comment">//其他操作</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自旋锁：</p><p>​    一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够成功获取锁，直到获取锁时才会退出循环，任何时刻最多只有一个执行单元获得锁，比如TicketLock、CLHLock、MSCLock</p><p>​    不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU</p></li><li><p>共享锁：</p><p>​    也叫S锁/读锁，只能查看而无法修改和删除的一种锁，加锁后其他用户可以并发读取、查询数据，但不能修改、增加、删除数据，该锁可以被多个线程持有，用于资源数据共享</p></li><li><p>互斥锁：</p><p>​    也叫X锁/排他锁/写锁/独占锁/独享锁，获得互斥锁的线程既能读数据又能修改数据，该锁每次只能被一个线程持有，加锁后任何试图再次加锁的线程都会被堵塞，直到当前线程解锁</p></li><li><p>死锁：</p><p>​    两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法让程序继续进行下去</p></li></ul></li></ul><p>  下面三种是JVM为了提高锁的获取与释放效率而做的优化，针对Synchronized的锁升级，锁的状态是通过对象监视器在对象头中的字段来表明，是不可逆的过程</p><ul><li><p>偏向锁：</p><p>​    一段同步代码一直被一个线程访问，那么该线程会自动获取锁，获取锁的代价更低</p></li><li><p>轻量级锁：</p><p>​    当锁是偏向锁的时候，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，但不会阻塞，而且性能会更高</p></li><li><p>重量级锁:</p><p>​    当锁为轻量级锁的时候，其他线程虽然是自旋，但自旋不会一直循环下去，当自旋一定次数的时候还没有获取到锁，就会进入阻塞，该锁升级为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能也会降低</p></li></ul><h2 id="4、多线程死锁"><a href="#4、多线程死锁" class="headerlink" title="4、多线程死锁"></a>4、多线程死锁</h2><ul><li><p>考点：考查对常见的死锁是否掌握</p></li><li><p>上机实战：写一个多线程死锁的例子</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="后端面试/image-8.png" alt=""></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> DeadLockDemo &#123;<br>    <span class="hljs-keyword">private</span> static Object resource1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> static Object resource2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//资源 2</span><br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>            synchronized (resource1) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>                &#125; catch (InterruptedException e) &#123;<br>                    e.print<span class="hljs-constructor">StackTrace()</span>;<br>                &#125;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                synchronized (resource2) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>            synchronized (resource2) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>                &#125; catch (InterruptedException e) &#123;<br>                    e.print<span class="hljs-constructor">StackTrace()</span>;<br>                &#125;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                synchronized (resource1) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>产生死锁的四个必要条件？</p><ol><li><p>互斥条件：</p><p>​    资源不能共享，该资源任意一个时刻只能由一个线程占用</p></li><li><p>请求与保持条件：</p><p>​    一个线程因请求其他资源而发生阻塞时，对已获得的资源保持不释放</p></li><li><p>不剥夺条件：</p><p>​    线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有等自己使用完毕后才会释放资源</p></li><li><p>循环等待条件：</p><p>​    多个线程之间形成一种头尾相接的循环等待资源关系，每个线程都占用对方需要申请的下个资源</p></li></ol></li></ul><p>  只要发生死锁，以上四个条件都成立；只要有其中一个不满足，就不会发生死锁。</p><ul><li><p>如何预防和避免线程死锁？</p><ul><li><p><strong>如何预防死锁？</strong>破坏死锁产生的必要条件即可：</p><ul><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：依靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul></li><li><p><strong>如何避免死锁？</strong></p><ul><li>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</li></ul></li></ul></li></ul><blockquote><p><strong>安全状态</strong>：指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。</p></blockquote><p>我们对（线程 2） 的代码修改成下面这样就不会产生死锁了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>    synchronized (resource1) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>        synchronized (resource2) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">2</span><br><br><span class="hljs-attribute">Process</span> finished with exit code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>我们分析一下上面的代码为什么避免了死锁的发生?</p><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><h2 id="5、多线程不可重入锁"><a href="#5、多线程不可重入锁" class="headerlink" title="5、多线程不可重入锁"></a>5、多线程不可重入锁</h2><ul><li><p>考点：考查对常见的不可重入锁是否掌握</p></li><li><p>上机实战：设计一个简单的不可重入锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">不可重入锁：<br>若当前线程执行某个方法时已经获取了该锁，那么在方法中尝试再次获取锁时就无法获取而是被阻塞<br><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>&#123;<br><span class="hljs-comment">//获取锁 TODO</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>&#123;<br><span class="hljs-comment">//获取锁 TODO</span><br>    <span class="hljs-comment">//其他操作</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> UnreentrantLock &#123;<br><br>    <span class="hljs-keyword">private</span> boolean isLocked = <span class="hljs-literal">false</span>;<br><br>    public synchronized void lock<span class="hljs-literal">()</span> throws InterruptedException &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入lock加锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>        <span class="hljs-comment">//判断是否已经被锁，如果被锁则当前请求的线程进行等待</span><br>        <span class="hljs-keyword">while</span> (isLocked) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入wait等待 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>            wait<span class="hljs-literal">()</span>;<br>        &#125;<br>        <span class="hljs-comment">//进行加锁</span><br>        isLocked = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    public synchronized void unlock<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入unlock解锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>        isLocked = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//唤醒对象锁池里面的一个线程</span><br>        notify<span class="hljs-literal">()</span>;<br>    &#125;<br>    <br>&#125;<br><br>public <span class="hljs-keyword">class</span> UnreentrantLockTest &#123;<br><br>    <span class="hljs-keyword">private</span> UnreentrantLock unreentrantLock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UnreentrantLock()</span>;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            unreentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodA方法被调用&quot;</span>);<br>            <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            unreentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            unreentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodB方法被调用&quot;</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            unreentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>       <span class="hljs-keyword">new</span> <span class="hljs-constructor">Main()</span>.<span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">进入lock加锁 <span class="hljs-selector-tag">main</span><br>methodA方法被调用<br>进入lock加锁 <span class="hljs-selector-tag">main</span><br>进入wait等待 <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="6、多线程可重入锁"><a href="#6、多线程可重入锁" class="headerlink" title="6、多线程可重入锁"></a>6、多线程可重入锁</h2><ul><li><p>考点：考查对常见的重入锁是否掌握</p></li><li><p>上机实战：设计一个简单的可重入锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">可重入锁：<br>也叫递归锁，指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，不会发生死锁<br>public <span class="hljs-keyword">class</span> ReentrantLock &#123;<br><br>    <span class="hljs-keyword">private</span> boolean isLocked = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//用于记录是否是重入的线程</span><br>    <span class="hljs-keyword">private</span> Thread lockedOwner = null;<br><br>    <span class="hljs-comment">//累计加锁次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> lockedCount = <span class="hljs-number">0</span>;<br><br>    public synchronized void lock<span class="hljs-literal">()</span> throws InterruptedException &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入lock加锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br><br>        Thread thread = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>        <span class="hljs-comment">//判断是否是同一个线程获取锁</span><br>        <span class="hljs-keyword">while</span> (isLocked<span class="hljs-operator"> &amp;&amp; </span>lockedOwner != thread) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入wait等待 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;当前锁状态 isLocked =  &quot;</span> + isLocked);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;当前count数量 lockedCount =  &quot;</span> + lockedCount);<br>            wait<span class="hljs-literal">()</span>;<br>        &#125;<br>        <span class="hljs-comment">//进行加锁</span><br>        isLocked = <span class="hljs-literal">true</span>;<br>        lockedOwner = thread;<br>        lockedCount++;<br>    &#125;<br><br>    public synchronized void unlock<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入unlock解锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br><br>        Thread thread = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>        <span class="hljs-comment">//判断解锁与加锁的线程是否是同一个</span><br>        <span class="hljs-keyword">if</span> (thread<span class="hljs-operator"> == </span>this.lockedOwner) &#123;<br>            lockedCount--;<br>            <span class="hljs-keyword">if</span> (lockedCount<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>                isLocked = <span class="hljs-literal">false</span>;<br>                lockedOwner = null;<br>                <span class="hljs-comment">//唤醒对象锁池里面的一个线程</span><br>                notify<span class="hljs-literal">()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br>public <span class="hljs-keyword">class</span> ReentrantLockTest &#123;<br><br>    <span class="hljs-keyword">private</span> ReentrantLock reentrantLock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantLock()</span>;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            reentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodA方法被调用&quot;</span>);<br>            <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            reentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            reentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodB方法被调用&quot;</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            reentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantLockTest()</span>.<span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">进入lock加锁 main<br>methodA方法被调用<br>进入lock加锁 main<br>methodB方法被调用<br>进入unlock解锁 main<br>进入unlock解锁 main<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="7、多线程的synchronized"><a href="#7、多线程的synchronized" class="headerlink" title="7、多线程的synchronized"></a>7、多线程的synchronized</h2><ul><li><p>考点：考查对常见的synchronized是否掌握，新版JDK6里面优化了什么</p></li><li><p>对synchronized了解不，能否介绍下你对synchronized的理解</p><p>​    synchronized 关键字解决的是多个线程之间访问资源的同步性，常用在 普通方法、静态方法、代码块。是非公平、可重入的锁</p><p>​    每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程会阻塞等待。锁被释放后，对象会从队列中取出一个线程并唤醒，具体唤醒哪一个是不确定的。</p><ul><li>方法：生成的字节码文件中会多一个ACC_SYNCHRONIZED标识位，当一个线程访问方法时，会去检查是否存在ACC_SYNCHRONIZED标识，如果存在，执行的线程将会先获取monitor，获取成功之后才能执行方法体，方方法执行完成后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象，也叫隐式同步</li><li>代码块：加了synchronized关键字的代码块，生成的字节码文件会多出monitorenter 和 monitorexit 两条指令，每个monitor维护者一个记录着拥有次数的计数器，未被使用的monitor的计数器为0，当一个线程执行monitorenter 之后，该计数器自增1；当同一个线程执行monitorexit之后，该计数器自减1；当计数器为0的时候，monitor将被释放，也叫显式同步</li></ul><p>两种本质上没什么区别，底层都是通过monitor来实现同步</p></li><li><p>JDK6 后进行了优化，你知道哪些大的变化？</p><p>​    JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>​    锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p><blockquote><p>注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p></blockquote></li></ul><h2 id="8、高性能的Compare-and-Swap"><a href="#8、高性能的Compare-and-Swap" class="headerlink" title="8、高性能的Compare and Swap"></a>8、高性能的Compare and Swap</h2><p><strong>简介：并发编程面试核心点CAS考查</strong></p><ul><li><p>考点：考查对常见的CAS是否掌握</p></li><li><p>了解CAS不？，能否解释下什么是CAS？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">CAS全称是 Compare and Swap 比较再交换，是实现并发的一种技术<br>底层是通过Unsafe类实现原子性操作，包含三个操作数——内存地址（V）、预期原值（<span class="hljs-selector-tag">A</span>）、新值(<span class="hljs-selector-tag">B</span>)<br>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值，如果在第一轮循环中，<span class="hljs-selector-tag">a</span>线程获取地址里面的值被<span class="hljs-selector-tag">b</span>线程修改了，那么<span class="hljs-selector-tag">a</span>线程需要自旋，直到下次循环才可能有机会执行。<br><br>CAS属于乐观锁，乐观锁的性能比悲观锁好；<br>AtomicXXX等原子类底层就是CAS实现，所以在一定程度上比synchronized性能好，因为synchronized是悲观锁。<br></code></pre></td></tr></table></figure><p><img src="后端面试/image-9.png" alt=""></p></li><li><p>CAS会存在什么比较严重的问题？</p><ol><li>自旋时间长，CPU利用率增加，CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，CPU资源会一直被占用</li><li>存在ABA问题</li></ol></li><li><p>能否解释下什么是ABA问题，怎么避免这个问题呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">ABA问题：如果一个变量V初次读取是<span class="hljs-selector-tag">A</span>值，并且在准备赋值的时候也是<span class="hljs-selector-tag">A</span>值，那就能说明<span class="hljs-selector-tag">A</span>值没有被修改过吗？其实是不能的，因为变量V可能被其他线程改回<span class="hljs-selector-tag">A</span>值，结果就是会导致CAS操作误认为从来没被修改过，从而赋值给V<br><br>解决办法：给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。<br>在JDK5中，已经提供了AtomicStampedReference来解决问题，检查当前引用是否等于预期引用，其次检查当前标志是否等于预期标志，如果都相等就会以原子的方式将引用和标志都设置为新值<br></code></pre></td></tr></table></figure><p><img src="后端面试/image-10.png" alt=""></p></li></ul><h1 id="七、并发底层原理"><a href="#七、并发底层原理" class="headerlink" title="七、并发底层原理"></a>七、并发底层原理</h1><h2 id="1、AQS核心底层"><a href="#1、AQS核心底层" class="headerlink" title="1、AQS核心底层"></a>1、AQS核心底层</h2><p><strong>简介: 常见的并发编程AQS考查</strong></p><ul><li><p>考点：考查是否知道并发编程AQS</p></li><li><p>知道AQS吗？能否介绍下它的核心思想是什么？</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">AQS</span>的全称为（<span class="hljs-selector-tag">AbstractQueuedSynchronizer</span>），这个类在<span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>包下面。它是一个<span class="hljs-selector-tag">Java</span>提高的底层同步工具类，比如<span class="hljs-selector-tag">CountDownLatch</span>、<span class="hljs-selector-tag">ReentrantLock</span>，<span class="hljs-selector-tag">Semaphore</span>，<span class="hljs-selector-tag">ReentrantReadWriteLock</span>，<span class="hljs-selector-tag">SynchronousQueue</span>，<span class="hljs-selector-tag">FutureTask</span>等等皆是基于<span class="hljs-selector-tag">AQS</span>的<br><br>只要搞懂了<span class="hljs-selector-tag">AQS</span>，那么<span class="hljs-selector-tag">J</span><span class="hljs-selector-class">.U</span><span class="hljs-selector-class">.C</span>中绝大部分的<span class="hljs-selector-tag">api</span>都能轻松掌握<br><br>简单来说：是用一个<span class="hljs-selector-tag">int</span>类型的变量表示同步状态，并提供了一系列的<span class="hljs-selector-tag">CAS</span>操作来管理这个同步状态对象<br>一个是 <span class="hljs-selector-tag">state</span>（用于计数器，类似<span class="hljs-selector-tag">gc</span>的回收计数器）<br>一个是线程标记（当前线程是谁加锁的），<br>一个是阻塞队列（用于存放其他未拿到锁的线程)<br><br>例子：线程<span class="hljs-selector-tag">A</span>调用了<span class="hljs-selector-tag">lock</span>()方法，通过<span class="hljs-selector-tag">CAS</span>将<span class="hljs-selector-tag">state</span>赋值为<span class="hljs-selector-tag">1</span>，然后将该锁标记为线程<span class="hljs-selector-tag">A</span>加锁。如果线程<span class="hljs-selector-tag">A</span>还未释放锁时，线程<span class="hljs-selector-tag">B</span>来请求，会查询锁标记的状态，因为当前的锁标记为 线程<span class="hljs-selector-tag">A</span>，线程<span class="hljs-selector-tag">B</span>未能匹配上，所以线程<span class="hljs-selector-tag">B</span>会加入阻塞队列，直到线程<span class="hljs-selector-tag">A</span>触发了 <span class="hljs-selector-tag">unlock</span>() 方法，这时线程<span class="hljs-selector-tag">B</span>才有机会去拿到锁，但是不一定肯定拿到<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">acquire(<span class="hljs-built_in">int</span> arg) 源码讲解，类似加锁lock操作<br>    <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire()</span>尝试直接去获取资源，如果成功则直接返回,AQS里面未实现但没有定义成abstract，因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared，类似设计模式里面的适配器模式<br><br>    add<span class="hljs-constructor">Waiter()</span> 根据不同模式将线程加入等待队列的尾部，有Node.EXCLUSIVE互斥模式、Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail方法以CAS将当前线程节点加入到等待队列的末尾。否则通过enq(node)方法初始化一个等待队列<br><br>    acquire<span class="hljs-constructor">Queued()</span>使线程在等待队列中获取资源，一直获取到资源后才返回,如果在等待过程中被中断，则返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br><br>release(<span class="hljs-built_in">int</span> arg)源码讲解 类似解锁unlock操作<br>    独占模式下线程释放指定量的资源，里面是根据<span class="hljs-keyword">try</span><span class="hljs-constructor">Release()</span>的返回值来判断该线程是否已经完成释放掉资源了；在自义定同步器在实现时，如果已经彻底释放资源(state=<span class="hljs-number">0</span>)，要返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>    unparkSuccessor方法用于唤醒等待队列中下一个线程<br></code></pre></td></tr></table></figure></li><li><p>你知道的AQS有几种同步方式，实现同步器一般要覆盖哪些方法？</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">独占式: 比如ReentrantLock<br><br>共享式：比如Semaphore<br><br>存在组合：组合式的如ReentrantReadWriteLock，AQS为使用提供了底层支撑，使用者可以自由组装实现<br><br><span class="hljs-number">1.</span> boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">2.</span> boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Release(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">3.</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">try</span><span class="hljs-constructor">AcquireShared(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">4.</span> boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">ReleaseShared(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">5.</span> boolean is<span class="hljs-constructor">HeldExclusively()</span><br><br>不需要全部实现，根据获取的锁的种类可以选择实现不同的方法，比如<br>实现支持独占锁的同步器应该实现tryAcquire、 tryRelease、isHeldExclusively<br>实现支持共享获取的同步器应该实现tryAcquireShared、tryReleaseShared、isHeldExclusively<br></code></pre></td></tr></table></figure></li><li><p>注意：线程获取锁成功后直接返回，不会进入等待队列里面，只有失败的时候才会</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//线程获取锁成功后 直接返回，不会进入等待队列里面，只有失败的时候才会</span><br>public final void acquire(<span class="hljs-built_in">int</span> arg) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span><span class="hljs-operator"> &amp;&amp; </span>acquire<span class="hljs-constructor">Queued(<span class="hljs-params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))<br>　　self<span class="hljs-constructor">Interrupt()</span>;<br>&#125;<br>​<br>=========<br><span class="hljs-comment">//获取失败则将当前线程封装为Node.EXCLUSIVE的Node节点插入AQS阻塞队列的尾部</span><br> final boolean acquire<span class="hljs-constructor">Queued(<span class="hljs-params">final</span> Node <span class="hljs-params">node</span>, <span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> &#123;<br>        boolean failed = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            boolean interrupted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                final Node p = node.predecessor<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">if</span> (p<span class="hljs-operator"> == </span>head<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span>) &#123;<br>                    set<span class="hljs-constructor">Head(<span class="hljs-params">node</span>)</span>;<br>                    p.next = null; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    return interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (should<span class="hljs-constructor">ParkAfterFailedAcquire(<span class="hljs-params">p</span>, <span class="hljs-params">node</span>)</span><span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">                    </span>park<span class="hljs-constructor">AndCheckInterrupt()</span>)<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; finally &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancel<span class="hljs-constructor">Acquire(<span class="hljs-params">node</span>)</span>;<br>        &#125;<br>    &#125;<br>==================<br><span class="hljs-comment">//调用LockSupport.park(this)方式阻塞自己</span><br> <span class="hljs-keyword">private</span> final boolean park<span class="hljs-constructor">AndCheckInterrupt()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LockSupport</span>.</span></span>park(this);<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>interrupted<span class="hljs-literal">()</span>;<br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、ReentrantLock核心底层"><a href="#2、ReentrantLock核心底层" class="headerlink" title="2、ReentrantLock核心底层"></a>2、ReentrantLock核心底层</h2><p><strong>简介: 源码解析ReentrantLock实现原理</strong></p><ul><li>考点：考查是否知道ReentrantLock底层实现</li><li>java里面的公平锁和非公平锁你知道多少，有没看过ReentrantLock源码？</li></ul><p><img src="后端面试/image-11.png" alt=""></p><ul><li>ReentrantLock中公平锁和非公平锁的区别？</li></ul><p><img src="后端面试/image-12.png" alt=""></p><h2 id="3、ReentrantLock和synchronized"><a href="#3、ReentrantLock和synchronized" class="headerlink" title="3、ReentrantLock和synchronized"></a>3、ReentrantLock和synchronized</h2><p><strong>简介: 解析ReentrantLock和synchronized的区别</strong></p><ul><li><p>考点：考查ReentrantLock和synchronized的掌握情况</p></li><li><p>ReentrantLock和synchronized使用的场景是什么，实现机制有什么不同</p><ol><li><p>底层实现：</p><ul><li><p>synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait/notify方法；</p></li><li><p>ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁；</p></li></ul></li><li><p>是否可手动释放：</p><ul><li>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用；</li><li>ReentrantLock 则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活；</li></ul></li><li><p>是否可中断：</p><ul><li>synchronized 是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成；</li><li>ReentrantLock 则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断；</li></ul></li><li><p>是否是公平锁：</p><ul><li>synchronized为非公平锁；</li><li>ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁；</li></ul></li><li><p>锁是否可绑定条件Condition</p><ul><li>synchronized不能绑定；</li><li>ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程；</li></ul></li><li><p>锁的对象</p><ul><li>synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；</li><li>ReentrantLock锁的是线程，根据进入的线程和int类型的state来标识锁的获得/争抢；</li></ul></li></ol></li></ul><h2 id="4、ReentrantReadWriteLock"><a href="#4、ReentrantReadWriteLock" class="headerlink" title="4、ReentrantReadWriteLock"></a>4、ReentrantReadWriteLock</h2><p><strong>简介: 讲解ReentrantReadWriteLock读写锁的掌握情况</strong></p><ul><li>考点：考查ReentrantReadWriteLock读写锁的掌握情况</li><li>知道ReentrantReadWriteLock吗？和ReentrantLock有啥不同？</li></ul><p><img src="后端面试/image-13.png" alt=""></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs processing">ReentrantReadWriteLock<br>    <span class="hljs-number">1</span>、是读写锁接口ReadWriteLock接口的一个具体实现，实现了读写锁的分离，<br>    <span class="hljs-number">2</span>、支持公平和非公平，底层也是基于AQS实现<br>    <span class="hljs-number">3</span>、允许从写锁降级为读锁<br>        流程：先获取写锁，然后获取读锁，最后释放写锁；但不能从读锁升级到写锁<br>    <span class="hljs-number">4</span>、重入：读锁后还可以获取读锁；获取了写锁之后既可以再次获取写锁又可以获取读锁<br>    <br>核心：读锁是共享的，写锁是独占的。 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，主要是提升了读写的性能<br><br>ReentrantLock是独占锁且可重入的，相比<span class="hljs-keyword">synchronized</span>而言功能更加丰富也更适合复杂的并发场景，但跟ReentrantReadWriteLock相比较的话ReentrantLock也有弊端，假如有两个线程A/B访问数据，加锁是为了防止线程A在写数据， 线程B在读数据造成的数据不一致； 但线程A在读数据，线程C也在读数据，读数据是不会改变数据没有必要加锁，但是还是加锁了，降低了程序的性能，所以就有了ReadWriteLock读写锁接口<br><br>场景：读多写少，比如设计一个缓存组件 或 提高Collection的并发性<br>class CachedData &#123;<br><span class="hljs-keyword">Object</span> data;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">boolean</span> cacheValid;<br>    <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br> <br>    <span class="hljs-keyword">void</span> processCachedData() &#123;<br>      rwl.readLock().lock();<br>      <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>        <span class="hljs-comment">// Must release read lock before acquiring write lock</span><br>        rwl.readLock().unlock();<br>        rwl.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// Recheck state because another thread might have</span><br>          <span class="hljs-comment">// acquired write lock and changed state before we did.</span><br>          <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            data = ...<br>            cacheValid = <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-comment">// Downgrade by acquiring read lock before releasing write lock</span><br>          rwl.readLock().lock();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          rwl.writeLock().unlock(); <span class="hljs-comment">// Unlock write, still hold read</span><br>        &#125;<br>      &#125;<br> <br>      <span class="hljs-keyword">try</span> &#123;<br>        use(data);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        rwl.readLock().unlock();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br> <br> <br>class RWDictionary &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-keyword">String</span>, Data&gt; m = <span class="hljs-keyword">new</span> TreeMap&lt;<span class="hljs-keyword">String</span>, Data&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock r = rwl.readLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock w = rwl.writeLock();<br> <br>    <span class="hljs-keyword">public</span> Data <span class="hljs-built_in">get</span>(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>) &#123;<br>      r.lock();<br>      <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> m.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; r.unlock(); &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span>[] allKeys() &#123;<br>      r.lock();<br>      <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> m.keySet().toArray(); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; r.unlock(); &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Data put(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>, Data value) &#123;<br>      w.lock();<br>      <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> m.put(<span class="hljs-built_in">key</span>, value); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; w.unlock(); &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">clear</span>() &#123;<br>      w.lock();<br>      <span class="hljs-keyword">try</span> &#123; m.<span class="hljs-built_in">clear</span>(); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; w.unlock(); &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、阻塞队列BlockingQueue"><a href="#5、阻塞队列BlockingQueue" class="headerlink" title="5、阻塞队列BlockingQueue"></a>5、阻塞队列BlockingQueue</h2><p><strong>简介: 讲解阻塞队列BlockingQueue的掌握情况</strong></p><ul><li><p>考点：考查阻塞队列BlockingQueue的掌握情况</p></li><li><p>并发编程里面解决生产者消费者模型你知道哪几种方式？</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs isbl">核心：要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据<br><br>常用的同步方法是采用信号或加锁机制<br><span class="hljs-number">1</span>、<span class="hljs-function"><span class="hljs-title">wait</span>() / <span class="hljs-title">notify</span>()方法</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-number">2</span>、<span class="hljs-title">await</span>() / <span class="hljs-title">signal</span>()方法</span><br><span class="hljs-function">    用<span class="hljs-variable">ReentrantLock</span>和<span class="hljs-variable">Condition</span>实现等待/通知模型</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-number">3</span>、<span class="hljs-variable">Semaphore</span>信号量</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-number">4</span>、<span class="hljs-variable">BlockingQueue</span>阻塞队列</span><br><span class="hljs-function">    <span class="hljs-variable">ArrayBlockingQueue</span></span><br><span class="hljs-function">    <span class="hljs-variable">LinkedBlockingQueue</span></span><br><span class="hljs-function">        <span class="hljs-variable">put</span>方法用来向队尾存入元素，如果队列满，则阻塞</span><br><span class="hljs-function">    　　 <span class="hljs-variable">take</span>方法用来从队首取元素，如果队列为空，则阻塞</span><br></code></pre></td></tr></table></figure></li><li><p>你知道阻塞队列BlockingQueue不？介绍下常见的阻塞队列？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">BlockingQueue: j<span class="hljs-selector-class">.u</span>.c包下的提供了线程安全的队列访问的接口，并发包下很多高级同步类的实现都是基于阻塞队列实现的<br><br><span class="hljs-number">1</span>、当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满<br><span class="hljs-number">2</span>、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列里面是非空的时候<br><br>常见的阻塞队列<br>    ArrayBlockingQueue：<br>        基于数组实现的一个阻塞队列，需要指定容量大小，FIFO先进先出顺序<br>    <br>    LinkedBlockingQueue：<br>        基于链表实现的一个阻塞队列，如果不指定容量大小，默认 Integer<span class="hljs-selector-class">.MAX_VALUE</span>, FIFO先进先出顺序<br>    <br>    PriorityBlockingQueue：<br>        一个支持优先级的无界阻塞队列，默认情况下元素采用自然顺序升序排序，也可以自定义排序实现 java<span class="hljs-selector-class">.lang</span>.Comparable接口<br>    <br>    DelayQueue：<br>        延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，里面的对象必须实现java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.Delayed</span> 接口并实现CompareTo和getDelay方法<br></code></pre></td></tr></table></figure></li></ul><h2 id="6、并发队列ConcurrentLinkedQueue"><a href="#6、并发队列ConcurrentLinkedQueue" class="headerlink" title="6、并发队列ConcurrentLinkedQueue"></a>6、并发队列ConcurrentLinkedQueue</h2><p><strong>简介: 讲解非阻塞队列ConcurrentLinkedQueue的掌握情况</strong></p><ul><li><p>考点：考查非阻塞队列ConcurrentLinkedQueue的掌握情况</p></li><li><p>你知道非阻塞队列ConcurrentLinkedQueue不，它怎么实现线程安全的？</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">线程安全原因：<br>ConcurrentLinkedQueue是基于链表实现的无界线程安全队列，采用FIFO进行排序<br>保证线程安全的三要素：原子、有序、可见性<br><br><span class="hljs-number">1</span>、底层结构是<span class="hljs-keyword">Node</span><span class="hljs-title">，链表头部和尾部节点是head</span>和tail，使用节点变量和内部类属性使用volatile声明保证了有序和可见性<br><br><span class="hljs-number">2</span>、插入、移除、更新操作使用CAS无锁操作，保证了原子性<br><br><span class="hljs-number">3</span>、假如多线程并发修改导致 CAS 更新失败，采用for循环插入保证更新操作成功<br></code></pre></td></tr></table></figure></li></ul><h2 id="7、并发编程的最佳实践"><a href="#7、并发编程的最佳实践" class="headerlink" title="7、并发编程的最佳实践"></a>7、并发编程的最佳实践</h2><p><strong>简介: 并发编程常用的最佳实践</strong></p><ul><li><p>考点：考查是否有用多线程，总结个人的最佳实践</p></li><li><p>平时多线程用的挺多的，写出3条你遵循的多线程最佳实践？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">给不同模块的线程起名称，方便后续排查问题<br><br>使用同步代码块或者同步的方法的时候，尽量减小同步范围<br><br>多用并发集合少用同步集合<br>支持线程安全<br>并发集合：ConcurrentHashMap、CopyOnWriteArrayList<br>        同步集合：Hashtable<span class="hljs-regexp">/Vector/</span>同步工具类包装Collections.synXXX<br><br>线上业务需要使用多线程，优先考虑线程池是否更加合适，然后判断哪种线程池比较好，最后才是自己创建单一线程<br></code></pre></td></tr></table></figure></li><li><p>用过线程池不? 有什么好处， java里有哪些是常用的线程池？</p><p><strong>使用线程池的好处：</strong></p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p><strong>java里有哪些是常用的线程池：</strong></p><ul><li>newFixedThreadPool：一个定长线程池，可控制线程最大并发数</li><li>newSingleThreadExecutor：一个单线程化的线程池，用唯一的工作线程来执行任务</li><li>newCachedThreadPool：一个可缓存线程池</li><li>newScheduledThreadPool：一个定长线程池，支持定时/周期性任务执行</li></ul></li></ul><h2 id="8、使用线程池的坑"><a href="#8、使用线程池的坑" class="headerlink" title="8、使用线程池的坑"></a>8、使用线程池的坑</h2><p><strong>简介:常见线程池里面坑是否知道</strong></p><ul><li>考点：是否知道线程池里面的坑</li><li>【阿里巴巴编码规范】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor方式的原因？</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Executors创建的线程池底层也是调用 ThreadPoolExecutor，只不过是使用不同的参数、队列、拒绝策略等,如果使用不当，会造成资源耗尽问题；<br>直接使用ThreadPoolExecutor让使用者更加清楚线程池的规则，常见参数的使用，避免风险<br><br>常见的线程池问题：<br><span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>和<span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>: <br>    队列使用LinkedBlockingQueue，队列长度为 Integer.MAX_VALUE，可能造成堆积，导致OOM<br>    <br><span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>和<span class="hljs-keyword">new</span><span class="hljs-type">ScheduledThreadPool</span>:<br>    线程池里面允许最大的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM<br></code></pre></td></tr></table></figure><h2 id="9、ThreadPoolExecutor核心参数"><a href="#9、ThreadPoolExecutor核心参数" class="headerlink" title="9、ThreadPoolExecutor核心参数"></a>9、ThreadPoolExecutor核心参数</h2><p><strong>简介: 并发编程里面的ThreadPoolExecutor参数考查</strong></p><ul><li>考点：ThreadPoolExecutor常见参数的掌握</li><li>ThreadPoolExecutor构造函数里面的参数你是否掌握，能否解释下各个参数的作用？</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,<br>                              <span class="hljs-keyword">int</span> maximumPoolSize,<br>                              <span class="hljs-keyword">long</span> keepAliveTime,<br>                              TimeUnit unit,<br>                              BlockingQueue&lt;Runnable&gt; workQueue,<br>                              ThreadFactory threadFactory,<br>                              RejectedExecutionHandler <span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure><ol><li><strong>corePoolSize</strong><ul><li>核心线程数，线程池也会维护线程的最少数量，默认情况下核心线程会一直存活，即使没有任务也不会受存keepAliveTime控制</li><li>在刚创建线程池时线程不会立即启动，直到有任务提交时才开始创建线程并且逐步达到线程数目corePoolSize</li></ul></li><li><strong>maximumPoolSize</strong><ul><li>线程池维护线程的最大数量，超过将被阻塞</li><li>当核心线程满，且阻塞队列也满时，才会判断当前线程数是否小于最大线程数，才决定是否创建新线程</li></ul></li><li><strong>keepAliveTime</strong><ul><li>非核心线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize</li></ul></li><li><strong>unit</strong><ul><li>指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS</li></ul></li><li><strong>workQueue</strong><ul><li>线程池中的任务队列,常用的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</li></ul></li><li><strong>threadFactory</strong><ul><li>创建新线程时使用的工厂</li></ul></li><li><strong>handler</strong><ul><li>RejectedExecutionHandler是一个接口且只有一个方法,线程池中的数量大于maximumPoolSize时，拒绝任务的处理策略，默认有4种策略AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</li></ul></li></ol><h1 id="八、消息队列"><a href="#八、消息队列" class="headerlink" title="八、消息队列"></a>八、消息队列</h1><h2 id="1、消息队列的优缺点及选型"><a href="#1、消息队列的优缺点及选型" class="headerlink" title="1、消息队列的优缺点及选型"></a>1、消息队列的优缺点及选型</h2><p><strong>简介：对比当下主流的消息队列和选择问题</strong></p><ul><li><p>考点：是否有了解主流消息队列</p></li><li><p>消息队列有什么优点和缺点？</p><p>优点：</p><ul><li>异步：<ul><li>能提高系统的响应速度、吞吐量。</li></ul></li><li>解耦：<ul><li>服务之间进行解耦，可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。</li><li>解耦后可以实现数据分发。生产者发送一个消息后，可以由一个或者多个消费者进行处理，并且消费者的增加或者减少对生产者没有影响。</li></ul></li><li>削峰：<ul><li>以稳定的系统资源应对突发的流量冲击。</li></ul></li></ul><p>缺点：</p><ul><li>系统可用性降低：<ul><li>系统引入外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。<strong>这就需要考虑如何保证MQ的高可用。</strong></li></ul></li><li>系统复杂度提高：<ul><li>以前服务之间可以进行同步的服务调用，引入MQ之后，会变成异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：<strong>如何保证消息不会丢失？如何保证消息不被重复调用？如何保证消息传递的顺序性？</strong></li></ul></li><li>消息一致性问题：<ul><li>A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，但C系统处理失败了怎么办？<strong>这就需要考虑如何保证消息数据处理的一致性。</strong></li></ul></li></ul></li><li><p>业界主流消息队列和技术选型？</p><ul><li>ActiveMQ：<a href="http://activemq.apache.org/">http://activemq.apache.org/</a><ul><li>Apache出品，历史悠久，支持多种语言的客户端和协议，支持多种语言Java, .NET, C++ 等</li><li>基于JMS Provider的实现</li><li>缺点：吞吐量不高，多队列的时候性能下降，存在消息丢失的情况，比较少大规模使用</li></ul></li><li>Kafka：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a><ul><li>是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理大规模的网站中的所有动作流数据(网页浏览，搜索和其他用户的行动)，副本集机制，实现数据冗余，保障数据尽量不丢失；支持多个生产者和消费者</li><li>类似MQ，功能较为简单，主要支持简单的MQ功能</li><li>缺点：不支持批量和广播消息，运维难度大，文档比较少, 需要掌握Scala</li></ul></li><li>RocketMQ：<a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a><ul><li>阿里开源的一款的消息中间件, 纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点, 性能强劲(零拷贝技术)，支持海量堆积, 支持指定次数和时间间隔的失败消息重发,支持consumer端tag过滤、延迟消息等，在阿里内部进行大规模使用，适合在电商，互联网金融等领域</li><li>基于JMS Provider的实现</li><li>缺点：社区相对不活跃，更新比较快，纯java支持</li></ul></li><li>RabbitMQ：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a><ul><li>是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、C、用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不错</li><li>缺点：使用Erlang开发，阅读和修改源码难度大</li></ul></li></ul></li></ul><h2 id="2、oneway-延迟消息"><a href="#2、oneway-延迟消息" class="headerlink" title="2、oneway/延迟消息"></a>2、oneway/延迟消息</h2><p><strong>简介：是否知道oneway、延迟消息等类型消息的应用</strong></p><ul><li>考点：是否有了解主流消息队列oneway、延迟消息的使用</li><li>消息队列的发送方式有哪几种，使用场景分别是怎样的？</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">SYNC</span> 同步发送<br>应用场景：重要通知邮件、报名短信通知、营销短信系统等<br><br>ASYNC 异步发送<br>应用场景：对RT时间敏感,可以支持更高的并发，回调成功触发相对应的业务，比如注册成功后通知积分系统发放优惠券<br><br>ONEWAY 无需要等待响应<br>应用场景：主要是日志收集，适用于某些耗时非常短，但对可靠性要求并不高的场景, 也就是LogServer, 只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求，不等待应答<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">发送方式</th><th style="text-align:left">发送 TPS</th><th style="text-align:left">发送结果反馈</th><th style="text-align:left">可靠性</th></tr></thead><tbody><tr><td style="text-align:left">同步发送</td><td style="text-align:left">快</td><td style="text-align:left">有</td><td style="text-align:left">不丢失</td></tr><tr><td style="text-align:left">异步发送</td><td style="text-align:left">快</td><td style="text-align:left">有</td><td style="text-align:left">不丢失</td></tr><tr><td style="text-align:left">单向发送</td><td style="text-align:left">最快</td><td style="text-align:left">无</td><td style="text-align:left">可能丢失</td></tr></tbody></table></div><ul><li>有没用过延迟消息，使用场景是怎样的？</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">延迟消息：<br><span class="hljs-code">    Producer 将消息发送到消息队列 broker服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费</span><br><span class="hljs-code"></span><br>使用场景一：通过消息触发一些定时任务，比如在某一固定时间点向用户发送提醒消息<br>使用场景二：消息生产和消费有时间窗口要求，比如在天猫电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条 延时消息。这条消息将会在 30 分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。 如支付未完成，则关闭订单。如已完成支付则忽略<br></code></pre></td></tr></table></figure><h2 id="3、消息的顺序性"><a href="#3、消息的顺序性" class="headerlink" title="3、消息的顺序性"></a>3、消息的顺序性</h2><p><strong>简介：是否知道如何保证消息的顺序性</strong></p><ul><li><p>考点：如何保证消息的顺序性</p></li><li><p>你用的队列是否支持顺序消息，是怎么实现顺序消息的？</p><ul><li><p>消息的顺序性：消息的生产顺序和消费顺序一致</p><ul><li><p>全局顺序：</p><p>​    topic下面全部消息都要有序(很少使用)，适合于性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景，并行度成为消息系统的瓶颈, 吞吐量不够</p><p>​    使用场景：在证券处理中，以人民币兑换美元为例子，在价格相同的情况下，先出价者优先处理，则可以通过全局顺序的方式按照 FIFO 的方式进行发布和消费</p></li><li><p>局部顺序：</p><p>​    只要保证一组消息被顺序消费即可，性能要求高</p><p>​    使用场景：电商的订单创建，同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息、订单交易成功消息 都会按照先后顺序来发布和消费（阿里巴巴集团内部电商系统均使用局部顺序消息，既保证业务的顺序，同时又能保证业务的高性能）</p></li></ul></li></ul></li></ul><p><strong>以RabbitMQ为例分析如何保证消息的顺序性</strong></p><p><strong>出现消费顺序错乱的情况①：</strong></p><ul><li><strong>一个queue存在多个consumer</strong></li></ul><p><img src="后端面试/image-14.png" alt=""></p><ul><li><strong>解决方案：</strong>将原来的一个queue拆分成多个queue，每个queue都有一个自己的consumer。该种方案的核心是生产者在投递消息的时候<strong>根据业务数据关键值（例如订单ID哈希值对订单队列数取模）来将需要保证先后顺序的同一类数据（同一个订单的数据）</strong> 发送到同一个queue当中</li></ul><p><img src="后端面试/image-15.png" alt=""></p><p><strong>出现消费顺序错乱的情况②：</strong></p><ul><li><strong>一个queue只存在一个consumer，但consumer中使用了多线程进行处理</strong></li></ul><p><img src="后端面试/image-16.png" alt=""></p><ul><li><strong>解决方案：</strong>在consumer中维护<strong>多个内存队列</strong>，<strong>根据业务数据关键值（例如订单ID哈希值对内存队列数取模）将消息加入到不同的内存队列中</strong>，然后多个真正负责处理消息的线程去各自对应的内存队列当中获取消息进行消费。</li></ul><p><img src="后端面试/image-17.png" alt=""></p><p><strong>RabbitMQ保证消息顺序性总结：</strong><br>核心思路就是根据业务数据关键值划分成多个消息集合，而且每个消息集合中的消息数据都是有序的，每个消息集合有自己独立的一个consumer。多个消息集合的存在保证了消息消费的效率，每个有序的消息集合对应单个的consumer保证了消息消费时的顺序性。</p><h2 id="4、消息的幂等性"><a href="#4、消息的幂等性" class="headerlink" title="4、消息的幂等性"></a>4、消息的幂等性</h2><p><strong>简介：考查怎么样可以避免重复消费</strong></p><ul><li>考点：是否有真正用过消息队列，是否设计过重复消费</li><li>幂等性是什么?<ul><li>通俗点说，就一个数据或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的</li><li>保证同一条消息不会重复或者重复消费了也不会对系统数据造成异常</li></ul></li><li>哪些情况会导致重复消费？<ul><li>在生产者发送消息给rabbitMQ服务器的时候，有可能因为网络波动等情况，导致生产者收不到rabbitMQ服务器的应答，导致生产者再发送一条消息。</li><li>也是因为网络波动等问题，导致rabbitMQ服务器在向消费者发送消息的时候，没有收到消费者的应答，重复向消费者发生消息。</li></ul></li><li>如何保证消息的幂等性?<ul><li>在消息生产时，MQ内部针对每条生产者发送的消息都会生成一个<code>inner-msg-id</code>作为去重和幂等的依据（消息传递失败并重传），避免重复的消息进入队列；</li><li>在消息消费时，要求消息体中必须要有一个<code>bizid</code>（对于同一业务全局唯一，如支付ID、订单ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</li></ul></li><li>你的业务系统有没做消息的重复消费处理，是怎么做的?<ul><li>拿到这个消息做数据库的 <code>insert</code> 操作。给这个消息一个唯一主键，那么即使出现重复消费的情况，也会因为主键冲突，而避免数据库出现脏数据。</li><li>拿到这个消息做Redis的 <code>set</code> 操作，无论你 <code>set</code> 几次结果都一样，<code>set</code> 操作本身就算是幂等操作。</li><li>用第三方介质来做消费记录。如Redis；给消息分配一个全局ID，只要消费过此消息，将以key-value的形式写入Redis。在消费者开始消费之前，先去Redis中查询有没有消费记录即可。</li></ul></li></ul><h2 id="5、消息的可靠性"><a href="#5、消息的可靠性" class="headerlink" title="5、消息的可靠性"></a>5、消息的可靠性</h2><p><strong>简介：如何保证消费的可靠性传输</strong></p><ul><li>考点：是否有研究消息队列的底层原理，保证消息的可靠性传输，消息队列的架构</li><li><p>你用了消息队列，你知道这个消息队列如何保证消息的可靠性传输吗？</p></li><li><p><strong>可能发生消息丢失情况的阶段</strong></p><ul><li><strong>Producer 发送消息到 Broker 失败</strong>；（发送过程中网络波动、发送到一个不存在的 Exchange等）</li><li><strong>Exchange 路由到 Queue 失败</strong>；Exchange 将消息根据 RoutingKey 路由到对应的 Queue 时失败；（此 Exchange 没有绑定 Queue 等）</li><li><strong>Consumer 处理消息失败</strong>；已经获取了消息但无法正确处理导致消息丢失（消费者来不及处理就挂掉了等）</li></ul></li></ul><p>针对以上可能发生消息丢失的情况可以采取对应的<strong>解决方案：</strong></p><p><strong>① Producer 发送消息到 Broker 失败 情况的解决方案：</strong></p><ul><li><p><strong>transaction 机制：</strong></p><ul><li>生产者发送数据之前开启 RabbitMQ 的事务 <code>channel.txSelect</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback</code> ，然后重试发送消息；如果收到了消息，那么可以提交事务<code>channel.txCommit</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>开启事务<br>channel.txSelect<br>try &#123;<br>    <span class="hljs-regexp">//</span>这里发送消息<br>&#125; catch (Exception e) &#123;<br>    channel.txRollback<br>    <span class="hljs-regexp">//</span>回滚事务后，这里重试发送消息<br>&#125;<br><span class="hljs-regexp">//</span>提交事务<br>channel.txCommit<br>Copy<br></code></pre></td></tr></table></figure><ul><li>采用该种方法由于事务机制，会导致吞吐量下降，太消耗性能。</li></ul></li><li><p><strong>confirm机制：</strong>（推荐使用）</p><ul><li>使用 SpringBoot 时在 application.yml 配置文件中做如下配置</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 发送者开启 <span class="hljs-keyword">confirm</span> 确认机制<br>publisher-<span class="hljs-keyword">confirm</span>-<span class="hljs-keyword">type</span>: correlated<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li>通过<strong>confirmCallback</strong>生产者投递消息后，如果Broker收到消息后，会给生产者一个ACK。生产者通过ACK，可以确认这条消息是否正常发送到Broker，这种方式是消息可靠性投递的核心。</li><li>一旦 channel 进入 confirm 模式，所有在该 channel 上的消息都会被指派一个以为的ID（从1开始），一旦消息被投递到所有匹配到的队列之后，RabbitMQ 就会发送一个 <code>ACK</code> 给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了。如果 RabbitMQ 没能处理该消息，则会发送一个 <code>Nack</code> 消息给你，你可以进行重试操作。</li></ul></li><li><p><strong>注意：</strong>transaction 机制和 confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</p></li></ul><p><strong>② Exchange 路由到 Queue 失败 情况的解决方案：</strong></p><ul><li><strong>开启 RabbitMQ 的持久化机制</strong><ul><li>消息写入之后会持久化到磁盘，哪怕 RabbitMQ 挂了，重启之后会自动读取之前存储的数据，一般数据不会丢失。<strong>特殊情况：除非 RabbitMQ 还没持久化就已经挂了，此时会导致少量数据丢失。</strong></li><li>解决特殊情况，<strong>持久化机制和 confirm 机制配合使用</strong>；可以在消息持久化磁盘之后，再给生产者发送一个 <code>ACK</code> ，这样，如果消息持久化磁盘之前，RabbitMQ 挂掉了，那么生产者收不到 <code>ACK</code> ，生产者也会自动重发处理。</li><li>通过<strong>returnCallback</strong>，消息从交换器发送到对应队列失败时触发</li></ul></li></ul><p><strong>③ Consumer 处理消息失败 情况的解决方案：</strong></p><ul><li><p><strong>关闭自动<code>ACK</code>，使用手动<code>ACK</code></strong></p><ul><li>使用 SpringBoot 时在 application.yml 配置文件中做如下配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">listener:</span><br><span class="hljs-attr">simple:</span><br>    <span class="hljs-comment"># 设置消费端手动 ack</span><br>    <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br><span class="hljs-string">Copy</span><br></code></pre></td></tr></table></figure><ul><li>如果消费者来不及处理就挂掉了，没有响应<code>ACK</code>时会重复发送一条信息给其他的消费者</li><li>如果出现了异常，且不对异常进行捕获，就会一直重复接受消息，然后一直抛异常。</li><li>如果对异常进行了捕获，但是没有在 finally 里<code>ACK</code>，也会一直重复发送消息（<strong>重试机制</strong>）</li><li>我们只需要保证幂等性就好了，重复消费也不会造成问题。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@RabbitHandler<br>public void handler<span class="hljs-constructor">Mq(String <span class="hljs-params">msg</span>, Channel <span class="hljs-params">channel</span>, Message <span class="hljs-params">message</span>)</span> throws IOException &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//业务处理代码</span><br>...... <br><span class="hljs-comment">//手动ACK</span><br>channel.basic<span class="hljs-constructor">Ack(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>);<br>&#125; catch (Exception e) &#123;<br><span class="hljs-keyword">if</span> (message.get<span class="hljs-constructor">MessageProperties()</span>.get<span class="hljs-constructor">Redelivered()</span>) &#123;<br>log.error(<span class="hljs-string">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>, e);<br><span class="hljs-comment">//拒绝消息</span><br>channel.basic<span class="hljs-constructor">Reject(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.error(<span class="hljs-string">&quot;消息即将再次返回队列处理...&quot;</span>, e);<br>channel.basic<span class="hljs-constructor">Nack(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="6、消息堆积的处理"><a href="#6、消息堆积的处理" class="headerlink" title="6、消息堆积的处理"></a>6、消息堆积的处理</h2><p><strong>简介：如果消息大量堆积在broker里面，应该怎么处理</strong></p><ul><li>考点：是否有研究消息队列不可用后的应急方案，是否有架构思维</li><li>线上故障了，怎么处理？<ul><li>消息堆积了10小时，有几千万条消息待处理，现在怎么办?</li><li>修复consumer, 然后慢慢消费？也需要几小时才可以消费完成，新的消息怎么办？</li></ul></li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">核心思想：紧急临时扩容，更快的速度去消费数据<br><br><span class="hljs-bullet">- </span>修复Consumer不消费问题，使其恢复正常消费，根据业务需要看是否要暂停<br><br><span class="hljs-bullet">- </span>临时topic队列扩容，并提高消费者能力，但是如果增加Consumer数量，但是堆积的topic里面的message queue数量固定，过多的consumer不能分配到message queue<br><br><span class="hljs-bullet">- </span>编写临时处理分发程序，从旧topic快速读取到临时新topic中，新topic的queue数量扩容多倍，然后再启动更多consumer进行在临时新的topic里消费<br><br><span class="hljs-bullet">- </span>直到堆积的消息处理完成，再还原到正常的机器数量<br></code></pre></td></tr></table></figure><p><img src="后端面试/image-18.png" alt=""></p><p><img src="后端面试/image-19.png" alt=""></p><p><img src="后端面试/image-20.png" alt=""></p><h1 id="九、MySQL数据库"><a href="#九、MySQL数据库" class="headerlink" title="九、MySQL数据库"></a>九、MySQL数据库</h1><h2 id="1、ACID"><a href="#1、ACID" class="headerlink" title="1、ACID"></a>1、ACID</h2><p><strong>简介：是否掌握事务的ACID原理</strong></p><ul><li>考点：是否掌握事务的ACID原理</li><li>你知道Mysql事务的四大特性不，简单说下？<ul><li><strong>原子性Atomicity</strong>：一个事务必须是不可分割的最小工作单元，整个操作要么全部成功，要么全部失败，一般就是通过commit和rollback来控制。</li><li><strong>一致性Consistency</strong>：数据库总能从一个一致性的状态转换到另一个一致性的状态。</li><li><strong>隔离性Isolation</strong>：一个事务相对于另一个事务是隔离的，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li><li><strong>持久性Durability</strong>：一旦事务提交，其所做的修改就会永久保存到数据库，即使系统崩溃，修改的数据也不会丢失</li></ul></li></ul><h2 id="2、脏读-不可重复读-幻读"><a href="#2、脏读-不可重复读-幻读" class="headerlink" title="2、脏读-不可重复读-幻读"></a>2、脏读-不可重复读-幻读</h2><p><strong>简介：考查数据库隔离级别导致的问题</strong></p><ul><li><p>考点：是否掌握数据库常见隔离级别和对应导致的问题</p></li><li><p>能否简单解释下脏读、不可重复读、幻读的意思</p><ul><li><p><strong>脏读</strong>：一个事务读取到另外一个事务未提交的数据</p><p>​    例子：A向B转账，<strong>A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了</strong>！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。</p></li><li><p><strong>不可重复读</strong>：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改</p><p>​    注：<strong>A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了】</strong></p></li><li><p><strong>幻读(虚读)</strong>：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</p><p>​    注：<strong>和不可重复读类似，但幻读(虚读)会读到其他事务的插入的数据，导致前后读取不一致</strong></p></li></ul><p><strong>不可重复读和幻读有什么区别呢？</strong></p><ul><li>不可重复读的重点是内容修改或者记录减少，比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增，比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul></li><li><p>常见的隔离级别由低到高有哪几种，mysql默认是哪种?</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<strong>【MySQL默认是REPEATABLE-READ(可重复读)】</strong></li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">READ-UNCOMMITTED</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">READ-COMMITTED</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">REPEATABLE-READ</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table></div><blockquote><p>×代表无法解决，√代表能解决</p></blockquote><h2 id="3、MySQL的存储引擎"><a href="#3、MySQL的存储引擎" class="headerlink" title="3、MySQL的存储引擎"></a>3、MySQL的存储引擎</h2><p><strong>简介：考查mysql的存储引擎</strong></p><ul><li><p>考点：是否知道Mysql的存储引擎及其区别</p></li><li><p>说下你知道Mysql常见的存储引擎，新版Mysql默认是哪个</p><ul><li><strong>Innodb引擎</strong>，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li><strong>MyISAM引擎</strong>(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。</li><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">新版本MySQL 5.5以后默认是Innodb；MySQL 5.5以前默认是MyISAM<br></code></pre></td></tr></table></figure></blockquote></li><li><p>mysql的存储引擎 Innodb和MyISAM有什么区别，应该怎么选择？</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">区别项</th><th style="text-align:center">Innodb</th><th style="text-align:center">MyISAM</th></tr></thead><tbody><tr><td style="text-align:center">事务</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">锁粒度</td><td style="text-align:center">行锁，适合高并发</td><td style="text-align:center">表锁，不适合高并发</td></tr><tr><td style="text-align:center">是否默认</td><td style="text-align:center">默认</td><td style="text-align:center">非默认</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center">支持外键</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">适合场景</td><td style="text-align:center">读写均衡、写大于读、需要事务</td><td style="text-align:center">读多写少、不需要事务</td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">不支持，可以通过插件实现, 更多使用ElasticSearch</td><td style="text-align:center">支持全文索引</td></tr></tbody></table></div><blockquote><p>InnoDB 是聚簇索引；InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效</p><p>MyISAM 是非聚簇索引；MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据</p></blockquote><h2 id="4、MySQL的索引"><a href="#4、MySQL的索引" class="headerlink" title="4、MySQL的索引"></a>4、MySQL的索引</h2><p><strong>简介：考查mysql的功能索引掌握情况</strong></p><ul><li>考点：mysql的功能索引</li><li>mysql常用的功能索引有哪些？分别在什么场景下使用？创建语句是怎样的？</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">索引名称</th><th style="text-align:center">特点</th><th style="text-align:left">创建语句</th></tr></thead><tbody><tr><td style="text-align:center">普通索引</td><td style="text-align:center">最基本的索引,加速查询</td><td style="text-align:left">CREATE INDEX idx_name ON table_name(filed_name)</td></tr><tr><td style="text-align:center">唯一索引</td><td style="text-align:center">加速查询，列值唯一，允许为空； <br />组合索引则列值的组合必须唯一</td><td style="text-align:left">CREATE UNIQUE INDEX idx_name ON table_name(filed_name_1,filed_name_2)</td></tr><tr><td style="text-align:center">主键索引</td><td style="text-align:center">加速查询，列值唯一 <br />一个表只有1个，不允许有空值</td><td style="text-align:left">ALTER TABLE table_name ADD PRIMARY KEY ( filed_name )</td></tr><tr><td style="text-align:center">组合索引</td><td style="text-align:center">加速查询，多条件组合查询</td><td style="text-align:left">CREATE INDEX idx_name ON table_name(filed_name_1,filed_name_2);</td></tr><tr><td style="text-align:center">覆盖索引</td><td style="text-align:center">索引包含所需要的字段，不需要“回表”查询； <br />比如查询的两个字段，刚好是组合索引的两个字段</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">对内容进行分词搜索，仅可用于Myisam， 更多用ElasticSearch做搜索</td><td style="text-align:left">ALTER TABLE table_name ADD FULLTEXT ( filed_name</td></tr></tbody></table></div><ul><li><p>数据库索引的优缺点？</p><ul><li><p>优点：</p><ul><li><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p></li><li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p></li></ul></li><li><p>缺点：</p><ul><li>时间方面：创建索引和维护索引要耗费时间，当对表中的数据进行增/删/改的时候，索引也要动态的维护，会降低增/删/改的执行效率；</li><li>空间方面：索引需要占用物理空间</li></ul></li></ul></li><li><p>索引的最佳实践？</p><ul><li>前缀索引，特别是TEXT和BLOG类型的字段，只检索前面几个字符，提高检索速度</li><li>尽量使用数据量少的索引，索引值过长查询速度会受到影响</li><li>选择合适的索引列顺序</li><li>内容变动少，且查询频繁，可以建立多个索引</li><li>内容变动频繁，谨慎创建索引</li><li>根据业务创建适合的索引类型，比如某个字段常用来做查询条件，才为这个字段建立索引来提高查询速度</li><li>组合索引选择业务查询最相关的字段</li></ul></li></ul><h1 id="十、数据库设计"><a href="#十、数据库设计" class="headerlink" title="十、数据库设计"></a>十、数据库设计</h1><h2 id="1、数据库查询关键词执行顺序"><a href="#1、数据库查询关键词执行顺序" class="headerlink" title="1、数据库查询关键词执行顺序"></a>1、数据库查询关键词执行顺序</h2><p><strong>简介：数据库查询指令的执行顺序</strong></p><ul><li>考点：考查数据库查询指令的执行顺</li><li>MySQL数据库查询的指令有多个，说下执行顺序 select、where、from、group by、having、order by、limit<ol><li><strong>FROM阶段</strong>：标识出查询的来源表，并处理表运算符</li><li><strong>WHERE阶段</strong>：初步过滤条件，此时数据还没有分组，所以不能在WHERE中出现对统计的过滤</li><li><strong>GROUP BY阶段</strong>：过滤后进行分组，在GROUP BY阶段，数据库认为两个NULL值是相等的，因此会将NULL值分到同一个分组中</li><li><strong>HAVING阶段</strong>：对分组后的数据进行二次过滤，COUNT(expr) 会返回expr不为NULL的行数，count(1)、count(*)会返回包括NULL值在内的所有数量</li><li><strong>SELECT阶段</strong>：查看哪些结果字段</li><li><strong>ORDER BY阶段</strong>：按照怎样的顺序进行排序返回，如果不指定排序，数据并非总是按照主键顺序进行排序的。NULL被视为最小值</li><li><strong>LIMIT阶段</strong>：指定返回的记录数，LIMIT n, m的效率是十分低的，一般可以通过在WHERE条件中指定范围来优化 WHERE id &gt; ? limit 10</li></ol></li></ul><h2 id="2、数据库表的字段类型"><a href="#2、数据库表的字段类型" class="headerlink" title="2、数据库表的字段类型"></a>2、数据库表的字段类型</h2><p><strong>简介：设计数据库的时候相似类型的字段区分</strong></p><ul><li><p>考点：是否知道常用的相似字段他们的区别</p></li><li><p>MySQL中的varchar和char有什么区别，应该怎么选择？</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">对比项</th><th style="text-align:center">char(16)</th><th style="text-align:center">varchar(16)</th></tr></thead><tbody><tr><td style="text-align:center">长度特点</td><td style="text-align:center">长度固定，存储字符</td><td style="text-align:center">长度可变，存储字符</td></tr><tr><td style="text-align:center">长度不足情况</td><td style="text-align:center">插入的长度小于定义长度时，则右侧用空格填充</td><td style="text-align:center">小于定义长度时，按实际插入长度存储</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">存取速度较快</td><td style="text-align:center">存取速度较慢</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">适合存储很短的,固定长度的字符串,如手机号，MD5值等</td><td style="text-align:center">适合用在长度不固定场景，如收货地址，邮箱地址等</td></tr></tbody></table></div><ul><li>MySQL中的datetime和timestamp有什么区别？</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">类型</td><td style="text-align:left">占据字节</td><td style="text-align:left">范围</td><td style="text-align:left">时区问题</td></tr><tr><td style="text-align:left">datetime</td><td style="text-align:left">8 字节</td><td style="text-align:left">1000-01-01 00:00:00到 9999-12-31 23:59:59</td><td style="text-align:left">存储与时区无关，不会发生改变</td></tr><tr><td style="text-align:left">timestamp</td><td style="text-align:left">4 字节</td><td style="text-align:left">1970-01-01 00:00:01 到 2038-01-19 11:14:07</td><td style="text-align:left">存储的是与时区有关，随数据库的时区而发生改变</td></tr></tbody></table></div><ul><li>为什么timestamp只能到2038年？</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">MySQL的timestamp类型是4个字节，最大值是(2的31次方)<span class="hljs-string">-1</span>，结果是2147483647，<br>转换成北京时间就是2038<span class="hljs-string">-01</span><span class="hljs-string">-19</span> 11:14:07<br></code></pre></td></tr></table></figure><h2 id="3、数据表分页优化"><a href="#3、数据表分页优化" class="headerlink" title="3、数据表分页优化"></a>3、数据表分页优化</h2><p><strong>简介：针对海量数据sql分页优化思路</strong></p><ul><li>考点：是否有海量数据分页优化思路</li><li>线上数据库的一个商品表数据量过千万，做深度分页的时候性能很慢，有什么优化思路？</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">现象：千万级别数据很正常，比如数据流水、日志记录等，数据库正常的深度分页会很慢<br>慢的原因：<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> product <span class="hljs-keyword">limit</span> M,N<br>MySQL执行此类<span class="hljs-keyword">SQL</span>时是从第M+<span class="hljs-number">1</span>行开始显示，一共显示N条（显示的记录是M+<span class="hljs-number">1</span>，M+N）所以M越大,MySQL扫描的记录数越多，<span class="hljs-keyword">SQL</span>的性能就会越差<br><br><span class="hljs-number">1</span>、后端、前端缓存<br><br><span class="hljs-number">2</span>、使用ElasticSearch分页搜索<br><br><span class="hljs-number">3</span>、合理使用 mysql 查询缓存，覆盖索引进行查询分页<br>  <span class="hljs-keyword">select</span> title,cateory <span class="hljs-keyword">from</span> product <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">100</span><br>  <br><span class="hljs-number">4</span>、如果id是自增且不存在中间删除数据，使用子查询优化，定位偏移位置的 id<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">100</span>; //<span class="hljs-number">5.</span>秒<br>      <br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">1</span>; // <span class="hljs-number">0.4</span>秒 <br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">and</span>  id&gt;=(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">limit</span> <span class="hljs-number">100</span>; //<span class="hljs-number">0.8</span>秒 <br></code></pre></td></tr></table></figure><h2 id="4、数据库应用版本更新"><a href="#4、数据库应用版本更新" class="headerlink" title="4、数据库应用版本更新"></a>4、数据库应用版本更新</h2><p><strong>简介：数据库上线流程，版本更新流程</strong></p><ul><li>考点：是否有正确的数据库部署流程</li><li>你公司里面产品迭代更新，开发好代码和数据库，上线流程是怎样的？</li></ul><p><img src="后端面试/image-21.png" alt=""></p><h1 id="十一、数据库性能监控和优化"><a href="#十一、数据库性能监控和优化" class="headerlink" title="十一、数据库性能监控和优化"></a>十一、数据库性能监控和优化</h1><h2 id="1、生产环境的数据库的安全保证"><a href="#1、生产环境的数据库的安全保证" class="headerlink" title="1、生产环境的数据库的安全保证"></a>1、生产环境的数据库的安全保证</h2><p><strong>简介：生成环境监控指标和安全</strong></p><ul><li><p>考点：是否有监控和数据安全思维</p></li><li><p>针对线上的数据库，你会做哪些监控？，业务性能 + 数据安全的角度分析</p><ul><li><p><strong>业务性能</strong>：</p><ol><li><p>应用上线前会审查业务新增的sql、分析sql执行计划</p><p>​    比如是否存在 select *    索引建立是否合理</p></li><li><p>开启慢查询日志，定期分析慢查询日志</p></li><li><p>监控CPU/内存利用率、读写、网关IO、流量带宽 随着时间变化的统计图</p></li><li><p>吞吐量QPS/TPS 一天内随着时间变化的统计图</p></li></ol></li><li><p><strong>数据安全</strong>：</p><ol><li>短期增量备份，比如一周一次。定期全量备份，比如一月一次</li><li>检查是否存在非授权用户、是否存在弱口令，进行网络防火墙检查</li><li>导出数据是否进行脱敏，防止数据泄露或者黑产利用</li><li>数据库进行全量操作日志审计，防止数据泄露</li><li>数据库账号密码根据业务进行独立，权限独立控制，防止多库共用同一个账号密码</li><li>高可用时采用主从架构、多机房部署</li></ol></li></ul></li></ul><h2 id="2、MySQL中的日志"><a href="#2、MySQL中的日志" class="headerlink" title="2、MySQL中的日志"></a>2、MySQL中的日志</h2><p><strong>简介：mysql常见日志的考查</strong></p><ul><li><p>考点：mysql常见日志种类和作用</p></li><li><p>Mysql有多少种常见的日志？分别解释日志的作用</p><ol><li><p><strong>redo 重做日志</strong></p><p>​    确保事务的持久性，防止在发生故障时，脏页未写入磁盘。重启数据库会进行<strong>redo log</strong>执行重做，达到事务一致性</p><blockquote><p>脏页：内存数据页与磁盘内存页的内容不一致时的内存页叫做脏页</p></blockquote></li><li><p><strong>undo 回滚日志</strong></p><p>​    保证数据的原子性，记录事务发生之前数据的一个版本，用于回滚</p><blockquote><p>MVCC的实现就是依赖于：隐藏字段、Read View、undo log</p></blockquote></li><li><p><strong>errorlog 错误日志</strong></p><p>​    记录MySQL本身启动、停止、运行期间发生的错误信息</p></li><li><p><strong>slow query log 慢查询日志</strong></p><p>​    记录执行时间过程的sql，时间阈值可以配置，只记录执行成功</p></li><li><p><strong>binlog 二进制日志</strong></p><p>​    用于数据库的数据备份、主备、主主、主从 ，保证数据一致性</p></li><li><p><strong>relay log 中继日志</strong></p><p>​    用于数据库主从同步，将主库发送来的binlog先保存在本地，然后在从库进行重放</p></li><li><p><strong>general log 普通日志</strong></p><p>​    记录数据库操作明细，默认关闭，因为开启会降低数据库性能</p></li></ol></li></ul><h2 id="3、数据库的主从同步"><a href="#3、数据库的主从同步" class="headerlink" title="3、数据库的主从同步"></a>3、数据库的主从同步</h2><p><strong>简介：数据库主从的用途、原理流程</strong></p><ul><li>考点：是否搭建过主从，并掌握原理</li><li>解释下主从复制中的异步复制原理？</li></ul><p><img src="后端面试/image-22.png" alt=""></p><ul><li><p>搭建数据库主从同步的目的是什么？</p><ol><li>业务需要，进行读写分离，减少主库压力</li><li>容灾使用，用于故障切换</li></ol></li><li><p>同步延迟问题如何解决？</p><p>保证性能的情况下，无法百分百的解决，只能缓解</p><p><strong>现象</strong>：大量数据的场景下，主库的数据已经写入，但从库中还没有</p><p><strong>原因</strong>：</p><ol><li>主从复制是单线程操作，当主库TPS过高，产生的数据量超过从库SQL执行的执行能力</li><li>从库执行了某些很大的SQL操作，导致阻塞等待</li><li>服务器硬件问题，如磁盘、CPU、网络延迟</li></ol><p><strong>缓解方法</strong>：</p><ol><li>引入缓存；写入主库后，再写入缓存，读取的时候可以先读缓存，没命中再去读从库</li><li>读写分离；一主多从，分散主库和从库的压力</li><li>提高硬件配置；比如使用SSD固态硬盘、更好的CPU和网络</li><li>进行分库分表；减少单机数据库的压力</li></ol></li></ul><p><img src="后端面试/image-23.png" alt=""></p><ul><li>什么场景下会出现主从数据不一致？<ol><li>复制的延迟导致</li><li>主库或从库宕机都会导致复制中断</li><li>把一个从库升级为主库时，也可能会导致</li></ol></li><li>主从一致性校验和修复如何做？</li></ul><p>​    Mysql主从复制是基于binlog复制，难免出现复制数据不一致的风险，导致用户数据访问前后不一致的问题<br>所以要定期开展主从复制数据一致性的校验并修复</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stata">使用Percona公司下的工具<br><br>pt-<span class="hljs-keyword">table</span>-<span class="hljs-keyword">checksum</span>工具进行一致性校验<br><br>  原理：<br>  主库利用表中的索引，将表的数据切割成一个个chunk(块)，然后进行计算得到<span class="hljs-keyword">checksum</span>值。<br>  从库也执相应的操作，并在从库上计算相同数据块的<span class="hljs-keyword">checksum</span>，然后对比主从中各个表的<span class="hljs-keyword">checksum</span>是否一致并存储到数据库，最后通过存储校验结果的表就可以判断出哪些表的数据不一致<br><br><br>pt-<span class="hljs-keyword">table</span>-sync(在从库执行)工具进行数据不一致的修复，可以修复主从结构数据的不一致，也可以修复非主从结构数据的不一致<br><br>  原理：在主库上执行数据的更改，再同步到从库上，不会直接更改成从的数据。在主库上执行更改是基于主库现有的数据，不会更改主库上的数据，可以同步某些表或整个库的数据，但它不会同步表结构、索引，只同步不一致的数据<br><br><br>注意：<br>  默认主库要检查的表在从库都存在，并且同主库表有相同的表结构<br>  如果表中没有索引，pt-<span class="hljs-keyword">table</span>-<span class="hljs-keyword">checksum</span>将没法处理，一般最基本的主键索引要有<br>  pt-<span class="hljs-keyword">table</span>-sync工具会修改数据，使用前最好备份下数据，防止误操作<br></code></pre></td></tr></table></figure><ul><li>pt-table-checksum怎么保证在计算某个chunk的时候checksum数据一致性？</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">当pt工具在计算主库上某chunk的<span class="hljs-keyword">checksum</span>时，主库可能在更新且从库可能复制延迟，那该怎么保证主库与从库计算的是”同一份”数据，答案把要<span class="hljs-keyword">checksum</span>的行加上<span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>锁并计算，这保证了主库的某个chunk内部数据的一致性<br></code></pre></td></tr></table></figure><h1 id="十二、HTTP协议"><a href="#十二、HTTP协议" class="headerlink" title="十二、HTTP协议"></a>十二、HTTP协议</h1><h2 id="1、HTTP协议核心知识"><a href="#1、HTTP协议核心知识" class="headerlink" title="1、HTTP协议核心知识"></a>1、HTTP协议核心知识</h2><p><strong>简介：http状态码和method知识点考查</strong></p><ul><li>考点：是否掌握Http基础知识，遵循开发规范</li><li>常见的Http Method有哪些，使用场景分别是？<ul><li><strong>HTTP 1.0</strong> 定义的三种：<ol><li>GET：向服务器获取资源，比如常见的查询请求</li><li>POST：向服务器提交数据而发送的请求</li><li>HEAD：和GET类似，返回的响应中没有具体的内容，用于获取报文头</li></ol></li><li><strong>HTTP 1.1</strong> 定义的六种：<ol><li>PUT：一般用于更新请求，比如更新个人信息、商品信息，采用全量更新</li><li>PATCH：是PUT方法的补充，更新指定资源的部分数据</li><li>DELETE：用于删除指定的资源</li><li>OPTIONS：获取服务器支持的HTTP请求方式，服务器性能、跨域检查等</li><li>CONNECT：把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据返回给用户；一般网页开发基本不用这个，如果是HTTP代理才会使用，类似于中介</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li></ol></li></ul></li><li>常见HTTP状态码有哪些？<ul><li>1XX：收到请求，需要请求者继续执行操作，很少使用</li><li>2XX：请求成功，常用的200</li><li>3XX：重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location中获取；网站改版、域名迁移等，多个域名指向同一个主站导流<ul><li>301 永久性跳转，比如域名过期，换个域名</li><li>302 临时性跳转</li></ul></li><li>4XX：客户端出错，比如语法错误、请求无法完成<ul><li>400 请求出错，比如语法协议</li><li>403 无访问权限</li><li>404 找不到路径对应的接口或者文件</li><li>405 提交方式错误，Method not allowed</li></ul></li><li>5XX：服务端出错，服务器在处理请求的过程中发生了错误<ul><li>500 服务器内部报错，无法完成请求</li><li>503 服务器宕机</li></ul></li></ul></li></ul><h2 id="2、HTTP协议无状态解决方法之Cookie和Session"><a href="#2、HTTP协议无状态解决方法之Cookie和Session" class="headerlink" title="2、HTTP协议无状态解决方法之Cookie和Session"></a>2、HTTP协议无状态解决方法之Cookie和Session</h2><p><strong>简介：单机情况下 http无状态解决方案，cookie和session</strong></p><ul><li>考点：是否掌握cookie和session知识点</li><li>说下Cookie和Session的区别和联系<ul><li>cookie数据保存在客户端；session数据保存在服务端</li><li>cookie不是很安全，容易泄露，不能直接明文存储信息</li><li>cookie存储的大小和数量有限制</li></ul></li></ul><h2 id="3、HTTP协议分布式业务无状态解决方法之JWT"><a href="#3、HTTP协议分布式业务无状态解决方法之JWT" class="headerlink" title="3、HTTP协议分布式业务无状态解决方法之JWT"></a>3、HTTP协议分布式业务无状态解决方法之JWT</h2><p><strong>简介：分布式业务场景的常见登录解决方案JWT</strong></p><ul><li><p>考点：是否知道JWT</p></li><li><p>你们公司是用JWT做集群的登录解决是不是，能否介绍下JWT</p><ul><li><p>JWT 是一个开放标准，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p></li><li><p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p><ul><li>Header 头部：主要描述签名的算法</li><li>Payload 负载：主要描述加密对象的信息，比如用户的id、iss签发者、exp过期时间、sub面向的用户等</li><li>Signature 签名：主要是把前面两部分进行加密吗，防止别人拿到token进行base解密之后篡改token</li></ul><p>因此，一个典型的JWT看起来是这个样子的：</p><blockquote><p>xxxxx.yyyyy.zzzzz</p></blockquote></li></ul></li></ul><p>简单来说: 就是通过一定规范来生成token，然后可以通过解密算法逆向解密token，这样就可以获取用户信息</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&#123;<br>          id:<span class="hljs-number">666</span>,<br>          <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>          expire:<span class="hljs-number">10000</span><br>      &#125;<br>          <br>      funtion 加密(<span class="hljs-keyword">object</span>, appsecret)&#123;<br>          xxxx<br>          <span class="hljs-keyword">return</span> base64( token);<br>      &#125;<br>      <br>      <span class="hljs-keyword">function</span> 解密(token ,appsecret)&#123;<br>          xxxx<br>          //成功返回<span class="hljs-keyword">true</span>,失败返回<span class="hljs-keyword">false</span><br>      &#125;<br></code></pre></td></tr></table></figure><ul><li>使用 JWT 的优缺点有哪些？<ul><li>优点：<ul><li>生成的token可以包含基本信息，比如id、昵称等信息，避免再次查库</li><li>存储在客户端，不需要占用服务端的内存资源，使用加解密的方式进行校验，在分布式业务中能较好地提高性能和节省空间</li></ul></li><li>缺点：<ul><li>token是经过base64编码的，所以是可以进行解码的，因此token加密前的对象不应该包含敏感信息，比如用户权限、密码等</li><li>如果没有服务端存储，则不能做登录失效处理，除非服务端该密钥</li></ul></li></ul></li><li>生成的token在客户端或者浏览器中具体是如何存储的？<ul><li>可以存储在cookie、localStorage、sessionStorage</li></ul></li></ul><h2 id="4、HTTP请求从产生到响应的链路"><a href="#4、HTTP请求从产生到响应的链路" class="headerlink" title="4、HTTP请求从产生到响应的链路"></a>4、HTTP请求从产生到响应的链路</h2><p><strong>简介：浏览器网络请求链路</strong></p><ul><li><p>考点：是否掌握http请求产生到响应的链路</p></li><li><p>说下常用浏览器输入一个 url 到用户看到结果，中间经过哪些流程？</p><ol><li>浏览器输入 url，解析 url 是否合法</li><li>浏览器检查是否有缓存，如果有则直接显示；没有就进行下一步</li><li>进行域名解析（DNS解析），解析获取对应的 IP 地址</li><li>浏览器向服务器发送 tcp 连接，完成 tcp 三次握手</li><li>握手成功后，浏览器向服务器发送 http 请求</li><li>服务器收到处理的请求后，将数据返回到浏览器</li><li>浏览器接受 http 响应</li><li>浏览器解析响应，如果响应需要缓存，则存入到缓存中</li><li>浏览器进行页面渲染</li></ol></li></ul><h2 id="5、浏览器同源策略和跨域"><a href="#5、浏览器同源策略和跨域" class="headerlink" title="5、浏览器同源策略和跨域"></a>5、浏览器同源策略和跨域</h2><p><strong>简介：什么是浏览器的同源策略和跨域知识点</strong></p><ul><li><p>考点：同源策略和跨域知识点</p></li><li><p>你是否知道什么是浏览器同源策略</p><ul><li><strong>同源策略</strong>：是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</li></ul><p>如果两个 URL 的 protocol、port(en-US)如果有指定的话) 和 host 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p><p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例：</p><p>| URL                                               | 结果 | 原因                                |<br>| :———————————————————————— | :—- | :————————————————— |<br>| <code>http://store.company.com/dir2/other.html</code>        | 同源 | 只有路径不同                        |<br>| <code>http://store.company.com/dir/inner/another.html</code> | 同源 | 只有路径不同                        |<br>| <code>https://store.company.com/secure.html</code>           | 失败 | 协议不同                            |<br>| <code>http://store.company.com:81/dir/etc.html</code>        | 失败 | 端口不同 ( <code>http://</code> 默认端口是 80) |<br>| <code>http://news.company.com/dir/other.html</code>          | 失败 | 主机不同                            |</p><ul><li>同源策略的限制<ul><li>不能读写Cookie、Session Storage、Local Storage、Cache、Indexed DB</li><li>DOM 和 JS对象无法获得</li><li>AJAX请求不能发送</li></ul></li></ul></li><li><p>为什么会出现跨域，有什么常见的解决方案?</p><ul><li><p><strong>跨域</strong>：浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任何一个不同，就属于跨域</p></li><li><p><strong>解决方案</strong>：</p><ul><li><p>JSONP</p></li><li><p>页面这层再包装一层服务，目前最多就是nodejs</p></li><li><p>Http响应头配置允许跨域</p><ul><li><p>nginx代理服务器</p></li><li><p>后端程序代码配置</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">程序代码中处理 SpringBoot 通过拦截器配置<br>     <br><span class="hljs-comment">//表示接受任意域名的请求,也可以指定域名</span><br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-params">request</span>.<span class="hljs-params">getHeader</span>(<span class="hljs-string">&quot;origin&quot;</span>)</span>);<br>     <br><span class="hljs-comment">//该字段可选，是个布尔值，表示是否可以携带cookie</span><br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)</span>;<br>     <br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS&quot;</span>)</span>;<br>     <br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h1 id="十三、Spring-Mybatis框架"><a href="#十三、Spring-Mybatis框架" class="headerlink" title="十三、Spring-Mybatis框架"></a>十三、Spring-Mybatis框架</h1><h2 id="1、Spring框架核心知识点"><a href="#1、Spring框架核心知识点" class="headerlink" title="1、Spring框架核心知识点"></a>1、Spring框架核心知识点</h2><p><strong>简介：常见的spring核心知识点考查</strong></p><ul><li><p>考点：spring的核心理念</p></li><li><p>能否介绍下什么是Spring框架的 IOC 和 DI </p><ul><li>IOC 控制反转：将对象的创建权，反转到Spring容器</li><li>DI 依赖注入：Spring创建对象的过程中，将对象依赖的属性通过配置的方式进行注入，在IOC的基础上完成</li></ul><p>IOC 和 DI 是从不同的角度描述同样的一件事，通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦</p></li><li><p>Spring里面 bean的scope作用域有哪些，能否解释下？</p><ul><li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次di奥永getBean方法时都会创建不同的对象，会频繁的创建和销毁对象。</li><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul></li></ul><h2 id="2、AOP面向切面编程"><a href="#2、AOP面向切面编程" class="headerlink" title="2、AOP面向切面编程"></a>2、AOP面向切面编程</h2><p><strong>简介：Spring常见面试题AOP</strong></p><ul><li><p>考点：Spring的AOP相关知识点考查</p></li><li><p>谈谈你对AOP的理解？</p><ul><li>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</li><li>AOP思想把功能分两个部分，分离系统中的各种关注点<ul><li>核心关注点<ul><li>业务的主要功能</li></ul></li><li>横切关注点<ul><li>非核心、额外增加的功能</li></ul></li><li>用户下单为例子<ul><li>核心关注点：创建订单</li><li>横切关注点：记录日志、控制事务</li></ul></li></ul></li><li>好处<ul><li>减少代码侵入，解耦</li><li>可以统一处理横切逻辑</li><li>方便添加和删除横切逻辑</li></ul></li></ul></li><li><p>能否解释下AOP里面常见的概念，比如 横切、通知、连接点、切入点、切面 ？</p><ul><li>横切关注点<ul><li>对哪些方法进行拦截，拦截后怎么处理，这些就叫横切关注点</li><li>比如 权限认证、日志、事务</li></ul></li><li>通知 Advice<ul><li>在特定的切入点上执行的增强处理</li><li>做啥？ 比如你需要记录日志，控制事务 ，提前编写好通用的模块，需要的地方直接调用</li></ul></li><li>连接点 JointPoint<ul><li>需要用到通知的地方，业务流程在运行过程中需要插入切面的具体位置，</li><li>一般是方法的调用前后，全部方法都可以是连接点</li><li>只是概念，没啥特殊</li></ul></li><li>切入点 Pointcut<ul><li>不能全部方法都是连接点，通过特定的规则来筛选连接点, 就是Pointcut，选中那几个你想要的方法</li><li>在程序中主要体现为书写切入点表达式（通过通配、正则表达式）过滤出特定的一组 JointPoint连接点</li><li>过滤出相应的 Advice 将要发生的joinpoint地方</li></ul></li><li>切面 Aspect<ul><li>通常是一个类，里面定义 <strong>切入点+通知</strong> , 定义什么地方、 什么时间点、做什么事情</li><li><strong>通知 advice指明了时间和做的事情（前置、后置等）</strong></li><li><strong>切入点 pointcut 指定在什么地方干这个事情</strong></li><li>web接口设计中，web层-&gt;网关层-&gt;服务层-&gt;数据层，每一层之间也是一个切面，对象和对象，方法和方法之间都是切面</li></ul></li><li><p>目标 target</p><ul><li>目标类，真正的业务逻辑，可以在目标类不知情的条件下，增加新的功能到目标类的链路上</li></ul></li><li><p>织入 Weaving</p><ul><li>把切面（某个类）应用到目标函数的过程称为织入</li></ul></li></ul></li></ul><p><img src="后端面试/image-24.png" alt=""></p><h2 id="3、Spring-AOP代理模式"><a href="#3、Spring-AOP代理模式" class="headerlink" title="3、Spring AOP代理模式"></a>3、Spring AOP代理模式</h2><p><strong>简介：Spring常见面试题静态代理和动态代理</strong></p><ul><li><p>考点：静态代理和动态代理知识点考查</p></li><li><p>能否解释下什么是静态代理？</p><ul><li>什么是静态代理<ul><li>由程序创建或特定工具自动生成源代码，在程序运行前，代理类的.class文件就已经存在</li><li>通过将目标类与代理类实现同一个接口，让代理类持有真实类对象，然后在代理类方法中调用真实类方法，在调用真实类方法的前后添加我们所需要的功能扩展代码来达到增强的目的</li></ul></li><li>优点<ul><li>代理使得客户端不需要知道实现类是什么，只需知道代理即可</li><li>方便增加功能，拓展业务逻辑</li></ul></li><li>缺点<ul><li>代理类中出现大量冗余的代码，非常不利于扩展和维护</li><li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度</li></ul></li></ul></li><li><p>能否解释下什么是动态代理？</p><ul><li>在程序运行时，运用反射机制动态创建而成，无需手动编写代码</li></ul></li><li>Spring AOP是用什么代理？<ul><li>Spring AOP 就是基于动态代理的<ul><li>如果要代理的对象，<strong>实现了某个接口</strong>，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象；</li><li>而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</li></ul></li></ul></li></ul><p><img src="后端面试/image-25.png" alt=""></p><h2 id="4、JDBC和Mybaits"><a href="#4、JDBC和Mybaits" class="headerlink" title="4、JDBC和Mybaits"></a>4、JDBC和Mybaits</h2><p><strong>简介：讲解JDBC和Mybatis基础面试题</strong></p><ul><li><p>考点：JDBC和Mybatis基础面试题考查</p></li><li><p>说下JDBC连接数据库的开发步骤</p><ol><li>加载数据库驱动 DriverManager</li><li>获取数据连接对象 Connection</li><li>获取语句对象<ul><li>语句对象分为Statement和PreparedStatement两种执行语句<ul><li>PreparedStatement在执行之前会进行预编译</li><li>效率高于Statement，且能够有效防止SQL注入</li><li>PreparedStatement支持?占位符，而不是直接拼接，提高可读性</li></ul></li></ul></li><li>处理结果集 ResultSet</li><li>关闭资源（需要注意关闭顺序及处理异常rs.close()、st.close()、conn.close()）</li></ol></li><li><p>能否简单说下Mybatis的四大核心对象及流程?</p><ol><li><p>SqlSession对象，该对象中包含了执行SQL语句的所有方法。类似于JDBC里面的Connection</p></li><li><p>Executor接口，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。类似于JDBC里面的Statement/PrepareStatement</p></li><li><p>MappedStatement对象，该对象是对映射SQL的封装，用于存储要映射的SQL语句的id、参数等信息</p></li><li><p>ResultHandler对象，用于对返回的结果进行处理，最终得到自己想要的数据格式或类型。可以自定义返回类型</p></li></ol></li></ul><p><img src="后端面试/image-26.png" alt=""></p><h2 id="5、Mybatis3-X-防止SQL注入"><a href="#5、Mybatis3-X-防止SQL注入" class="headerlink" title="5、Mybatis3.X 防止SQL注入"></a>5、Mybatis3.X 防止SQL注入</h2><p><strong>简介：mybatis3.x 防止sql注入知识点</strong></p><ul><li>考点：Mybatis防注入知识点考查</li><li>${}和#{ }的区别是什么?<ul><li>${}是字符串替换；#{ }是预编译处理；</li><li>在处理#{}时，会将SQL中的#{}替换为 ? 号，调用PreparedStatement的 set 方法来赋值；</li><li>在处理${}时，直接把${}替换成变量的值；</li><li>使用#{}可以有效防止SQL注入，提高系统安全性；</li></ul></li></ul><h2 id="6、Mybatis的多级缓存"><a href="#6、Mybatis的多级缓存" class="headerlink" title="6、Mybatis的多级缓存"></a>6、Mybatis的多级缓存</h2><p><strong>简介：讲解Mybatis多级缓存面试题</strong></p><ul><li>考点：Mybatis多级缓存知识点</li><li>有没用过Mybatis一级缓存，能否介绍下？<ul><li>简介：一级缓存的作用域是SqlSession，同一个SqlSession中执行相同的SQL查询（相同的SQL和参数），第一次回去查询数据库并写入缓存，第二次直接去缓存中获取</li><li>基于PerpetualCache 的 HashMap本地缓存，默认开启一级缓存</li><li><strong>失效策略</strong>：当执行SQL时两次查询的中间发生了增删改的操作，即insert、update、delete等操作，commit后会清空该SqlSession缓存；比如SqlSession关闭、清空等</li></ul></li><li>有没用过Mybatis二级缓存，能否介绍下？<ul><li>简介：当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个<strong>共同的 cache</strong>，也就是二级缓存被多个 SqlSession 共享，是一个<strong>全局的变量</strong>。当开启缓存后，数据的查询执行的流程就是 <strong>二级缓存 -&gt; 一级缓存 -&gt; 数据库</strong></li><li>基于PerpetualCache 的 HashMap本地缓存，可自定义存储源，如 Ehcache/Redis等；默认不开启二级缓存</li><li><strong>操作流程</strong>：<ul><li>第一次调用某个namespace下的SQL去查询信息，查询到的信息会存放该mapper对应的二级缓存区域。</li><li>第二次调用同个namespace下的mapper映射文件中，相同的sql去查询信息，会去对应的二级缓存内取结果</li></ul></li><li><strong>失效策略</strong>：执行同个namespace下的mapepr映射文件中的增删改sql，并执行了commit操作,会清空该二级缓存</li><li><strong>注意</strong>：实现二级缓存的时候，MyBatis建议返回的POJO是可序列化的， 也就是建议实现Serializable接口</li><li><strong>缓存淘汰策略</strong>：会使用默认的 LRU 算法来收回（最近最少使用的）</li></ul></li></ul><p><img src="后端面试/image-27.png" alt=""></p><h2 id="7、Mybatis3-X-懒加载"><a href="#7、Mybatis3-X-懒加载" class="headerlink" title="7、Mybatis3.X 懒加载"></a>7、Mybatis3.X 懒加载</h2><p><strong>简介：mybatis3.x懒加载面试题</strong></p><ul><li><p>考点：Mybatis懒加载知识点</p></li><li><p>什么是Mybatis3.X的懒加载？</p><ul><li>按需加载，先查单表，有需要再从关联表查询，能提高数据库性能（并不是所有场景都能够提高）</li><li>在mybatis中，resultMap可以实现高级映射(使用association一对一、collection一对多映射)，association、collection具备延迟加载功能。</li></ul></li></ul><h1 id="十四、Redis"><a href="#十四、Redis" class="headerlink" title="十四、Redis"></a>十四、Redis</h1><h2 id="1、Redis的基础数据类型"><a href="#1、Redis的基础数据类型" class="headerlink" title="1、Redis的基础数据类型"></a>1、Redis的基础数据类型</h2><p><strong>简介：分布式缓存Redis核心基础</strong></p><ul><li>考点：Redis基础知识点考查</li><li>你们业务用了redis，为啥不用其他缓存，比如memcached呢？<ul><li>Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为 丰富的数据类</li><li>Redis 的速度比 Memcached 快很</li><li>Redis 可以持久化其数据</li></ul></li><li>你用过Redis哪些数据结构？ 说下这些结构的使用场景有哪些？<ul><li>String<ul><li>简单的kv存储；验证码、分布式锁、热点商品卡片</li></ul></li><li>hash<ul><li>存储对象，一个key有多个值；购物车、商品详情</li></ul></li><li>list<ul><li>列表型数据、消息队列等；最新评论列表、非实时排行榜</li></ul></li><li>set<ul><li>无序集合、去重，交集、并集等；查看共同好友，在社交关系方面、数据排重等可以使用</li></ul></li><li>sroted set<ul><li>有序集合，去重；实时排行榜</li></ul></li></ul></li><li>redis是单线程，为什么这么快？<ul><li>基于内存，绝大部分请求是纯粹的内存操作</li><li>避免了不必要的CPU上下文切换和其他竞争条件，比如锁操作等</li><li>底层是使用多路I/O复用模型，非阻塞IO</li><li>redis 利用队列技术将并发访问变为串行访问，消除了传统数据库 串行控制的开销</li><li>redis6支持多线程，但只是用来处理网络数据的读写和协议解析上，<strong>底层数据操作还是单线程</strong></li></ul></li></ul><h2 id="2、Redis的持久化机制"><a href="#2、Redis的持久化机制" class="headerlink" title="2、Redis的持久化机制"></a>2、Redis的持久化机制</h2><p><strong>简介：Redis的持久化机制</strong></p><ul><li><p>考点：Redis的持久化机制考查</p></li><li><p>Redis 的持久化机制是什么？各自的优缺点？</p><ul><li><strong>RDB持久化</strong>：是指用数据集快照的方式半持久化存储，记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复<ul><li><strong>优点</strong>： <ul><li>只有一个文件 dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以 是 IO 最大化。使 用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ul></li><li><strong>缺点</strong>： 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li></ul></li><li><strong>AOF持久化</strong>：指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储，保存为 aof 文件<ul><li><strong>优点</strong>：<ul><li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis- check-aof 工具解决数据一致性问题</li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li></ul></li><li><strong>缺点</strong>：<ul><li>AOF 文件比 RDB 文件大，且恢复速慢</li><li>数据集大的时候，比 rdb 启动效率低。</li></ul></li></ul></li></ul></li></ul><h2 id="3、Redis的内存淘汰策略"><a href="#3、Redis的内存淘汰策略" class="headerlink" title="3、Redis的内存淘汰策略"></a>3、Redis的内存淘汰策略</h2><p><strong>简介：缓存的淘汰策略</strong></p><ul><li>考点：是否有看过缓存设计的知识点</li><li>能分别说下FIFO、LRU、LFU这些策略不？<ul><li>先进先出First In，First Out<ul><li>新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动，淘汰FIFO队列头部的数据</li></ul></li><li>最近最少使用算法 Least recently used<ul><li>根据数据的历史访问记录来进行数据淘汰，从设置了过期时间的键中选择空转时间最长的键值对清除掉</li><li>新数据插入到链表头部，每当缓存数据被访问，则将数据移到链表头部，当链表满的时候，将链表尾部的数据丢弃</li></ul></li><li>最近使用频率最低算法 Least Frequently Used<ul><li>根据数据的历史访问频率来淘汰数据，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉</li><li>把数据加入到链表中，按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉</li></ul></li></ul></li></ul><h2 id="4、缓存穿透、击穿、雪崩"><a href="#4、缓存穿透、击穿、雪崩" class="headerlink" title="4、缓存穿透、击穿、雪崩"></a>4、缓存穿透、击穿、雪崩</h2><p><strong>简介：缓存穿透、击穿和雪崩你是否可以区分</strong></p><ul><li><p>考点：缓存穿透-击穿-雪崩知识点</p></li><li><p>能否说下缓存穿透、击穿、雪崩，及其预防方案？</p><ul><li><p><strong>缓存穿透</strong></p><ul><li><p>问题描述：</p><p>大量并发查询不存在的 KEY ，在缓存和数据库中都不存在，同时给缓存和数据库带来压力。<code>如：用一个不存在的用户id获取用户信息，这也是黑客利用不存在的key频繁攻击应用的一种方式</code></p></li><li><p>解决方案：</p><ul><li>接口层增加校验，对数据的合理性进行校验。<code>如：用户鉴权校验，id 做基础校验，id&lt;=0直接拦截</code></li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，设置一个短的过期时间，防止同个key被一直攻击</li><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li></ul></li><li><p>SpringCache解决：</p><p> 空结果也缓存，防止缓存穿透</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># 指定缓存类型</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-comment"># 是否缓存空结果，防止缓存穿透，默认为true</span><br>      <span class="hljs-attr">cache-null-values:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>缓存击穿</strong></p><ul><li><p>问题描述：</p><p> 缓存中没有但数据库中有的数据（一般是缓存时间到期），当这个热点key在过期的一瞬间，正好有大量的并发请求访问这个key，这些请求都会击穿到数据库，造成瞬时数据库请求量大、压力增大</p></li><li><p>解决方案：</p><ul><li>设置热点数据不过期</li><li>采用定时任务定时更新缓存</li><li>设置互斥锁</li></ul></li><li><p>SpringCache解决：</p><p> 缓存的同步 sync，sync 可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存中</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Cacheable</span>(<span class="hljs-keyword">sync</span>=<span class="hljs-keyword">true</span>)<br>Copy<br></code></pre></td></tr></table></figure><p>@Cacheable注解中的sync属性，当设置它为true时，只有一个线程的请求会去到数据库，其他线程都会等待直到缓存可用。这个设置可以减少对数据库的瞬间并发访问</p></li></ul></li><li><p><strong>缓存雪崩</strong></p><ul><li><p>问题描述：</p><p> 大量的key设置了相同的过期时间，导致缓存在同一时刻大面积的失效，造成大量的请求无法获取缓存，从而将流量压力传导到数据库上，引起雪崩</p></li><li><p>解决方案：</p><ul><li>在原有失效时间基础上增加一个随机值，防止同一时间大量数据过期现象发生</li><li>使用的热数据尽量分散在不同的机器上</li><li>设置热点数据永远不过期，定时任务定时更新</li></ul></li><li><p>SpringCache解决：</p><ul><li>CacheManager配置多个不同过期时间维度</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列RabbitMQ的集群模式</title>
    <link href="/2022/03/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、RabbitMQ的集群模式"><a href="#一、RabbitMQ的集群模式" class="headerlink" title="一、RabbitMQ的集群模式"></a>一、RabbitMQ的集群模式</h1><ul><li><strong>单机模式</strong><ul><li>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li></ul></li></ul><p>&lt;/br&gt;</p><ul><li><p><strong>普通集群模式（无高可用性）</strong></p><ul><li>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</li></ul><p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-1.png" alt="image-1"></p><ul><li>这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</li><li>而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</li><li>所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，<strong>这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</strong></li></ul></li></ul><p>&lt;/br&gt;</p><ul><li><p><strong>镜像集群模式（高可用性）</strong></p><ul><li>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</li></ul><p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-2.png" alt="image-2"></p><ul><li><strong>那么如何开启这个镜像集群模式呢？</strong>其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li><li><strong>镜像集群的好处：</strong><ul><li>你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。</li></ul></li><li><strong>镜像集群的坏处：</strong><ul><li>第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！</li><li>第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li></ul></li></ul></li></ul><p>&lt;/br&gt;</p><h1 id="二、集群中的节点类型"><a href="#二、集群中的节点类型" class="headerlink" title="二、集群中的节点类型"></a>二、集群中的节点类型</h1><ul><li>内存节点：ram,保存状态到内存，但持久化的队列和消息还是会保存到磁盘；</li><li>磁盘节点：disc,保存状态到内存和磁盘，一个集群中至少需要一个磁盘节点；</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列RabbitMQ的死信队列和“延迟队列”</title>
    <link href="/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%92%8C%E2%80%9C%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E2%80%9D/"/>
    <url>/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%92%8C%E2%80%9C%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、RabbitMQ的死信队列"><a href="#一、RabbitMQ的死信队列" class="headerlink" title="一、RabbitMQ的死信队列"></a>一、RabbitMQ的死信队列</h1><p><strong>TTL是什么？</strong></p><ul><li>TTL（Time To Live），即存活时间</li><li>RabbitMQ支持两种方式设置TTL<ul><li>单独对消息本身设置，每条消息的 TTL 可以不同。<ul><li>expiration 单位ms(毫秒)</li></ul></li><li>通过队列属性设置，队列中所有消息都有相同的存活时间。<ul><li>x-message-ttl 单位ms(毫秒)</li></ul></li></ul></li><li>注意：如果两种方式同时使用，则消息的 TTL 以两者之间较小的数值为准。</li></ul><p><strong>消息在什么情况会成为死信（Dead Message）</strong></p><ul><li>消费者拒收消息<strong>（ basic.reject/ basic.nack ）</strong>，并且不再重新入队 <strong>requeue=false</strong></li><li>消息 TTL 超时</li><li>队列达到最大长度</li></ul><p><strong>死信队列是什么？</strong></p><ul><li>没有被及时消费的消息存放的队列，即死信队列</li></ul><p><strong>死信交换机是什么？</strong></p><ul><li>DLX，全称为 <code>Dead-Letter-Exchange</code> ，当消息成为死信后，会被重新发送到另一个交换机，这个交换机就是 DLX 死信交换机。</li></ul><p><img src="/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%92%8C%E2%80%9C%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E2%80%9D/image-1.png" alt="image-1"></p><ul><li>注意：消息成为死信后，如果原队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列</li></ul><h1 id="二、RabbitMQ的“延迟队列”"><a href="#二、RabbitMQ的“延迟队列”" class="headerlink" title="二、RabbitMQ的“延迟队列”"></a>二、RabbitMQ的“延迟队列”</h1><p><strong>延迟队列是什么？</strong></p><ul><li>一种带有延迟功能的消息队列，Producer 将消息发送到消息队列 服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费，该消息即定时消息。</li><li>注意：在 RabbitMQ 中不存在延迟队列，但可以通过设置消息的 TTL 和死信队列来模拟延迟队列。<ul><li>消费者监听与死信交换机绑定的队列，而不要监听消息发送的队列。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置属性，消息10秒钟过期</span><br>AMQP.BasicProperties properties = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder()<br>.expiration(<span class="hljs-string">&quot;10000&quot;</span>) <span class="hljs-comment">// TTL</span><br><br><span class="hljs-comment">// 指定队列的死信交换机</span><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Object</span>&gt; <span class="hljs-built_in">arguments</span> = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Object</span>&gt;();<br><span class="hljs-built_in">arguments</span>.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,<span class="hljs-string">&quot;DLX_EXCHANGE&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>延迟队列的使用场景</strong></p><ul><li>通过消息触发一些定时任务，比如在某一固定时间点向用户发送提醒消息；</li><li>用户登录之后5分钟给用户做分类推送、用户多少天未登录给用户做召回推送；</li><li>消息生产和消费有时间窗口要求：比如在天猫电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条延时消息。这条消息将会在 30 分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。 如支付未完成，则关闭订单。如已完成支付则忽略。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列RabbitMQ如何保证消息的幂等性、可靠性、顺序性</title>
    <link href="/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7/"/>
    <url>/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="一、如何保证消息的幂等性"><a href="#一、如何保证消息的幂等性" class="headerlink" title="一、如何保证消息的幂等性"></a>一、如何保证消息的幂等性</h1><p><strong>幂等性是什么？</strong></p><ul><li>通俗点说，就一个数据或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的</li><li>保证同一条消息不会重复或者重复消费了也不会对系统数据造成异常</li></ul><p><strong>哪些情况会导致重复消费？</strong></p><ul><li>在生产者发送消息给rabbitMQ服务器的时候，有可能因为网络波动等情况，导致生产者收不到rabbitMQ服务器的应答，导致生产者再发送一条消息。</li><li>也是因为网络波动等问题，导致rabbitMQ服务器在向消费者发送消息的时候，没有收到消费者的应答，重复向消费者发生消息。</li></ul><p><strong>如何保证消息的幂等性</strong>？</p><ul><li>在消息生产时，MQ内部针对每条生产者发送的消息都会生成一个<code>inner-msg-id</code>作为去重和幂等的依据（消息传递失败并重传），避免重复的消息进入队列；</li><li>在消息消费时，要求消息体中必须要有一个<code>bizid</code>（对于同一业务全局唯一，如支付ID、订单ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</li></ul><p>结合业务逻辑可以选择以下几种<strong>解决方案：</strong></p><ul><li>拿到这个消息做数据库的 <code>insert</code> 操作。给这个消息一个唯一主键，那么即使出现重复消费的情况，也会因为主键冲突，而避免数据库出现脏数据。</li><li>拿到这个消息做Redis的 <code>set</code> 操作，无论你 <code>set</code> 几次结果都一样，<code>set</code> 操作本身就算是幂等操作。</li><li>用第三方介质来做消费记录。如Redis；给消息分配一个全局ID，只要消费过此消息，将<id,message>以key-value的形式写入Redis。在消费者开始消费之前，先去Redis中查询有没有消费记录即可。</id,message></li></ul><h1 id="二、如何保证消息的可靠性"><a href="#二、如何保证消息的可靠性" class="headerlink" title="二、如何保证消息的可靠性"></a>二、如何保证消息的可靠性</h1><ul><li><p><strong>可能发生消息丢失情况的阶段</strong></p><ul><li><strong>Producer 发送消息到 Broker 失败</strong>；（发送过程中网络波动、发送到一个不存在的 Exchange等）</li><li><strong>Exchange 路由到 Queue 失败</strong>；Exchange 将消息根据 RoutingKey 路由到对应的 Queue 时失败；（此 Exchange 没有绑定 Queue 等）</li><li><strong>Consumer 处理消息失败</strong>；已经获取了消息但无法正确处理导致消息丢失（消费者来不及处理就挂掉了等）</li></ul><p><br></p></li></ul><p>针对以上可能发生消息丢失的情况可以采取对应的<strong>解决方案：</strong></p><p><strong>① Producer 发送消息到 Broker 失败 情况的解决方案：</strong></p><ul><li><p><strong>transaction 机制：</strong></p><ul><li>生产者发送数据之前开启 RabbitMQ 的事务 <code>channel.txSelect</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback</code> ，然后重试发送消息；如果收到了消息，那么可以提交事务<code>channel.txCommit</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>开启事务<br>channel.txSelect<br>try &#123;<br>    <span class="hljs-regexp">//</span>这里发送消息<br>&#125; catch (Exception e) &#123;<br>    channel.txRollback<br>    <span class="hljs-regexp">//</span>回滚事务后，这里重试发送消息<br>&#125;<br><span class="hljs-regexp">//</span>提交事务<br>channel.txCommit<br></code></pre></td></tr></table></figure><ul><li>采用该种方法由于事务机制，会导致吞吐量下降，太消耗性能。</li></ul></li><li><p><strong>confirm机制：</strong>（推荐使用）</p><ul><li>使用 SpringBoot 时在 application.yml 配置文件中做如下配置</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># 发送者开启 confirm 确认机制</span><br><span class="hljs-title">publisher</span>-confirm-<span class="hljs-class"><span class="hljs-keyword">type</span>: correlated</span><br></code></pre></td></tr></table></figure><ul><li>通过<strong>confirmCallback</strong>生产者投递消息后，如果Broker收到消息后，会给生产者一个ACK。生产者通过ACK，可以确认这条消息是否正常发送到Broker，这种方式是消息可靠性投递的核心。</li><li>一旦 channel 进入 confirm 模式，所有在该 channel 上的消息都会被指派一个以为的ID（从1开始），一旦消息被投递到所有匹配到的队列之后，RabbitMQ 就会发送一个 <code>ACK</code> 给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了。如果 RabbitMQ 没能处理该消息，则会发送一个 <code>Nack</code> 消息给你，你可以进行重试操作。</li></ul></li><li><p><strong>注意：</strong>transaction 机制和 confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</p><p><br></p></li></ul><p><strong>② Exchange 路由到 Queue 失败 情况的解决方案：</strong></p><ul><li><p><strong>开启 RabbitMQ 的持久化机制</strong></p><ul><li>消息写入之后会持久化到磁盘，哪怕 RabbitMQ 挂了，重启之后会自动读取之前存储的数据，一般数据不会丢失。<strong>特殊情况：除非 RabbitMQ 还没持久化就已经挂了，此时会导致少量数据丢失。</strong></li><li>解决特殊情况，<strong>持久化机制和 confirm 机制配合使用</strong>；可以在消息持久化磁盘之后，再给生产者发送一个 <code>ACK</code> ，这样，如果消息持久化磁盘之前，RabbitMQ 挂掉了，那么生产者收不到 <code>ACK</code> ，生产者也会自动重发处理。 </li><li>通过<strong>returnCallback</strong>，消息从交换器发送到对应队列失败时触发</li></ul></li></ul><p>   <br></p><p><strong>③ Consumer 处理消息失败 情况的解决方案：</strong></p><ul><li><p><strong>关闭自动<code>ACK</code>，使用手动<code>ACK</code></strong></p><ul><li>使用 SpringBoot 时在 application.yml 配置文件中做如下配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">listener:</span><br><span class="hljs-attr">simple:</span><br>    <span class="hljs-comment"># 设置消费端手动 ack</span><br>    <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br></code></pre></td></tr></table></figure><ul><li>如果消费者来不及处理就挂掉了，没有响应<code>ACK</code>时会重复发送一条信息给其他的消费者</li><li>如果出现了异常，且不对异常进行捕获，就会一直重复接受消息，然后一直抛异常。</li><li>如果对异常进行了捕获，但是没有在 finally 里<code>ACK</code>，也会一直重复发送消息（<strong>重试机制</strong>）</li><li>我们只需要保证幂等性就好了，重复消费也不会造成问题。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@RabbitHandler<br>public void handler<span class="hljs-constructor">Mq(String <span class="hljs-params">msg</span>, Channel <span class="hljs-params">channel</span>, Message <span class="hljs-params">message</span>)</span> throws IOException &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//业务处理代码</span><br>...... <br><span class="hljs-comment">//手动ACK</span><br>channel.basic<span class="hljs-constructor">Ack(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>);<br>&#125; catch (Exception e) &#123;<br><span class="hljs-keyword">if</span> (message.get<span class="hljs-constructor">MessageProperties()</span>.get<span class="hljs-constructor">Redelivered()</span>) &#123;<br>log.error(<span class="hljs-string">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>, e);<br><span class="hljs-comment">//拒绝消息</span><br>channel.basic<span class="hljs-constructor">Reject(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.error(<span class="hljs-string">&quot;消息即将再次返回队列处理...&quot;</span>, e);<br>channel.basic<span class="hljs-constructor">Nack(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="三、如何保证消息的顺序性"><a href="#三、如何保证消息的顺序性" class="headerlink" title="三、如何保证消息的顺序性"></a>三、如何保证消息的顺序性</h1><p><strong>出现消费顺序错乱的情况①：</strong></p><ul><li><strong>一个queue存在多个consumer</strong></li></ul><p><img src="/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7/image-1.png" alt="image-1"></p><ul><li><strong>解决方案：</strong>将原来的一个queue拆分成多个queue，每个queue都有一个自己的consumer。该种方案的核心是生产者在投递消息的时候<strong>根据业务数据关键值（例如订单ID哈希值对订单队列数取模）来将需要保证先后顺序的同一类数据（同一个订单的数据）</strong> 发送到同一个queue当中</li></ul><p><img src="/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7/image-2.png" alt="image-3"></p><p>   <br></p><p><strong>出现消费顺序错乱的情况②：</strong></p><ul><li><strong>一个queue只存在一个consumer，但consumer中使用了多线程进行处理</strong></li></ul><p><img src="/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7/image-3.png" alt="image-3"></p><ul><li><strong>解决方案：</strong>在consumer中维护<strong>多个内存队列</strong>，<strong>根据业务数据关键值（例如订单ID哈希值对内存队列数取模）将消息加入到不同的内存队列中</strong>，然后多个真正负责处理消息的线程去各自对应的内存队列当中获取消息进行消费。</li></ul><p><img src="/2022/03/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7/image-4.png" alt="image-4"></p><p>   <br></p><p><strong>RabbitMQ保证消息顺序性总结：</strong><br>核心思路就是根据业务数据关键值划分成多个消息集合，而且每个消息集合中的消息数据都是有序的，每个消息集合有自己独立的一个consumer。多个消息集合的存在保证了消息消费的效率，每个有序的消息集合对应单个的consumer保证了消息消费时的顺序性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列RabbitMQ的五种工作模式</title>
    <link href="/2022/03/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、simple简单（最简单的收发模式）"><a href="#一、simple简单（最简单的收发模式）" class="headerlink" title="一、simple简单（最简单的收发模式）"></a>一、simple简单（最简单的收发模式）</h1><ul><li>一个生产、一个消费，不用指定交换机，使用默认交换机</li></ul><h1 id="二、work工作队列（资源的竞争）"><a href="#二、work工作队列（资源的竞争）" class="headerlink" title="二、work工作队列（资源的竞争）"></a>二、work工作队列（资源的竞争）</h1><ul><li>一个生产，多个消费，有轮询策略和公平策略，不用指定交换机，使用默认交换机<ul><li>轮询：一个消费者消费一条，直至消息消费完，<strong>平均分配</strong></li><li>公平：根据消费者的消费能力进行公平分发，处理得快的分得多，处理的慢的分得少，<strong>能者多劳</strong><ul><li>将消息置为手动确认模式，且将预置队列数为1（prefetchCount=1）</li></ul></li></ul></li></ul><h1 id="三、publish-subscribe发布订阅（共享资源）"><a href="#三、publish-subscribe发布订阅（共享资源）" class="headerlink" title="三、publish/subscribe发布订阅（共享资源）"></a>三、publish/subscribe发布订阅（共享资源）</h1><ul><li>fanout类型交换机，通过交换机和队列绑定，<strong>不用指定绑定的路由健</strong>，生产者将消息发送给broker，由交换机将消息转发到绑定此交换机的每个队列，所有绑定同一个fanout交换机的队列都将接收到消息</li></ul><h1 id="四、routing路由"><a href="#四、routing路由" class="headerlink" title="四、routing路由"></a>四、routing路由</h1><ul><li>direct类型交换机，通过交换机和队列绑定，<strong>需要指定绑定的路由健</strong>，生产者发送消息到broker，由交换机根据消息的RoutingKey转发到对应的队列，对应的消费者才能接收到消息</li></ul><h1 id="五、topic主题（通配符）"><a href="#五、topic主题（通配符）" class="headerlink" title="五、topic主题（通配符）"></a>五、topic主题（通配符）</h1><ul><li>topic交换机，通过交换机和队列绑定，<strong>指定绑定的【通配符路由健】</strong>，生产者发送消息到broker，由交换机根据消息的RoutingKey转发到对应的队列，对应的消费者才能接收到消息<ul><li>* 代表一个词，#代表1个或多个词，一般用#作为通配符居多</li><li>比如 #.order 会匹配 info.order 、sys.error.order, 而 *.order 只会匹配 info.order  词之间是使用 . 点进行分割</li><li>如果只使用点 . 则info.order、error.order都会匹配</li><li>生产者发送消息时需要使用具体的路由健</li></ul></li></ul><p><strong>结合官方文档学习</strong>：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列RabbitMQ核心概念</title>
    <link href="/2022/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、RabbitMQ消息队列介绍"><a href="#一、RabbitMQ消息队列介绍" class="headerlink" title="一、RabbitMQ消息队列介绍"></a>一、RabbitMQ消息队列介绍</h1><ul><li>RabbitMQ：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a><ul><li>是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、C、用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不错，与SpringAMQP完美的整合、API丰富易用</li><li>文档：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></li></ul></li></ul><h1 id="二、RabbitMQ核心概念"><a href="#二、RabbitMQ核心概念" class="headerlink" title="二、RabbitMQ核心概念"></a>二、RabbitMQ核心概念</h1><ul><li>核心概念, 了解了这些概念，是使用好RabbitMQ的基础</li></ul><p><img src="/2022/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image-1.png" alt="image-1"></p><ul><li><p>Broker</p><ul><li>RabbitMQ的服务端程序，可以认为一个mq节点就是一个broker</li></ul></li><li><p>Producer生产者</p><ul><li>创建消息Message，然后发布到RabbitMQ中</li></ul></li><li><p>Consumer消费者:</p><ul><li>消费队列里面的消息</li></ul></li><li><p>Message 消息</p><ul><li>生产消费的内容，有消息头和消息体，也包括多个属性配置，比如routingKey路由键</li></ul></li><li><p>Queue 队列</p><ul><li>是RabbitMQ 的内部对象，用于存储消息，消息都只能存储在队列中</li></ul></li><li><p>Channel 信道</p><ul><li>一条支持多路复用的通道，独立的双向数据流通道，可以发布、订阅、接收消息。</li><li>信道是建立在真实的TCP连接内的虚拟连接，复用TCP连接的通道</li></ul></li><li><p>Connection连接</p><ul><li>是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑，一个连接上可以有多个channel进行通信</li></ul></li><li><p>Exchange 交换器</p><ul><li>生产者将消息发送到 Exchange，交换器将消息路由到一个或者多个队列中，里面有多个类型，后续再一一介绍，队列和交换机是多对多的关系。</li></ul></li><li><p>RoutingKey 路由键</p><ul><li>生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则</li><li>最大长度255 字节</li></ul></li><li><p>Binding 绑定</p><ul><li>通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键 ( BindingKey )，这样 RabbitMQ 就知道如何正确地将消息路由到队列了</li><li>生产者将消息发送给交换器时，需要一个RoutingKey，只有当BindingKey和RoutingKey相匹配时，消息才会被路由到对应的队列中</li></ul></li><li><p>Virtual host 虚拟主机</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">vhost可以理解为虚拟<span class="hljs-keyword">broker，即mini-RabbitMQ </span>server<br>其内部均含有独立的queue、exchange和<span class="hljs-keyword">binding等</span><br><span class="hljs-keyword"></span>拥有独立的权限系统，可以做到vhost范围的用户控制，更多用作不同权限的隔离<br></code></pre></td></tr></table></figure><ul><li>用于不同业务模块的逻辑隔离<ul><li>一个Virtual Host里面可以有若干个Exchange和Queue</li><li>同一个VirtualHost 里面不能有相同名称的Exchange或Queue</li></ul></li><li>默认是 /</li></ul></li></ul><h1 id="三、RabbitMQ交换机介绍"><a href="#三、RabbitMQ交换机介绍" class="headerlink" title="三、RabbitMQ交换机介绍"></a>三、RabbitMQ交换机介绍</h1><ul><li>RabbitMQ的Exchange交换机<ul><li>生产者将消息发送到 Exchange，交换器将消息路由到一个或者多个队列中，交换机有多个类型，队列和交换机是多对多的关系。</li><li>交换机只负责转发消息，不具备存储消息的能力，如果没有队列和exchange绑定，或者没有符合的路由规则，则消息会被丢失</li><li>RabbitMQ有四种交换机类型，分别是Direct exchange、Fanout exchange、Topic exchange、Headers exchange</li></ul></li><li>交换机类型<ul><li>Direct Exchange 定向<ul><li>将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配</li><li>例子：如果一个队列绑定到该交换机上要求路由键 “aabb”，则只有被标记为“aabb”的消息才被转发，不会转发aabb.cc，也不会转发gg.aabb，只会转发aabb</li><li>处理路由健</li></ul></li><li>Fanout Exchange 广播<ul><li>只需要简单的将队列绑定到交换机上，一个被发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息</li><li>Fanout交换机转发消息是最快的，用于发布订阅，广播形式。</li><li>不处理路由健</li></ul></li><li>Topic Exchange 通配符<ul><li>主题交换机是一种发布/订阅的模式，结合了直连交换机与扇形交换机的特点</li><li>将路由键和某模式进行匹配。此时队列需要绑定到一个模式上</li><li>符号“#”匹配一个或多个词，符号“*”只匹配一个词</li><li>例子：因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.*” 只会匹配到“abc.def”。</li></ul></li><li>Headers Exchanges（很少使用）<ul><li>根据发送的消息内容中的headers属性进行匹配, 在绑定Queue与Exchange时指定一组键值对</li><li>当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；</li><li>如果完全匹配则消息会路由到该队列，否则不会路由到该队列</li><li>不处理路由键</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列JMS和AMQP</title>
    <link href="/2022/03/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97AMQP%E5%92%8CJMS/"/>
    <url>/2022/03/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97AMQP%E5%92%8CJMS/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JMS介绍"><a href="#一、JMS介绍" class="headerlink" title="一、JMS介绍"></a>一、JMS介绍</h1><ul><li><p>什么是JMS：</p><ul><li>JMS是Java消息服务（Java Message Service),Java平台中关于面向消息中间件的接口</li><li><p>JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API</p></li><li><p>是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive</p></li><li><p>JMS是针对java的，那微软开发了NMS（.NET消息传递服务）</p></li></ul></li><li><p>常见概念：</p><ul><li>JMS提供者：连接面向消息中间件的，JMS接口的一个实现，RocketMQ,ActiveMQ,Kafka等等</li><li>JMS生产者(Message Producer)：生产消息的服务</li><li>JMS消费者(Message Consumer)：消费消息的服务</li><li>JMS消息：数据对象</li><li>JMS队列：存储待消费消息的区域</li><li>JMS主题：一种支持发送消息给多个订阅者的机制</li><li>JMS消息通常有两种类型：点对点（Point-to-Point)、发布/订阅（Publish/Subscribe）</li></ul></li><li><p>特性：</p><ul><li>面向Java平台的标准消息传递API</li><li>在Java或JVM语言比如Scala、Groovy中具有互用性</li><li>无需担心底层协议</li><li>有queues和topics两种消息传递模型</li><li>支持事务、能够定义消息格式（消息头、属性和内容）</li></ul></li></ul><h1 id="二、AMQP介绍"><a href="#二、AMQP介绍" class="headerlink" title="二、AMQP介绍"></a>二、AMQP介绍</h1><ul><li><p>什么是AMQP：</p><ul><li>AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题,就是是一种协议，兼容JMS</li><li>更准确说的链接协议 binary- wire-level-protocol 直接定义网络交换的数据格式，类似http</li><li>具体的产品实现比较多，RabbitMQ就是其中一种</li></ul></li><li><p>特性</p><ul><li>独立于平台的底层消息传递协议</li><li>消费者驱动消息传递</li><li>跨语言和平台的互用性、属于底层协议</li><li>有5种交换类型direct，fanout，topic，headers，system</li><li>面向缓存的、可实现高性能、支持经典的消息队列，循环，存储和转发</li><li>支持长周期消息传递、支持事务（跨消息队列）</li></ul></li></ul><h1 id="三、JMS和AMQP的对比"><a href="#三、JMS和AMQP的对比" class="headerlink" title="三、JMS和AMQP的对比"></a>三、JMS和AMQP的对比</h1><p><img src="/2022/03/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97AMQP%E5%92%8CJMS/image-1.png" alt="image-1"></p><div class="table-container"><table><thead><tr><th></th><th>JMS</th><th>AMQP</th></tr></thead><tbody><tr><td>定义</td><td>Java API</td><td>Wire-protocol （协议）</td></tr><tr><td>跨语言</td><td>否</td><td>是</td></tr><tr><td>跨平台</td><td>否</td><td>是</td></tr><tr><td>Model</td><td>提供两种消息模型：<br>（1）Peer-2-Peer<br>（2）Pub/sub<br><br><br><br></td><td>提供了五种消息模型：<br>（1）direct exchange<br>（2）fanout exchange<br>（3）topic change<br>（4）headers exchange<br>（5）system exchange<br></td></tr><tr><td>支持消息类型</td><td>多种消息类型：<br>TextMessage<br>MapMessage<br>BytesMessage<br>StreamMessage<br>ObjectMessage<br>Message （只有消息头和属性）</td><td>byte[]<br>当实际应用时，有复杂的消息，<br>可以将消息序列化后发送。<br><br><br><br></td></tr><tr><td>综合评价</td><td>JMS 定义了JAVA API层面的标准；<br>在java体系中，多个client均可以通过JMS进行交互，<br>不需要应用修改代码，但是其对跨平台的支持较差；</td><td>AMQP定义了wire-level层的协议标准；<br>天然具有跨平台、跨语言特性。</td></tr></tbody></table></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列MQ介绍及优缺点</title>
    <link href="/2022/03/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <url>/2022/03/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是消息队列"><a href="#一、什么是消息队列" class="headerlink" title="一、什么是消息队列"></a>一、什么是消息队列</h1><p><strong>MQ：MessageQueue 消息队列</strong>。队列是一种FIFO先进先出的数据结构。消息由生产者发送到MQ进行排队，然后由消费者对消息进行处理。</p><h1 id="二、消息队列有什么优点和缺点"><a href="#二、消息队列有什么优点和缺点" class="headerlink" title="二、消息队列有什么优点和缺点"></a>二、消息队列有什么优点和缺点</h1><ul><li><h2 id="MQ的优点："><a href="#MQ的优点：" class="headerlink" title="MQ的优点："></a>MQ的优点：</h2><ul><li>异步：<ul><li>能提高系统的响应速度、吞吐量。</li></ul></li><li><p>解耦：</p><ul><li>服务之间进行解耦，可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。</li><li>解耦后可以实现数据分发。生产者发送一个消息后，可以由一个或者多个消费者进行处理，并且消费者的增加或者减少对生产者没有影响。</li></ul></li><li><p>削峰：</p><ul><li>以稳定的系统资源应对突发的流量冲击。</li></ul></li></ul></li><li><h2 id="MQ的缺点："><a href="#MQ的缺点：" class="headerlink" title="MQ的缺点："></a>MQ的缺点：</h2><ul><li>系统可用性降低：<ul><li>系统引入外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。<strong>这就需要考虑如何保证MQ的高可用。</strong></li></ul></li><li>系统复杂度提高：<ul><li>以前服务之间可以进行同步的服务调用，引入MQ之后，会变成异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：<strong>如何保证消息不会丢失？如何保证消息不被重复调用？如何保证消息传递的顺序性？</strong></li></ul></li><li>消息一致性问题：<ul><li>A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，但C系统处理失败了怎么办？<strong>这就需要考虑如何保证消息数据处理的一致性。</strong></li></ul></li></ul></li></ul><h1 id="三、业界主流消息队列和技术选型"><a href="#三、业界主流消息队列和技术选型" class="headerlink" title="三、业界主流消息队列和技术选型"></a>三、业界主流消息队列和技术选型</h1><ul><li><p>业界主流的消息队列：ActiveMQ、Kafka、RabbitMQ、RocketMQ</p><ul><li><p>ActiveMQ：<a href="http://activemq.apache.org/">http://activemq.apache.org/</a></p><ul><li>Apache出品，历史悠久，支持多种语言的客户端和协议，支持多种语言Java, .NET, C++ 等</li><li><p>基于JMS Provider的实现</p></li><li><p>缺点：吞吐量不高，多队列的时候性能下降，存在消息丢失的情况，比较少大规模使用</p></li></ul></li><li><p>Kafka：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p><ul><li>是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理大规模的网站中的所有动作流数据(网页浏览，搜索和其他用户的行动)，副本集机制，实现数据冗余，保障数据尽量不丢失；支持多个生产者和消费者</li><li><p>类似MQ，功能较为简单，主要支持简单的MQ功能</p></li><li><p>缺点：不支持批量和广播消息，运维难度大，文档比较少, 需要掌握Scala</p></li></ul></li><li><p>RocketMQ：<a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></p><ul><li>阿里开源的一款的消息中间件, 纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点, 性能强劲(零拷贝技术)，支持海量堆积, 支持指定次数和时间间隔的失败消息重发,支持consumer端tag过滤、延迟消息等，在阿里内部进行大规模使用，适合在电商，互联网金融等领域</li><li>基于JMS Provider的实现</li><li>缺点：社区相对不活跃，更新比较快，纯java支持</li></ul></li><li><p>RabbitMQ：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p><ul><li>是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、C、用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不错</li><li>缺点：使用Erlang开发，阅读和修改源码难度大</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis6.X新特性</title>
    <link href="/2022/03/23/Redis6.X%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/03/23/Redis6.X%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="支持多线程"><a href="#支持多线程" class="headerlink" title="支持多线程"></a>支持多线程</h4><ul><li><p>redis6多线程只是用来处理网络数据的读写和协议解析上，<strong>底层数据操作还是单线程</strong></p></li><li><p>执行命令仍然是单线程，之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题</p></li><li><p>默认不开启</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">io</span>-threads-<span class="hljs-keyword">do</span>-reads yes<br><span class="hljs-built_in">io</span>-threads 线程数<br></code></pre></td></tr></table></figure><ul><li>官方建议 ( 线程数小于机器核数 )<ul><li>4 核的机器建议设置为 2 或 3 个线程</li><li>8 核的建议设置为 4或6个线程</li></ul></li><li>开启多线程后，是否会存在线程并发安全问题？<ul><li>不会有安全问题，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行</li></ul></li></ul></li></ul><ul><li><h4 id="引入了-ACL（Access-Control-List"><a href="#引入了-ACL（Access-Control-List" class="headerlink" title="引入了 ACL（Access Control List)"></a>引入了 ACL（Access Control List)</h4><ul><li>之前的redis没有用户的概念，redis6引入了acl</li><li>可以给每个用户分配不同的权限来控制权限</li><li>通过限制对命令和密钥的访问来提高安全性，以使不受信任的客户端无法访问</li><li>提高操作安全性，以防止由于软件错误或人为错误而导致进程或人员访问 Redis，从而损坏数据或配置</li></ul></li><li><p>常用命令</p><ul><li>acl list 当前启用的 ACL 规则</li><li>acl cat 支持的权限分类列表</li><li>acl cat hash 返回指定类别中的命令</li><li>acl setuser 创建和修改用户命令</li><li>acl deluser 删除用户命令</li></ul></li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pf">+<span class="hljs-variable">&lt;command&gt;</span> 将命令添加到用户可以调用的命令列表中，如+@hash<br>-<span class="hljs-variable">&lt;command&gt;</span> 将命令从用户可以调用的命令列表中移除<br><br><span class="hljs-comment">#切换默认用户</span><br>auth <span class="hljs-keyword">default</span> <span class="hljs-number">123456</span><br><br><br><span class="hljs-comment">#例子 密码 123 ，全部key，全部权限</span><br>acl setuser jack <span class="hljs-keyword">on</span> &gt;<span class="hljs-number">123</span> ~* +@<span class="hljs-literal">all</span><br><br><span class="hljs-comment">#例子 密码 123 ，全部key，get权限</span><br>acl setuser jack <span class="hljs-keyword">on</span> &gt;<span class="hljs-number">123</span> ~* +get<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参 数</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>用户</td></tr><tr><td>default</td><td>表示默认用户名，或则自己定义的用户名</td></tr><tr><td>on</td><td>表示是否启用该用户，默认为off（禁用）</td></tr><tr><td>#…</td><td>表示用户密码，nopass表示不需要密码</td></tr><tr><td>~*</td><td>表示可以访问的Key（正则匹配）</td></tr><tr><td>+@</td><td>表示用户的权限，“+”表示授权权限，有权限操作或访问，“-”表示还是没有权限； @为权限分类，可以通过 <code>ACL CAT</code> 查询支持的分类。+@all 表示所有权限，nocommands 表示不给与任何命令的操作权限</td></tr></tbody></table></div><ul><li><h4 id="client-side-caching客户端缓存"><a href="#client-side-caching客户端缓存" class="headerlink" title="client side caching客户端缓存"></a>client side caching客户端缓存</h4><ul><li>类似浏览器缓存一样<ul><li>在服务器端更新了静态文件（如css、js、图片），能够在客户端得到及时的更新，但又不想让浏览器每次请求都从服务器端获取静态资源</li><li>类似前端的-Expires、Last-Modified、Etag缓存控制</li></ul></li></ul></li></ul><p><img src="/2022/03/23/Redis6.X%E6%96%B0%E7%89%B9%E6%80%A7/image-1.png" alt="image-1"></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">redis在服务端记录访问的连接和相关的<span class="hljs-built_in">key</span>， 当<span class="hljs-built_in">key</span>有变化时通知相应的应用<br>应用收到请求后自行处理有变化的<span class="hljs-built_in">key</span>, 进而实现client cache与redis的一致<br>这需要客户端实现，目前lettuce对其进行了支持<br></code></pre></td></tr></table></figure><p>client side caching的两种模式：</p><ul><li>默认模式<ul><li>Server 端全局唯一的表（<strong>Invalidation Table</strong>）记录每个Client访问的Key，当发生变更时，向client推送数据过期消息。<ul><li>优点：只对Client发送其访问过的被修改的数据</li><li>缺点：Server端需要额外存储较大的数据量</li></ul></li></ul></li></ul><ul><li>广播模式<ul><li>客户端订阅key前缀的广播，服务端记录key前缀与client的对应关系。当相匹配的key发生变化时通知client。</li><li>优点：服务端记录信息比较少</li><li>缺点：client会收到自己未访问过的key的失效通知</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群Cluster</title>
    <link href="/2022/03/22/Redis%E9%9B%86%E7%BE%A4Cluster/"/>
    <url>/2022/03/22/Redis%E9%9B%86%E7%BE%A4Cluster/</url>
    
    <content type="html"><![CDATA[<p>​    Sentinel解决了主从架构故障自动迁移的问题，但是Master主节点的写能力和存储能力依旧受限。</p><p>使用Redis的集群cluster就是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器</p><h3 id="一、什么是集群Cluster"><a href="#一、什么是集群Cluster" class="headerlink" title="一、什么是集群Cluster"></a>一、什么是集群Cluster</h3><ul><li>集群Cluster介绍：<ul><li>是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理</li><li>采用无中心结构，每个节点保存数据和整个集群状态, 每个节点都和其他所有节点连接</li><li>官方要求：至少6个节点才可以保证高可用，即3主3从；扩展性强、更好做到高可用</li><li>各个节点会互相通信，采用gossip协议交换节点元数据信息</li><li>数据分散存储到各个节点上</li></ul></li></ul><h3 id="二、Cluster如何实现数据分片"><a href="#二、Cluster如何实现数据分片" class="headerlink" title="二、Cluster如何实现数据分片"></a>二、Cluster如何实现数据分片</h3><ul><li>常见的数据分区算法：<ul><li>哈希取模<ul><li>对选择的 partitioning key 计算其哈希值，得到的哈希值就是对应的分区</li></ul></li><li>范围分片<ul><li>通过确定分区键是否在某个范围内来选择分区</li></ul></li><li>一致性Hash分区</li></ul></li></ul><p><strong>Redis Cluster集群没有采用一致性哈希方案，而是采用【数据分片】中的哈希槽来进行数据存储与读取的</strong></p><ul><li><p>Redis的哈希槽介绍：</p><ul><li>Redis的集群内部内置了16384个哈希槽，当你需要把一个Key-value形式的数据放入集群时，redis会先使用crc16算法算出一个结果，然后把结果对16384进行取余，取余的结果进行取余， 获得一个范围在0-16383范围的余数，通过余数放入对应编号的哈希槽里面。</li></ul></li><li><p>数据分片流程：</p><ul><li>假设主节点的数量为3，将16384个槽位按照【用户自己的规则】去分配这3个节点，每个节点复制一部分槽位<ul><li>节点1的槽位区间范围为0-5460</li><li>节点2的槽位区间范围为5461-10922</li><li>节点3的槽位区间范围为10923-16383</li><li><strong>注意：从节点是没有槽位的，只有主节点才有</strong></li></ul></li><li>存储查找<ul><li>对要存储查找的键进行crc16哈希运算,得到一个值，并取模16384，判断这个值在哪个节点的范围区间</li><li>假设crc16(“test_key”)%16384=3000，就是节点一</li><li><strong>注意：crc16算法不是简单的hash算法，是一种校验算法</strong></li></ul></li></ul></li></ul><p><img src="/2022/03/22/Redis%E9%9B%86%E7%BE%A4Cluster/image-1.png" alt="image-1"></p><ul><li>使用哈希槽的好处就在于可以方便的添加或移除节点。<ul><li>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了</li><li>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了</li></ul></li></ul><h3 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h3><ul><li><p><strong>什么情况下会导致集群不可用</strong>？</p><ul><li><p>如果集群中的master没有slave节点，则master挂掉后整个集群就会进入fail状态，因为集群的slot映射不完整。</p></li><li><p>如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态。</p></li></ul></li><li><p><strong>集群会有写操作丢失吗？</strong></p><ul><li>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操<br>作。<ul><li>过期 key 被清理。</li><li>最大内存不足，导致 Redis 自动清理部分 key 以节省空间。</li><li>主库故障后自动重启，从库自动同步。</li><li>单独的主备方案，网络不稳定触发哨兵的自动切换主从节点，切换期间会有数据丢失。</li></ul></li></ul></li><li><p><strong>集群的主从复制模型是怎样的？</strong></p><ul><li>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用， 所以集群使用了主<br>从复制模型,每个节点都会有N-1 个复制品。</li><li>采用异步复制</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis哨兵监控Sentinel</title>
    <link href="/2022/03/20/Redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Sentinel/"/>
    <url>/2022/03/20/Redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Sentinel/</url>
    
    <content type="html"><![CDATA[<p>在Redis的主从模式中，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，人工干预费时费力，还会造成一段时间内服务不可用。</p><h2 id="一、什么是Sentinel哨兵模式"><a href="#一、什么是Sentinel哨兵模式" class="headerlink" title="一、什么是Sentinel哨兵模式"></a>一、什么是Sentinel哨兵模式</h2><ul><li><p>Sentinel哨兵模式介绍：</p><ul><li>哨兵是Redis的一种运行模式，它专注于对Redis实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个Redis系统的可用性。</li><li>哨兵通过发送命令给多个节点，等待Redis服务器响应，从而监控运行的多个Redis实例的运行情况。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，并通知其他的从服务器，修改配置文件切换主机。</li></ul></li><li><p>Sentinel哨兵的能力：</p><ul><li><strong>监控（Monitoring）</strong>：持续监控Redis主节点、从节点是否处于预期的工作状态。</li><li><strong>通知（Notification）</strong>：哨兵可以把Redis实例的运行故障信息通过API通知监控系统或者其他应用程序。</li><li><strong>自动故障恢复（Automatic failover）</strong>：当主节点运行故障时，哨兵会启动自动故障恢复流程：某个从节点会升级为主节点，其他从节点会使用新的主节点进行主从复制，通知客户端使用新的主节点进行。</li><li><strong>配置中心（Configuration provider）</strong>：哨兵可以作为客户端服务发现的授权源，客户端连接到哨兵请求给定服务的Redis主节点地址。如果发生故障转移，哨兵会通知新的地址。这里要注意：哨兵并不是Redis代理，只是为客户端提供了Redis主从节点的地址信息。</li></ul></li></ul><p>一般是使用多个哨兵进行监控，各个哨兵之间还会进行监控，形成多哨兵模式</p><p><img src="/2022/03/20/Redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Sentinel/image-1.png" alt="image-1"></p><h2 id="二、多哨兵模式介绍："><a href="#二、多哨兵模式介绍：" class="headerlink" title="二、多哨兵模式介绍："></a>二、多哨兵模式介绍：</h2><ul><li>主观下线（Subjectively Down， 简称 SDOWN）<ul><li>是单个 Sentinel 实例对服务器做出的下线判断，比如网络问题接收不到通知等</li><li>如果一个服务器<strong>没有</strong>在 down-after-milliseconds 选项所指定的时间内，对向它发送 PING 命令的 Sentinel 返回一个有效回复（valid reply）， 那么 Sentinel 就会将这个服务器标记为主观下线。</li></ul></li></ul><p><img src="/2022/03/20/Redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Sentinel/image-2.png" alt="image-2"></p><ul><li>客观下线（Objectively Down， 简称 ODOWN）<ul><li>指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断</li><li>一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线</li><li>客观下线条件只适用于<strong>主服务器</strong></li></ul></li></ul><p><img src="/2022/03/20/Redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Sentinel/image-3.png" alt="image-3"></p><ul><li>仲裁 quorum<ul><li>Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了【足够数量】的主服务器下线报告， 那么 Sentinel 就会将<strong>主服务器</strong>的状态从主观下线改变为客观下线</li><li>这个【足够数量】就是配置文件里面的值，一般是Sentinel个数的一半加1，比如3个Sentinel则就设置为2</li><li>down-after-milliseconds 是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用</li><li>当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行故障转移failover</li></ul></li></ul><ul><li>故障转移 failover<ul><li>在已下线的Master主机下面挑选一个Slave将其转换为主服务器。</li><li>让其余所有Slave服务器复制新的Master服务器。</li><li>让已下线的Master服务器变成新的Master服务器的Slave。当已下线的服务器在此上线后将复新的Master的数据。</li></ul></li></ul><p><img src="/2022/03/20/Redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Sentinel/image-4.png" alt="image-4"></p><ul><li><strong>那么sentinel是如何选择到底让哪一个从节点成为新的主节点呢？</strong></li></ul><p><img src="/2022/03/20/Redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Sentinel/image-5.png" alt="image-5"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从复制</title>
    <link href="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Redis主从复制"><a href="#一、什么是Redis主从复制" class="headerlink" title="一、什么是Redis主从复制"></a>一、什么是Redis主从复制</h2><ul><li>Redis主从复制介绍：<ul><li>主从复制是指将一台Redis服务器（主节点master）的数据，复制到其他的Redis服务器（从节点slave），数据的复制只能从master到slave，一个master可以有多个slave，但一个slave只能有一个master。</li><li>主从模式下，Redis采用读写分离：<ul><li>读操作：master和slave均可执行读操作，主要以slave为主。</li><li>写操作：master执行写操作，然后把数据同步到各个slave，保证主从数据一致性。</li></ul></li></ul></li></ul><h2 id="二、Redis主从复制实现原理"><a href="#二、Redis主从复制实现原理" class="headerlink" title="二、Redis主从复制实现原理"></a>二、Redis主从复制实现原理</h2><ul><li>主从复制分两种（主从刚连接的时候，进行全量同步；全量同步结束后，进行增量同步）<ul><li>全量复制：<ul><li>master服务器会开启一个后台进程用于将redis中的数据生成一个rdb文件</li><li>服务器会缓存所有接收到的来自客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该rdb 文件传递给slave 服务器</li><li>slave 服务器会将rdb 文件保存在磁盘并通过读取该文件将数据加载到内存</li><li>在此之后master 服务器会将在此期间缓存的命令通过redis 传输协议发送给slave 服务器</li><li>然后slave 服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性</li></ul></li><li>增量复制：<ul><li>从redis 2.8 版本以前，并不支持部分同步，当主从服务器之间的连接断掉之后，master 服务器和slave 服务器之间都是进行全量数据同步。</li><li>从redis 2.8 开始，即使主从连接中途断掉，也不需要进行全量同步，因为从这个版本开始融入了部分同步的概念。部分同步的实现依赖于在master 服务器内存中给每个slave 服务器维护了一份同步日志和同步标识，每个slave 服务器在跟master 服务器进行同步时都会携带自己的同步标识和上次同步的最后位置。当主从连接断掉之后，slave 服务器隔断时间（默认1s）主动尝试和master 服务器进行连接，如果从服务器携带的偏移量标识还在master 服务器上的同步备份日志中，那么就从slave 发送的偏移量开始继续上次的同步操作，如果slave 发送的偏移量已经不再master 的同步备份日志中（可能由于主从之间断掉的时间比较长或者在断掉的短暂时间内master 服务器接收到大量的写操作），则必须进行一次全量更新。在部分同步过程中，master 会将本地记录的同步备份日志中记录的指令依次发送给slave 服务器从而达到数据一致。</li></ul></li></ul></li></ul><p>从Redis 2.8版本开始，Redis使用<code>PSYNC</code>命令代替<code>SYNC</code>命令来执行复制时的同步操作。</p><p><code>PSYNC</code>命令有以下2种场景：</p><ol><li><p>完整重同步</p><p>完整重同步用于处理<strong>初次复制</strong>，执行步骤和<code>SYNC</code>命令的执行步骤基本一样。</p></li><li><p>部分重同步</p><p>部分重同步用于处理<strong>断线后重复制</strong>，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</p></li></ol><p>仍然用上面举的例子，新版复制，主服务器只需要把断开期间执行的10个写命令发送给从服务器即可，而不用生成并发送整个RDB文件，性能大大提升。</p><p>主从服务器在执行部分重同步时的通信过程如下图所示：</p><p><img src="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-1.png" alt="image-1"></p><p>那么部分重同步是如何实现的呢？</p><p>部分重同步功能由以下3个部分组成：</p><ol><li>主服务器和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区</li><li>服务器的运行ID</li></ol><h3 id="1、复制偏移量"><a href="#1、复制偏移量" class="headerlink" title="1、复制偏移量"></a>1、复制偏移量</h3><p>执行复制的主服务器和从服务器会分别维护一个复制偏移量：</p><ol><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li></ol><p>举个例子，假设主服务器有3个从服务器，它们的复制偏移量都为10086，如下图所示：</p><p><img src="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-2.png" alt="image-2"></p><p>然后，主服务器向3个从服务器传播了长度为33字节的数据，那么主服务器的复制偏移量会加上33，变为10119，</p><p>从服务器A在这时刚好断线了，没有接收到数据，所以偏移量仍然为10086，</p><p>从服务器B和从服务器C正常接收到了数据，所以偏移量都更新为了10019，如下图所示：</p><p><img src="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-3.png" alt="image-3"></p><p>很显然，通过对比主从服务器的复制偏移量，可以很容易地知道主从服务器是否处于一致状态。</p><p>然后，从服务器A通过重试又重新连接到了主服务器，然后向主服务器发送PSYNC命令，并报告了自己当前的复制</p><p>偏移量为10086，主服务器此时需要处理2个问题：</p><ol><li>该对从服务器A执行完整重同步还是部分重同步？</li><li>如果执行部分重同步，主服务器从哪里获取到断线期间从服务器A丢失的数据？</li></ol><p>带着这2个问题，我们看下复制积压缓冲区。</p><h3 id="2、复制积压缓冲区"><a href="#2、复制积压缓冲区" class="headerlink" title="2、复制积压缓冲区"></a>2、复制积压缓冲区</h3><p>复制积压缓冲区是主服务器维护的一个<strong>固定长度先进先出队列</strong>，默认大小为1MB。</p><p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区，如下图所示：</p><p><img src="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-4.png" alt="image-4"></p><p>所以，主服务器的复制积压缓冲区会保存着一部分最近传播的写命令，并且为队列中的每个字节记录相应的复制偏移量，如下所示：</p><div class="table-container"><table><thead><tr><th>偏移量</th><th>…</th><th>10087</th><th>10088</th><th>10089</th><th>10090</th><th>10091</th><th>…</th></tr></thead><tbody><tr><td>字节值</td><td>…</td><td>‘*’</td><td>3</td><td>‘\r’</td><td>‘\n’</td><td>‘$’</td><td>…</td></tr></tbody></table></div><p>当从服务器重新连接上主服务器时，会通过<code>PSYNC</code>命令将自己的复制偏移量offset发送给主服务器，主服务器会根据以下规则来决定对从服务器执行何种同步操作：</p><ul><li>如果offset偏移量之后的数据仍然存在于复制积压缓冲区，那么主服务器将对从服务器执行部分重同步操作。</li><li>如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li></ul><p>回到之前的例子：</p><ol><li>从服务器A重新连接上主服务器，向主服务器发送<code>PSYNC</code>命令，报告自己的复制偏移量为10086。</li><li>主服务器收到<code>PSYNC</code>命令以及偏移量10086之后，会检查偏移量10086之后的数据是否存在于复制积压缓冲区，结果发现数据还在，于是主服务器向从服务器A发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行。</li><li>接着主服务器会将复制积压缓冲区里10086偏移量之后的所有数据（偏移量为10087到10119）都发送给从服务器A。</li><li>从服务器A接收这33字节的缺失数据，就回到与主服务器一致的状态。</li></ol><p><img src="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-5.png" alt="image-5"></p><h3 id="3、服务器运行ID"><a href="#3、服务器运行ID" class="headerlink" title="3、服务器运行ID"></a>3、服务器运行ID</h3><p>每个Redis服务器，不论主服务器还是从服务器，都会有自己的运行ID，运行ID在服务器启动时自动生成，由40个十六进制字符组成，如下图所示：</p><p><img src="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-6.png" alt="image-6"></p><p>当从服务器对主服务器进行<strong>初次复制</strong>时，主服务器会将自己的运行ID传送给从服务器，从服务器会将这个运行ID保存起来。</p><p>当从服务器断线并重新连接上主服务器时，从服务器会把之前保存的运行ID发送给当前连接的主服务器：</p><ul><li>如果从服务器之前保存的运行ID和当前连接的主服务器的运行ID相同，说明从服务器断线前后复制的是同一台主服务器，主服务器可以继续尝试执行部分重同步操作。</li><li>如果从服务器之前保存的运行ID和当前连接的主服务器的运行ID不相同，说明从服务器断线前后复制的不是同一台主服务器，主服务器将对从服务器执行完整重同步操作。</li></ul><h3 id="4、PSYNC命令执行细节"><a href="#4、PSYNC命令执行细节" class="headerlink" title="4、PSYNC命令执行细节"></a>4、PSYNC命令执行细节</h3><p>对于从服务器来说，调用<code>PSYNC</code>命令有以下2种情况：</p><ol><li><p>如果从服务器以前没有复制过任何主服务器，或者之前执行过<code>SLAVEOF on one</code>命令，那么从服务器在开始一次新的复制时将向主服务器发送<code>PSYNC ? -1</code>命令，主动请求主服务器进行完整重同步。</p></li><li><p>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送</p><p><code>PSYNC &#123;runid&#125; &#123;offset&#125;</code>命令，其中runid是上一次复制的主服务器的运行ID，offset是从服务器当前的复制偏移量。</p></li></ol><p>对于主服务器来说，接收到<code>PSYNC</code>命令后会向从服务器返回以下3种回复中的一种：</p><ol><li>如果主服务器返回<code>+FULLRESYNC &#123;runid&#125; &#123;offset&#125;</code>，表示主服务器将与从服务器执行完整重同步操作，其中runid是主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送<code>PSYNC</code>命令时使用，offset是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。</li><li>如果主服务器返回<code>+CONTINUE</code>，表示主服务器将与从服务器执行部分重同步操作，主服务器会将从服务器缺少的那部分数据发送给从服务器。</li><li><code>如果主服务器返回-ERROR，表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC</code>命令，并与主服务器执行完整重同步操作。</li></ol><p>以上描述流程可以使用以下流程图来表示：</p><p><img src="/2022/03/17/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-7.png" alt="image-7"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis的内存淘汰策略</title>
    <link href="/2022/03/15/Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2022/03/15/Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<ul><li><h3 id="Redis的内存淘汰策略介绍："><a href="#Redis的内存淘汰策略介绍：" class="headerlink" title="Redis的内存淘汰策略介绍："></a>Redis的内存淘汰策略介绍：</h3><p>​    redis在占用的内存超过指定的maxmemory之后，通过maxmemory_policy确定redis是否释放内存以及如何释放内存，提供了多种策略。</p></li><li><h3 id="淘汰策略："><a href="#淘汰策略：" class="headerlink" title="淘汰策略："></a>淘汰策略：</h3><ul><li>volatile-lru(least recently used)<ul><li>最近最少使用算法，从设置了过期时间的键中选择空转时间最长的键值对清除掉；</li></ul></li><li>volatile-lfu(least frequently used)<ul><li>最近使用频率最低算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</li></ul></li><li>volatile-ttl<ul><li>从设置了过期时间的键中选择过期时间最早的键值对清除 (删除即将过期的）</li></ul></li><li>volatile-random<ul><li>从设置了过期时间的键中，随机选择键进行清除；</li></ul></li><li>allkeys-lru<ul><li>最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；</li></ul></li><li>allkeys-lfu<ul><li>最近使用频率最低算法，从所有的键中选择某段时间之内使用频次最少的键值对清除；</li></ul></li><li>allkeys-random<ul><li>所有的键中，随机选择键进行删除；</li></ul></li><li>noeviction<ul><li>不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;</li></ul></li></ul></li><li><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>config配置的时候key的下划线 _ 需要用中横线 - </li></ul></li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; config set maxmemory_policy volatile-lru<br>(error) ERR Unsupported CONFIG parameter: maxmemory_policy<br><br><span class="hljs-number">127.0.0.1:6379</span>&gt; config set maxmemory-policy volatile-lru<br>OK<br></code></pre></td></tr></table></figure><p>​    最好为Redis指定一种有效的内存淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis过期键的删除策略</title>
    <link href="/2022/03/14/Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/"/>
    <url>/2022/03/14/Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis过期键的删除策略是什么？"><a href="#一、Redis过期键的删除策略是什么？" class="headerlink" title="一、Redis过期键的删除策略是什么？"></a>一、Redis过期键的删除策略是什么？</h1><ul><li><h2 id="Redis过期删除策略介绍："><a href="#Redis过期删除策略介绍：" class="headerlink" title="Redis过期删除策略介绍："></a>Redis过期删除策略介绍：</h2><p>​    Redis是key-value数据库，可以设置Redis中缓存的key的过期时间。Redis过期键的删除策略就是指当Redis中缓存的key过期了，Redis如何处理。</p></li><li><h2 id="Redis过期删除策略方式："><a href="#Redis过期删除策略方式：" class="headerlink" title="Redis过期删除策略方式："></a>Redis过期删除策略方式：</h2><ul><li>定期删除</li><li>惰性删除</li></ul></li></ul><h1 id="二、定期删除"><a href="#二、定期删除" class="headerlink" title="二、定期删除"></a>二、定期删除</h1><ul><li>每隔一段时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。具体检查多少个数据库以及删除多少过期的key，则由算法决定。</li><li>定期删除可能会导致很多过期的key并没有被删除掉。</li></ul><h1 id="三、惰性删除"><a href="#三、惰性删除" class="headerlink" title="三、惰性删除"></a>三、惰性删除</h1><ul><li>当访问一个key的时候，先检查该key是否过期，过期则删除。</li><li>节省CPU时间，但对内存不友好，极端情况可能出现大量的过期key没有被再次访问，从而不会被删除，占用大量内存。</li></ul><h1 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h1><p>​    Redis服务器实际是同时使用定期删除和惰性删除两种策略，通过结合使用这两种删除策略，服务器可以很好地在<code>合理使用CPU时间</code>和<code>避免浪费内存空间</code>之间取得平衡。</p><ul><li>如果定期删除遗漏掉了很多过期key，并且你没有及时查到，也就没有进行惰性删除，此时会怎样？</li><li>如果大量过期key堆积在内存里，导致Redis内存耗尽了，就需要进行<strong>内存淘汰机制</strong>。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制之RDB和AOF</title>
    <link href="/2022/03/10/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E4%B9%8BRDB%E5%92%8CAOF/"/>
    <url>/2022/03/10/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E4%B9%8BRDB%E5%92%8CAOF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis的持久化机制是什么？"><a href="#一、Redis的持久化机制是什么？" class="headerlink" title="一、Redis的持久化机制是什么？"></a>一、Redis的持久化机制是什么？</h1><ul><li><h3 id="Redis持久化机制介绍："><a href="#Redis持久化机制介绍：" class="headerlink" title="Redis持久化机制介绍："></a>Redis持久化机制介绍：</h3><p>​    Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来<strong>保证Redis的数据不会因为故障而丢失</strong>。</p></li><li><h3 id="Redis的持久化方式："><a href="#Redis的持久化方式：" class="headerlink" title="Redis的持久化方式："></a>Redis的持久化方式：</h3><ul><li>RDB(Redis DataBase)持久化</li><li>AOF(Append Only File)持久化</li></ul></li></ul><h1 id="二、RDB持久化"><a href="#二、RDB持久化" class="headerlink" title="二、RDB持久化"></a>二、RDB持久化</h1><ul><li><h3 id="RDB持久化介绍："><a href="#RDB持久化介绍：" class="headerlink" title="RDB持久化介绍："></a>RDB持久化介绍：</h3><ul><li>将某个时间点上的数据库状态保存到一个RDB文件中，默认的文件名为dump.rdb</li><li>生成的RDB文件是一个经过压缩的二进制文件，通过该文件还可以还原生成RDB文件时的数据库状态</li></ul></li><li><h3 id="手动触发："><a href="#手动触发：" class="headerlink" title="手动触发："></a>手动触发：</h3><ul><li>sava命令：使Redis处于阻塞状态，直到RDB持久化完成，执行save命令期间，Redis不能处理其他命令。（慎用）</li><li>bgsave命令：fork出一个子进程执行持久化，主进程只在fork过程中会有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了。</li></ul></li><li><h3 id="自动触发："><a href="#自动触发：" class="headerlink" title="自动触发："></a>自动触发：</h3><ul><li>save m n：在m秒内如果有n个建发生改变，则自动触发bgsave，如果设置多个，只要满足一个就会触发。（可用通过配置文件实现，有默认配置）</li><li>flushall：用于清空Redis所有的数据库，flushdb清空当前Redis所在的数据库（默认是DB 0），会清空RDB文件，同时也会生产dump.rdb（内容为空）</li><li>主从同步：从服务器同步数据时，会发送sync执行同步操作，master主服务器会执行bgsave</li></ul></li><li><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>RDB文件紧凑，全量备份，适合数据备份和灾难恢复。</li><li>RDB在保存RDB文件时，父进程只需fork出一个子进程，接下来工作全由子进程来做，父进程不需进行任何IO操作，因此可以最大化Redis的性能。</li><li>在恢复大的数据集的时候，RDB比AOF更快。</li></ul></li><li><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>数据安全性低，RDB是以时间间隔进行持久化，若再持久化之间Redis意外宕机，会丢失部分数据。</li><li>由于RDB是通过fork子进程来协助完成持久化工作的，因此，当Redis数据量较大时，fork子进程非常耗时，并且会阻塞Redis主进程。</li></ul></li><li><h3 id="持久化加载规则："><a href="#持久化加载规则：" class="headerlink" title="持久化加载规则："></a>持久化加载规则：</h3><p>​    如果只开启了 <code>RDB</code> 持久化，<code>Redis</code> 启动时只会加载 <code>RDB</code> 文件（<code>dump.rdb</code>），进行数据恢复。</p></li><li><h3 id="核心配置redis-conf"><a href="#核心配置redis-conf" class="headerlink" title="核心配置redis.conf"></a>核心配置redis.conf</h3><figure class="highlight vala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#任何ip可以访问</span><br>bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-meta">#守护进程</span><br>daemonize yes<br><br><span class="hljs-meta">#密码</span><br>requirepass <span class="hljs-number">123456</span><br><br><span class="hljs-meta">#日志文件</span><br>logfile <span class="hljs-string">&quot;/usr/local/redis/log/redis.log&quot;</span><br><br><span class="hljs-meta">#持久化文件名称</span><br>dbfilename persistence.rdb<br><br><span class="hljs-meta">#持久化文件存储路径</span><br>dir /usr/local/redis/data<br><br><span class="hljs-meta">#持久化策略, 10秒内有个1个key改动，执⾏快照</span><br>save <span class="hljs-number">10</span> <span class="hljs-number">1</span><br><br><span class="hljs-meta">#导出rdb数据库文件压缩字符串和对象,默认是yes，会浪费CPU但是节省空间</span><br>rdbcompression yes<br><br><span class="hljs-meta">#导入时是否检查</span><br>rdbchecksum yes<br></code></pre></td></tr></table></figure></li></ul><h1 id="三、AOF持久化"><a href="#三、AOF持久化" class="headerlink" title="三、AOF持久化"></a>三、AOF持久化</h1><ul><li><h3 id="AOF持久化介绍："><a href="#AOF持久化介绍：" class="headerlink" title="AOF持久化介绍："></a>AOF持久化介绍：</h3><ul><li>以独立日志的方式记录每次写命令，并在 Redis 重启时在重新执行 AOF 文件中的命令以达到恢复数据的目的。</li><li>AOF 的主要作用是解决数据持久化的实时性。</li></ul></li><li><h3 id="AOF持久化流程："><a href="#AOF持久化流程：" class="headerlink" title="AOF持久化流程："></a>AOF持久化流程：</h3><ol><li>写入缓存：每次执行命令后会append追加到aof_buf(缓冲区)</li><li>同步磁盘：AOF缓冲区根据对应的策略向硬盘做同步操作</li><li>AOF重写：随着AOF文件越来越大，需要定期对AOF文件进行重写，用于压缩</li><li>重启加载：当Redis重启时，可以加载AOF文件进行数据恢复</li></ol></li><li><h3 id="同步策略："><a href="#同步策略：" class="headerlink" title="同步策略："></a>同步策略：</h3><ol><li><p>appendfsync always</p><p>Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件，<strong>并且同步 AOF 文件</strong>。（性能最差、最安全）</p></li><li><p>appendfsync everysec</p><p>Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件中，<strong>并且每隔一秒就要在子线程中对 AOF 文件进行一次同步</strong>。（该策略为AOF的缺省策略）</p></li><li><p>appendfsync no</p><p>Redis 在每一个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件。<strong>而 AOF 文件的同步由操作系统控制</strong>（性能最好、最不安全）</p></li></ol></li></ul><ul><li><h3 id="rewrite重写："><a href="#rewrite重写：" class="headerlink" title="rewrite重写："></a>rewrite重写：</h3><ul><li>手动触发：<ul><li>手动调用 bgrewriteaof 命令，如果当前有正在运行的 rewrite 子进程，则本次rewrite 会推迟执行，否则，直接触发一次 rewrite</li></ul></li><li>自动触发：<ul><li>auto-aof-rewrite-min-size 表示运行AOF重写时文件最小体积，默认为64MB</li><li>auto-aof-rewrite-percentage 代表当前AOF文件空间和上一次重写后AOF文件空间（aof_base_size）的比值</li></ul></li></ul></li><li><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul><li>使用AOF会让Redis更加持久化</li><li>通过append模式写文件，即使写入过程宕机，也不影响之前的数据，可以通过redis-check-aof检查修复问题</li><li>AOF机制的rewrite模式，定期对AOF文件进行重写，以达到压缩的目的</li><li>AOF文件可读性高，容易分析</li></ul></li><li><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>对于相同的数据来说，AOF文件比RDB文件大</li><li>根据所使用的fsync策略，AOF的速度可能比RDB满</li></ul></li><li><h3 id="持久化加载规则：-1"><a href="#持久化加载规则：-1" class="headerlink" title="持久化加载规则："></a>持久化加载规则：</h3><p>​    如果只开启了 <code>AOF</code> 持久化，<code>Redis</code> 启动时只会加载 <code>AOF</code> 文件（<code>appendonly.aof</code>），进行数据恢复。</p></li><li><h3 id="核心配置redis-conf-1"><a href="#核心配置redis-conf-1" class="headerlink" title="核心配置redis.conf"></a>核心配置redis.conf</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#任何ip可以访问</span><br>bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-meta">#守护进程</span><br>daemonize yes<br><br><span class="hljs-meta">#密码</span><br>requirepass <span class="hljs-number">123456</span><br><br><span class="hljs-meta">#日志文件</span><br>logfile <span class="hljs-string">&quot;/usr/local/redis/log/redis.log&quot;</span><br><br><span class="hljs-meta">#持久化文件存储路径</span><br>dir /usr/local/redis/data<br><br><span class="hljs-meta">#AOF持久化策略开启，默认不开启</span><br>appendonly yes<br><br><span class="hljs-meta">#AOF文件名 通过 appendfilename 配置设置，默认文件名是appendonly.aof</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br><br><span class="hljs-meta">#fsync策略 always、everysec、no</span><br>appendfsync everysec<br><br><span class="hljs-meta">#AOF重写期间是否同步</span><br>no-appendfsync-on-rewrite no<br><br><span class="hljs-meta">#自动重写触发配置</span><br><span class="hljs-meta">#默认这个值设置为100，意味着当前aof是基准大小的两倍的时候触发bgrewriteaof</span><br>auto-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-meta">#当前aof文件大于多少字节后才触发。避免在aof较小的时候无谓行为。默认大小为64mb</span><br>auto-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br><br><span class="hljs-meta">#加载AOF时如果有错如何处理</span><br><span class="hljs-meta">#yes表示如果AOF尾部文件出问题，写log记录并继续执行。no表示提示写入等待修复后写入</span><br>aof-load-truncated yes<br></code></pre></td></tr></table></figure></li></ul><h1 id="四、混合持久化"><a href="#四、混合持久化" class="headerlink" title="四、混合持久化"></a>四、混合持久化</h1><ul><li><h3 id="混合持久化介绍："><a href="#混合持久化介绍：" class="headerlink" title="混合持久化介绍："></a>混合持久化介绍：</h3><p>​    混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。混合持久化只发生于 AOF 重写过程。使用了混合持久化，重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。</p></li><li><h3 id="混合持久化本质："><a href="#混合持久化本质：" class="headerlink" title="混合持久化本质："></a>混合持久化本质：</h3><p>​    混合持久化本质是通过 AOF 后台重写（bgrewriteaof 命令）完成的，不同的是当开启混合持久化时，fork 出的子进程先将当前全量数据以 RDB 格式写入新的AOF 文件，然后再将 AOF 重写缓冲区（aof_rewrite_buf_blocks）的增量命令以 AOF格式追加写入到文件末尾，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p></li><li><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul><li>结合了RDB持久化和AOF持久化的优点，由于大部分是RDB格式，因此加载速度快；同时结合AOF，增量的数据以AOF方式保存，因此数据丢失更少。</li></ul></li><li><h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>阅读性较差，因为前部分是RDB格式。</li></ul></li><li><h3 id="持久化加载规则：-2"><a href="#持久化加载规则：-2" class="headerlink" title="持久化加载规则："></a>持久化加载规则：</h3><p>​    如果<strong>同时开启</strong>了 RDB 和 AOF 持久化，Redis 启动时<strong>只会加载 AOF 文件</strong>（appendonly.aof），进行数据恢复。</p></li><li><h3 id="混合持久化数据恢复流程："><a href="#混合持久化数据恢复流程：" class="headerlink" title="混合持久化数据恢复流程："></a>混合持久化数据恢复流程：</h3><ol><li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程。</li><li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程。</li><li>AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容。</li><li>AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li></ol></li></ul><h1 id="五、线上如何选择？"><a href="#五、线上如何选择？" class="headerlink" title="五、线上如何选择？"></a>五、线上如何选择？</h1><ul><li>使用混合持久化</li><li>采用集群和主从同步</li><li>如果Redis中的数据并不是特别敏感，可以通用其他方式重写生成数据</li><li>集群中可以关闭AOF持久化，靠集群的备份方式保证可用性</li><li>自己制定策略定期检查Redis的情况，然后手动触发备份、重写数据</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存穿透、缓存击穿、缓存雪崩及其解决方案</title>
    <link href="/2022/03/09/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/03/09/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-缓存穿透（查询不存在数据）"><a href="#1-缓存穿透（查询不存在数据）" class="headerlink" title="1.缓存穿透（查询不存在数据）"></a>1.缓存穿透（查询不存在数据）</h1><ul><li><p>问题描述：</p><p>​    大量并发查询不存在的 KEY ，在缓存和数据库中都不存在，同时给缓存和数据库带来压力。<code>如：用一个不存在的用户id获取用户信息，这也是黑客利用不存在的key频繁攻击应用的一种方式</code></p></li><li><p>解决方案：</p><ul><li>接口层增加校验，对数据的合理性进行校验。<code>如：用户鉴权校验，id 做基础校验，id&lt;=0直接拦截</code></li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，设置一个短的过期时间，防止同个key被一直攻击</li><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li></ul></li><li><p>SpringCache解决：</p><p>​    空结果也缓存，防止缓存穿透</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># 指定缓存类型</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-comment"># 是否缓存空结果，防止缓存穿透，默认为true</span><br>      <span class="hljs-attr">cache-null-values:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="2-缓存击穿（某个热点key缓存失效）"><a href="#2-缓存击穿（某个热点key缓存失效）" class="headerlink" title="2.缓存击穿（某个热点key缓存失效）"></a>2.缓存击穿（某个热点key缓存失效）</h1><ul><li><p>问题描述：</p><p>​    缓存中没有但数据库中有的数据（一般是缓存时间到期），当这个热点key在过期的一瞬间，正好有大量的并发请求访问这个key，这些请求都会击穿到数据库，造成瞬时数据库请求量大、压力增大</p></li><li><p>解决方案：</p><ul><li>设置热点数据不过期</li><li>采用定时任务定时更新缓存</li><li>设置互斥锁</li></ul></li><li><p>SpringCache解决：</p><p>​    缓存的同步 sync，sync 可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存中</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Cacheable</span>(<span class="hljs-keyword">sync</span>=<span class="hljs-keyword">true</span>)<br></code></pre></td></tr></table></figure><p>@Cacheable注解中的sync属性，当设置它为true时，只有一个线程的请求会去到数据库，其他线程都会等待直到缓存可用。这个设置可以减少对数据库的瞬间并发访问</p></li></ul><h1 id="3-缓存雪崩（多个热点key缓存都失效）"><a href="#3-缓存雪崩（多个热点key缓存都失效）" class="headerlink" title="3.缓存雪崩（多个热点key缓存都失效）"></a>3.缓存雪崩（多个热点key缓存都失效）</h1><ul><li><p>问题描述：</p><p>​    大量的key设置了相同的过期时间，导致缓存在同一时刻大面积的失效，造成大量的请求无法获取缓存，从而将流量压力传导到数据库上，引起雪崩</p></li><li><p>解决方案：</p><ul><li>在原有失效时间基础上增加一个随机值，防止同一时间大量数据过期现象发生</li><li>使用的热数据尽量分散在不同的机器上</li><li>设置热点数据永远不过期，定时任务定时更新</li></ul></li><li><p>SpringCache解决：</p><ul><li>CacheManager配置多个不同过期时间维度</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现分布式锁+Lua脚本</title>
    <link href="/2022/02/27/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81+Lua%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/02/27/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81+Lua%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Redis实现分布式锁-Lua脚本"><a href="#基于Redis实现分布式锁-Lua脚本" class="headerlink" title="基于Redis实现分布式锁+Lua脚本"></a>基于Redis实现分布式锁+Lua脚本</h1><ul><li><h2 id="加锁-SETNX-key-value"><a href="#加锁-SETNX-key-value" class="headerlink" title="加锁 SETNX key value"></a>加锁 SETNX key value</h2><p>SETNX key value 将<code>key</code>设置值为<code>value</code> </p><p><code>SETNX</code>是”<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists”的简写</p><p>若<code>key</code>不存在，则设置当前<code>key</code>成功，返回 <code>1</code></p><p>若当前<code>key</code>已经存在，则设置失败，返回 <code>0</code></p></li><li><h2 id="解锁-DEL-key"><a href="#解锁-DEL-key" class="headerlink" title="解锁 DEL key"></a>解锁 DEL key</h2><p>得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入,调用 DEL (key)</p></li><li><h2 id="配置锁过期时间-EXPIRE-key-seconds"><a href="#配置锁过期时间-EXPIRE-key-seconds" class="headerlink" title="配置锁过期时间 EXPIRE key seconds"></a>配置锁过期时间 EXPIRE key seconds</h2><p>客户端奔溃或者网络中断，资源将会永远被锁住,即死锁，因此需要给key配置过期时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放</p></li><li><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs processing">lockA()&#123;<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span> = <span class="hljs-string">&quot;lock_01&quot;</span><br><span class="hljs-keyword">if</span>（setnx（<span class="hljs-built_in">key</span>，value） == <span class="hljs-number">1</span>）&#123;<br><span class="hljs-comment">//设置锁的过期时间为60秒</span><br>    expire(<span class="hljs-built_in">key</span>,<span class="hljs-number">60</span>,TimeUnit.MILLISECONDS)<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//做对应的业务逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>del(<span class="hljs-built_in">key</span>)<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//睡眠100毫秒，然后自旋调用本方法</span><br>  lockA()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="思考：上述过程存在什么问题？🤔"><a href="#思考：上述过程存在什么问题？🤔" class="headerlink" title="思考：上述过程存在什么问题？🤔"></a>思考：上述过程存在什么问题？🤔</h2><h3 id="问题1-多命令之间不是原子性操作"><a href="#问题1-多命令之间不是原子性操作" class="headerlink" title="问题1.多命令之间不是原子性操作"></a>问题1.多命令之间不是原子性操作</h3><p>如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，则这个资源就是死锁。</p><p><strong>解决方案：使用原子性操作。</strong></p><p>从2.6.12版本开始，redis为<code>SET</code>命令增加了一系列选项:</p><p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p><ul><li><code>EX</code> <em>seconds</em> – 设置键key的过期时间，单位时秒</li><li><code>PX</code> <em>milliseconds</em> – 设置键key的过期时间，单位时毫秒</li><li><code>NX</code> – 只有键key不存在的时候才会设置key的值</li><li><code>XX</code> – 只有键key存在的时候才会设置key的值</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">例如：<span class="hljs-keyword">set</span> key <span class="hljs-comment">value ex 60 nx</span><br></code></pre></td></tr></table></figure><h3 id="问题2-业务超时，其他线程误删"><a href="#问题2-业务超时，其他线程误删" class="headerlink" title="问题2.业务超时，其他线程误删"></a>问题2.业务超时，其他线程误删</h3><p>假如线程A活得并加锁成功，锁30秒过期，但线程A执行在30秒内未执行完，这时候就自动释放锁了，且线程B获得并加锁成功，随后线程A执行完任务且执行del指令来释放锁，但此时线程B却未执行完。<strong>最终线程A删除的实际上是线程B加的锁！！！</strong></p><p><strong>解决方案：del释放锁之前做一个判断，验证当前的锁是不是自己加的。</strong></p><p>在加锁的时候设置一个唯一的指定值，可以存当前线程的id或者uuid</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">lock<span class="hljs-constructor">A()</span>&#123;<br>String key = <span class="hljs-string">&quot;lock_01&quot;</span><br><br><span class="hljs-comment">//采用当前线程的id</span><br>String value = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Id()</span><br><span class="hljs-comment">//采用uuid</span><br>String value = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span><br><br><span class="hljs-keyword">if</span>（setnx（key，value）<span class="hljs-operator"> == </span><span class="hljs-number">1</span>）&#123;<br><span class="hljs-comment">//设置锁的过期时间为60秒</span><br>    expire(key,<span class="hljs-number">60</span>,TimeUnit.MILLISECONDS)<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//做对应的业务逻辑</span><br>    &#125; finally &#123;<br>    <span class="hljs-comment">//删除锁，判断是不是当前线程加的锁</span><br>    <span class="hljs-keyword">if</span>(get(key).equals(value))&#123;<br>    <span class="hljs-comment">//还存在时间间隔</span><br>    del(key)<br>    &#125;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//睡眠100毫秒，然后自旋调用本方法</span><br>  lock<span class="hljs-constructor">A()</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题3-判断和释放锁是两个独立的操作，不是原子性操作"><a href="#问题3-判断和释放锁是两个独立的操作，不是原子性操作" class="headerlink" title="问题3.判断和释放锁是两个独立的操作，不是原子性操作"></a>问题3.判断和释放锁是两个独立的操作，不是原子性操作</h3><p>在判断是不是当前线程加的锁和del指令之间还存在时间间隔，因此仍存在误删的可能性。</p><p><strong>解决方案：采用lua脚本+redis</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(&quot;get&quot;,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(&quot;del&quot;,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>if中如果是true，那么执行del并返回del结果；如果if结果为false直接返回0</p><p>因为采用lua脚本来执行，所以<code>判断和删除</code>就是原子性操作了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//模拟优惠券来测试lua脚本</span><br>@<span class="hljs-constructor">GetMapping(<span class="hljs-string">&quot;testLua&quot;</span>)</span><br>public JsonData test<span class="hljs-constructor">Lua(@RequestParam(<span class="hljs-params">value</span> = <span class="hljs-string">&quot;coupon_id&quot;</span>, <span class="hljs-params">required</span> = <span class="hljs-params">true</span>)</span> <span class="hljs-built_in">int</span> couponId) &#123;<br>    String lockKey = <span class="hljs-string">&quot;lock:coupon:&quot;</span> + couponId;<br>    <span class="hljs-comment">//采用uuid防止其他线程误删</span><br>    String uuid = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    lock(couponId, lockKey, uuid);<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JsonData</span>.</span></span>build<span class="hljs-constructor">Success()</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> void lock(<span class="hljs-built_in">int</span> couponId, String lockKey, String uuid) &#123;<br>    <span class="hljs-comment">//lua脚本</span><br>    String script = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;<br>    <span class="hljs-comment">//获取锁并设置30秒过期时间</span><br>    Boolean nativeLock = stringRedisTemplate.ops<span class="hljs-constructor">ForValue()</span>.set<span class="hljs-constructor">IfAbsent(<span class="hljs-params">lockKey</span>, <span class="hljs-params">uuid</span>, Duration.<span class="hljs-params">ofSeconds</span>(30)</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(uuid + <span class="hljs-string">&quot;枷锁状态:&quot;</span> + nativeLock);<br>    <span class="hljs-keyword">if</span> (nativeLock) &#123;<br>        <span class="hljs-comment">//加锁成功</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//TODO 做相关业务逻辑</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">10L</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// e.printStackTrace();</span><br>        &#125; finally &#123;<br>            <span class="hljs-comment">//解锁</span><br>            Long result = stringRedisTemplate.execute(<span class="hljs-keyword">new</span> DefaultRedisScript&lt;&gt;(script, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Long</span>.</span></span><span class="hljs-keyword">class</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">lockKey</span>)</span>, uuid);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;解锁状态:&quot;</span> + result);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//自旋操作</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;加锁失败，睡眠5秒，进行自旋&quot;</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span>sleep(<span class="hljs-number">5000</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-comment">// e.printStackTrace();</span><br>        &#125;<br>        <span class="hljs-comment">//睡眠后再尝试获取锁</span><br>        lock(couponId, lockKey, uuid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结：Redis分布式锁的注意事项"><a href="#总结：Redis分布式锁的注意事项" class="headerlink" title="总结：Redis分布式锁的注意事项"></a>总结：Redis分布式锁的注意事项</h3><ul><li>使用原子性操作，避免宕机导致锁无法释放。</li><li>锁超时时间一定要结合业务情况权衡，过长，过短都不行。</li><li>释放锁时，根据value判断，防止误删。</li><li>程序异常之处，要捕获，并释放锁。如果需要回滚的，主动做回滚、补偿。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis通用指令+常见数据结构</title>
    <link href="/2022/01/15/Redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4+%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/15/Redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4+%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一-通用指令"><a href="#一-通用指令" class="headerlink" title="一.通用指令"></a>一.通用指令</h1><div class="table-container"><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">EXISTS key [key …]</td><td style="text-align:left">检查给定 <code>key</code> 是否存在</td></tr><tr><td style="text-align:left">DEL key [key …]</td><td style="text-align:left">删除给定的一个或多个 <code>key</code></td></tr><tr><td style="text-align:left">TYPE key</td><td style="text-align:left">字符串的形式返回存储在 <code>key</code> 中的值的类型</td></tr><tr><td style="text-align:left">TTL key</td><td style="text-align:left">以秒为单位返回 <code>key</code> 的剩余过期时间<br>用户客户端检查 <code>key</code> 还可以存在多久</td></tr></tbody></table></div><h1 id="二-常见数据结构"><a href="#二-常见数据结构" class="headerlink" title="二.常见数据结构"></a>二.常见数据结构</h1><h3 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1. String类型"></a>1. String类型</h3><ul><li><p>介绍：</p><ul><li>存储字符串类型的<code>key-value</code></li></ul></li><li><p>应用场景：</p><ul><li>验证码</li><li>计数器、发号器</li><li>订单重复提交令牌</li><li>热点商品卡片（序列化json对象存储）</li><li>分布式锁</li></ul></li><li><p>常用指令</p></li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>SET/GET key</td><td>设置和获取<code>key-value</code></td></tr><tr><td>MSET/MGET key [key …]</td><td>批量设置和获取多个<code>key-value</code></td></tr><tr><td>INCR key</td><td>将 <code>key</code> 中储存的数字值增一</td></tr><tr><td>INCRBY key increment</td><td>将 <code>key</code> 中储存的数字加上指定的增量值</td></tr><tr><td>SETEX key seconds value</td><td>将键 <code>key</code> 的值设置为 <code>value</code> ， 并将键 <code>key</code> 的生存时间设置为 <code>seconds</code> 秒钟。<strong>原子操作</strong></td></tr><tr><td>SETNX key value</td><td>key 不存在时，为 key 设置指定的值，等同 SET 命令。当 <code>key</code>存在时，什么也不做。<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists</td></tr><tr><td>GETSET key value</td><td>将键 <code>key</code> 的值设为<strong>新</strong> <code>value</code>，并返回<strong>旧</strong> <code>value</code></td></tr></tbody></table></div><ul><li><p>注意</p><ul><li>Redis中String的值能存储的最大容量：<strong><code>512M</code></strong></li><li>key命令规范：不能过长，冒号分隔，业务名:表名:ID</li></ul></li></ul><h3 id="2-List类型"><a href="#2-List类型" class="headerlink" title="2. List类型"></a>2. List类型</h3><ul><li><p>介绍：</p><ul><li>字符串列表：按插入顺序排序</li><li>双向链表：插入、删除时间复杂度为<code>O(1)</code>，查找为<code>O(n)</code></li></ul></li><li><p>应用场景：</p><ul><li>简单队列</li><li>最新评论列表：评论区第一页数据可以放在缓存中</li><li>非实时排行榜：定时计算榜单</li></ul></li><li><p>常用指令</p></li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>LPUSH key element [element …]</td><td>将一个或多个值插入到列表<code>key</code> 的头部</td></tr><tr><td>RPUSH key element [element …]</td><td>向存存储在 key 中的列表的尾部插入所有指定的值</td></tr><tr><td>LPOP key</td><td>删除并返回存储在 <code>key</code> 中的列表的第一个元素。</td></tr><tr><td>RPOP key</td><td>移除并返回列表 <code>key</code> 的最后一个元素</td></tr><tr><td>LLEN key</td><td>返回存储在 <code>key</code> 中的列表长度</td></tr><tr><td>LINDEX key index</td><td>返回列表 key 里索引 index 位置存储的元素。 index 下标是从 0 开始索引</td></tr><tr><td>LRANGE key start stop</td><td>返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。<br>其中 0 表示列表的第一个元素，-1 表示列表的最后一个元素</td></tr><tr><td>BRPOP key [key …] timeout</td><td>从给的列表参数中按顺序检查第一个不空的列表，然后从该列表的尾部移除元素。<br>如果列表中没有元素则会阻塞列表直到等待超时或发现可弹出的元素为止。</td></tr><tr><td>LREM key count element</td><td>从列表 key 中删除前 count 个值等于 <code>element</code> 的元素<br>count &gt; 0: 从头到尾删除值为 value 的元素<br> count &lt; 0: 从尾到头删除值为 value 的元素<br> count = 0: 移除所有值为 value 的元素</td></tr></tbody></table></div><ul><li><p>注意</p><ul><li>通常添加一个元素到头部（左边）或者尾部（右边）</li><li>存储的都是String字符串类型</li><li>支持分页操作，高并发项目中，第一页的数据来源于list，第二页及之后的数据则通过数据库加载</li><li>一个List列表最多可以包含$2^{32}$-1个元素</li></ul></li></ul><h3 id="3-Hash类型"><a href="#3-Hash类型" class="headerlink" title="3. Hash类型"></a>3. Hash类型</h3><ul><li><p>介绍：</p><ul><li>是一个String类型的<code>field</code>和<code>value</code>的映射表，Hash特别适用于存储对象</li></ul></li><li><p>应用场景：</p><ul><li>购物车</li><li>用户个人信息</li><li>商品详情</li></ul></li><li><p>常用指令</p></li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>HSET key field value [field value …]</td><td>将哈希表 <code>key</code> 中的 <code>field</code> 域的值设置为 <code>value</code><br>从 Redis 4.0 起，HSET 可以一次设置一个或多个 <code>field</code>/<code>value</code> 对</td></tr><tr><td>HMSET key field value [field value …]</td><td>同时将多个 <code>field-value</code> (域-值)对设置到哈希表 <code>key</code> 中<br>此命令会覆盖哈希表中已存在的域</td></tr><tr><td>HGET key field</td><td>返回哈希表 <code>key</code> 中的 <code>field</code> 域的值</td></tr><tr><td>HMGET key field [field …]</td><td>返回哈希表 <code>key</code> 中，一个或多少给定的 <code>field</code> 域的值</td></tr><tr><td>HGETALL key</td><td>返回哈希表 <code>key</code> 中所有的域和值</td></tr><tr><td>HEXISTS key field</td><td>查看哈希表 <code>key</code> 中的 <code>field</code> 域 是否存在</td></tr><tr><td>HDEL key field [field …]</td><td>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略</td></tr><tr><td>HINCRBY key field increment</td><td>为哈希表 <code>key</code> 中的 <code>field</code> 域的值加上增量 <code>increment</code></td></tr></tbody></table></div><ul><li><p>注意</p><ul><li>一个Hash表最多可以存储$2^{32}$-1键值对</li></ul></li></ul><h3 id="4-Set类型"><a href="#4-Set类型" class="headerlink" title="4. Set类型"></a>4. Set类型</h3><ul><li><p>介绍：</p><ul><li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li></ul></li><li><p>应用场景：</p><ul><li>去重</li><li>社交应用关注、粉丝、共同好友</li><li>统计网站的PV（页面浏览量）、UV（独立访客数）、IP</li><li>大数据中的用户画像标签集合</li></ul></li><li><p>常用指令</p></li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>SADD key member [member …]</td><td>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略</td></tr><tr><td>SCARD key</td><td>返回集合中元素的数量</td></tr><tr><td>SDIFF key [key …]</td><td>返回第一个集合与其他集合之间的差异，也可以认为是第一个集合中独有的元素</td></tr><tr><td>SINTER key [key …]</td><td>返回所有给定集合的成员交集</td></tr><tr><td>SISMEMBER key member</td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td>SMEMBERS key</td><td>返回 key 集合中的所有成员元素</td></tr><tr><td>SREM key member [member …]</td><td>删除 key 集合中指定的 member  元素。如果指定的元素不是集合成员则被忽略</td></tr><tr><td>SUNION key [key …]</td><td>返回所有给定集合的并集</td></tr></tbody></table></div><ul><li><p>注意</p><ul><li>集合是通过哈希表实现的</li><li>一个Set集合最多可以包含$2^{32}$-1个元素</li></ul></li></ul><h3 id="5-Sorted-Set类型"><a href="#5-Sorted-Set类型" class="headerlink" title="5. Sorted Set类型"></a>5. Sorted Set类型</h3><ul><li><p>介绍：</p><ul><li>Redis 的 Sorted Set 也是 String 类型的集合，且不允许重复的成员</li><li>每个元素都会关联一个 double 类型的分数，通过分数来为集合中的成员进行从小到大的排序</li><li>有序集合的成员是唯一的,但分数 ( score ) 却可以重复</li></ul></li><li><p>应用场景：</p><ul><li>实时排行榜：商品热销榜、体育类应用热门球队、积分榜</li><li>优先级任务、队列</li><li>朋友圈文章点赞-取消：用户只能点赞或取消，统计一篇文章点赞了多少次，可以直接取里面有多少个成员</li></ul></li><li><p>常用指令</p></li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>ZADD key score member [score member …]</td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td>ZCARD key</td><td>获取有序集合的成员数</td></tr><tr><td>ZCOUNT key min max</td><td>返回有序集 <code>key</code> 中， <code>score</code> 值在 <code>min</code> 和 <code>max</code> 之间(默认包括 <code>score</code> 值等于 <code>min</code> 或 <code>max</code> )的成员的数量</td></tr><tr><td>ZINCRBY key increment member</td><td>有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td>ZRANGE key start stop [WITHSCORES]</td><td>通过索引区间返回有序集合指定区间内的成员，按分数值<code>递增</code>排序</td></tr><tr><td>ZREVRANGE key start stop [WITHSCORES]</td><td>返回有序集中指定区间内的成员，通过索引，按分数值<code>递减</code>排序</td></tr><tr><td>ZRANK key member</td><td>返回有序集合中指定成员的排名，有序集成员按分数值<code>递增</code>排序</td></tr><tr><td>ZREVRANK key member</td><td>返回有序集合中指定成员的排名，有序集成员按分数值<code>递减</code>排序</td></tr><tr><td>ZREM key member [member …]</td><td>移除有序集合中的一个或多个成员</td></tr><tr><td>ZSCORE key member</td><td>返回有序集中，成员的分数值</td></tr></tbody></table></div><ul><li><p>注意</p><ul><li>底层使用 Ziplist压缩列表 和 “跳跃表” 两种存储结构</li><li>如果重复添加相同的数据，score值会被覆盖，保留最后一次修改的结果</li><li>一个Sorted Set集合最多可以包含$2^{32}$-1个元素</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis介绍及优缺点</title>
    <link href="/2022/01/15/Redis%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BC%98%E7%82%B9/"/>
    <url>/2022/01/15/Redis%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BC%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="一-什么是Redis？"><a href="#一-什么是Redis？" class="headerlink" title="一.什么是Redis？"></a>一.什么是Redis？</h1><p>Redis是开源免费，遵守BSD协议，高性能的<code>key-value</code>数据库。</p><h2 id="1-Redis与其他key-value缓存产品有以下三个特点"><a href="#1-Redis与其他key-value缓存产品有以下三个特点" class="headerlink" title="1. Redis与其他key-value缓存产品有以下三个特点"></a>1. Redis与其他key-value缓存产品有以下三个特点</h2><ol><li>Redis支持数据的持久化，可将内存中数据保存在磁盘中，重启时可再次加载进行使用。</li><li>Redis不仅支持key-value类型的数据，还支持list，hash，set，zset等数据结构。</li><li>Redis支持数据备份，即master-salve模式的数据备份。</li></ol><h2 id="2-Redis的优势（使用Redis的好处）"><a href="#2-Redis的优势（使用Redis的好处）" class="headerlink" title="2. Redis的优势（使用Redis的好处）"></a>2. Redis的优势（使用Redis的好处）</h2><ul><li>高性能：Redis读速度110000次/s，写速度81000次/s。数据存储在内存中。</li><li>丰富的数据类型：支持多种类型的数据结构，如字符串（strings）、散列（hashes）、 列表（lists）、 集合（sets）、 有序集合（sorted sets）等。</li><li>原子性：Redis所有操作都是原子性的。多个操作也支持事务，即原子性，通过MULTI 和EXEC 指令包起来。</li><li>丰富的特性：Redis支持publish/subscribe、通知、key过期等特性。</li></ul><h2 id="3-Redis与其他key-value存储的不同"><a href="#3-Redis与其他key-value存储的不同" class="headerlink" title="3. Redis与其他key-value存储的不同"></a>3. Redis与其他key-value存储的不同</h2><ul><li>Redis支持的数据结构更丰富且提供原子性操作。Redis的数据类型都是基于基本数据结构且对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但可以持久化到磁盘，因此在对不同数据集进行读写时需权衡内存，因为数据量不能大于硬件内存。</li><li>相比在磁盘上相同的复杂的数据结构，在内存中操作起来更简单，这也Redis可以做很多内部复杂性很强的事情。</li><li>在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们不需要进行随机访问。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/12/hello-world/"/>
    <url>/2022/01/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
