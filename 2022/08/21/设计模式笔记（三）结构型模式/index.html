

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
    <meta name="description" content="结构型模式适配器模式适配器模式介绍适配器模式的主要作用是把原本不兼容的接口通过适配修改做到统一，方便调用方使用。 变速箱通过不同齿轮之间的啮合，实现与不同转速的齿轮适配。 日常生活中用到的万能充电器、数据线和笔记本的转换接头，它们都为适配各种不同的接口进行了兼容。 除了日常生活中出现的各种物件适配的场景，在业务代码的开发中会有哪些场景呢？ 在业务开发中，经常需要做不同接口的兼容，尤其是中台服务。中">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式笔记（三）结构型模式">
<meta property="og:url" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name">
<meta property="og:description" content="结构型模式适配器模式适配器模式介绍适配器模式的主要作用是把原本不兼容的接口通过适配修改做到统一，方便调用方使用。 变速箱通过不同齿轮之间的啮合，实现与不同转速的齿轮适配。 日常生活中用到的万能充电器、数据线和笔记本的转换接头，它们都为适配各种不同的接口进行了兼容。 除了日常生活中出现的各种物件适配的场景，在业务代码的开发中会有哪些场景呢？ 在业务开发中，经常需要做不同接口的兼容，尤其是中台服务。中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-1.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-3.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-4.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-5.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-6.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-7.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-8.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-9.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-10.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-11.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-12.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-13.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-14.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-15.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-16.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-17.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-18.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-19.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-21.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-22.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-23.png">
<meta property="og:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-24.png">
<meta property="article:published_time" content="2022-08-21T01:17:57.787Z">
<meta property="article:modified_time" content="2022-08-21T16:00:58.501Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-1.png">
  
  
  
  <title>设计模式笔记（三）结构型模式 - </title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="设计模式笔记（三）结构型模式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-21 09:17" pubdate>
          2022年8月21日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          47k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          394 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式笔记（三）结构型模式</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="适配器模式介绍"><a href="#适配器模式介绍" class="headerlink" title="适配器模式介绍"></a>适配器模式介绍</h3><p>适配器模式的主要作用是把原本不兼容的接口通过适配修改做到统一，方便调用方使用。</p>
<p>变速箱通过不同齿轮之间的啮合，实现与不同转速的齿轮适配。</p>
<p>日常生活中用到的万能充电器、数据线和笔记本的转换接头，它们都为适配各种不同的接口进行了兼容。</p>
<p>除了日常生活中出现的各种物件适配的场景，在业务代码的开发中会有哪些场景呢？</p>
<p>在业务开发中，经常需要做不同接口的兼容，尤其是中台服务。中台需要把各个业务线的类型服务统一包装，再对外提供接口。</p>
<h3 id="MQ消息体兼容场景"><a href="#MQ消息体兼容场景" class="headerlink" title="MQ消息体兼容场景"></a>MQ消息体兼容场景</h3><p>随着公司业务的不断扩展，基础架构系统逐步成型，业务运营就需要开始做新用户的拉新和老用户的促活，从而保障DAU的增速，以及最终实现ROI转换</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-1.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这时就需要做一些营销系统，常见的有裂变、拉客，如邀请一位用户开户，或者邀请一位用户下单，平台就会返利，并且多邀多得。同时，随着拉新量的增多，平台开始设置每月首单返现等奖励。</p>
<p>开发这样一个营销系统就会遇到各种各样的MQ消息或接口，如果逐个开发，会耗费很高的成本，同时后期的扩展也有一定的难度。此时会希望有一个系统，配置后就能把外部的MQ接入，这些MQ就像上面提到的注册开户消息、商品下单消息等。而适配器的思想也恰恰可以运用在这里。需要强调的是，适配器不只可以适配接口，还可以适配一些属性信息。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这里模拟了三个不同类型的MQ消息：create_account、OrderMq和POPOrderDelivered。在消息体中有一些必要的字段，如用户ID、时间和业务ID，但是每个MQ的字段名称并不同，就像用户ID在不同的MQ里也有不同的字段uId、userId等一样。另外，这里还提供了两种不同类型的接口：OrderService 用于查询内部订单的下单数量，POPOrderService用于查询第三方是否为首单。</p>
<p>后面需要把这些不同类型的MQ和接口进行适配兼容，这种场景在开发中也很常见。</p>
<p><strong>注册开户MQ：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册开户MQ</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">create_account</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String number;      <span class="hljs-comment">// 开户编号</span><br>    <span class="hljs-keyword">private</span> String address;     <span class="hljs-comment">// 开户地</span><br>    <span class="hljs-keyword">private</span> Date accountDate;   <span class="hljs-comment">// 开户时间</span><br>    <span class="hljs-keyword">private</span> String desc;        <span class="hljs-comment">// 开户描述</span><br><br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在注册开户MQ消息体中，提供了四个核心属性：开户编号、开户地、开户时间和开户描述。</p>
<p><strong>内部订单MQ：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内部订单MQ</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderMq</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String uid;           <span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-keyword">private</span> String sku;           <span class="hljs-comment">// 商品编号</span><br>    <span class="hljs-keyword">private</span> String orderId;       <span class="hljs-comment">// 订单ID</span><br>    <span class="hljs-keyword">private</span> Date createOrderTime; <span class="hljs-comment">// 下单时间</span><br>    <br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在内部订单MQ的消息体中，提供了四个核心属性：用户ID、商品编号、订单ID和下单时间。</p>
<p><strong>第三方订单MQ：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单投递消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderDelivered</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String uId;     <span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-keyword">private</span> String orderId; <span class="hljs-comment">// 订单号</span><br>    <span class="hljs-keyword">private</span> Date orderTime; <span class="hljs-comment">// 下单时间</span><br>    <span class="hljs-keyword">private</span> Date sku;       <span class="hljs-comment">// 商品编号</span><br>    <span class="hljs-keyword">private</span> Date skuName;   <span class="hljs-comment">// 商品名称</span><br>    <span class="hljs-keyword">private</span> BigDecimal decimal; <span class="hljs-comment">// 商品金额</span><br>        <br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在第三方订单MQ的消息体中，提供了六个核心属性：用户ID、订单号、下单时间、商品编号、商品名称和商品金额。</p>
<p><strong>查询用户内部下单数量接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(POPOrderService.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">queryUserOrderCount</span><span class="hljs-params">(String userId)</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;自营商家，查询用户的订单是否为首单：&#123;&#125;&quot;</span>, userId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10L</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个接口主要用于查询用户在内部商家的下单数量。</p>
<p><strong>查询用户第三方下单首单接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(POPOrderService.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirstOrder</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;POP商家，查询用户的订单是否为首单：&#123;&#125;&quot;</span>, uId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个接口主要用于查询第三方订单是否为首单。</p>
<p>以上几项是不同的MQ及其接口的实现，后面将给这些MQ消息和接口做相应的适配，使程序的调用逻辑达到统一。</p>
<h3 id="违背设计模式实现"><a href="#违背设计模式实现" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>在大部分时候，各种MQ消息都在创建一个类用于消费，将它的MQ消息属性转换给自己的方法。</p>
<p>接下来同样先给出这种方式的实现过程，但是这里存在一个很大的问题：当MQ消息越来越多时，甚至达到几十个、几百个MQ消息后，中台服务应如何优化呢？</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-3.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这个工程中需要接收三个MQ消息，所以就有了三个对应的类create_accountMqService、OrderMqService、POPOrderDeliveredService。这和平时的代码几乎一样，如果MQ消息数量不多，则这种写法没什么问题；但如果是中台服务，随着对接服务数量的增加，需要考虑用一些设计模式来解决。</p>
<p><strong>MQ接收消息实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">create_accountMqService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        create_account mq = JSON.parseObject(message, create_account.class);<br>        mq.getNumber();<br>        mq.getAccountDate();<br>        <span class="hljs-comment">// ... 处理自己的业务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderMqService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        OrderMq mq = JSON.parseObject(message, OrderMq.class);<br>        mq.getUid();<br>        mq.getOrderId();<br>        mq.getCreateOrderTime();<br>        <span class="hljs-comment">// ... 处理自己的业务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderDeliveredService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        POPOrderDelivered mq = JSON.parseObject(message, POPOrderDelivered.class);<br>        mq.getuId();<br>        mq.getOrderId();<br>        mq.getOrderTime();<br>        <span class="hljs-comment">// ... 处理自己的业务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这三组MQ的消费类都是一样的，从这里也能看到它们的字段在使用上有一些相似。研发人员能够针对不规则的需求，按照统一的标准处理，降低开发成本，提高研发效率。</p>
<h3 id="适配器模式重构代码"><a href="#适配器模式重构代码" class="headerlink" title="适配器模式重构代码"></a>适配器模式重构代码</h3><p>适配器模式解决的主要问题是如何针对多种差异化类型的接口实现统一输出。在介绍工厂方法模式时，也提到过不同种类的奖品处理，其实也是适配器模式的应用。在本节中，还会再体现另外一个多种MQ消息接收的场景。把不同类型的消息中的属性字段做统一处理，便于减少后续人工硬编码方式对MQ的接收。如果没有开发过接收MQ消息的业务，会对这样的场景有些不理解。建议先了解MQ消息，即使没有了解，也不会影响对思路的理解。再者，本文展示的MQ兼容的核心部分，也是处理适配不同的类型字段。如果接收MQ消息后，在配置不同的消费类时不希望逐个开发消费MQ的类，那么可以使用代理类的方式处理。</p>
<p><strong>工程结构：</strong></p>
<p><img src alt><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-4.png" srcset="/img/loading.gif" lazyload alt="image-4"></p>
<p>适配器模式的工程结构提供了两种适配方式的代码：接口适配（OrderAdapterService）和MQ适配（MQAdapter）。之所以不只做接口适配的案例，因为这样的开发很常见。所以把适配的思想应用到MQ消息体上，增加对多设计模式的认知。先做MQ适配，接收各种各样的MQ消息。当业务发展得很快时，需要下单用户满足首单条件时才给予奖励，在这种场景下再增加对接口适配的操作。</p>
<p><strong>MQ适配：</strong></p>
<p>为了满足产品功能的需求，提取此项功能中必须的字段信息，单独创建一个类RebateInfo。后续所有的MQ信息都需要提供这些属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RebateInfo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String userId;<br>    <span class="hljs-keyword">private</span> String bizId;<br>    <span class="hljs-keyword">private</span> String bizTime;<br>    <span class="hljs-keyword">private</span> String desc;<br><br>    <span class="hljs-comment">// get/set...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>MQ消息中会有多种多样的类型属性，虽然它们都同样提供给使用方，但是如果都这样接入，那么当 MQ 消息特别多时就会很耗时。所以，在这个案例中定义了通用的 MQ消息体，后续把所有接入进来的消息进行统一的处理。</p>
<p><strong>MQ消息统一适配类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MQAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RebateInfo <span class="hljs-title">filter</span><span class="hljs-params">(String strJson, Map&lt;String, String&gt; link)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> filter(JSON.parseObject(strJson, Map.class), link);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RebateInfo <span class="hljs-title">filter</span><span class="hljs-params">(Map obj, Map&lt;String, String&gt; link)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        RebateInfo rebateInfo = <span class="hljs-keyword">new</span> RebateInfo();<br>        <span class="hljs-keyword">for</span> (String key : link.keySet()) &#123;<br>            Object val = obj.get(link.get(key));<br>            RebateInfo.class.getMethod(<span class="hljs-string">&quot;set&quot;</span> + key.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + key.substring(<span class="hljs-number">1</span>), String.class).invoke(rebateInfo, val.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> rebateInfo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个类里的方法非常重要，主要用于把不同类型的MQ中的各种属性映射成需要的属性并返回。就像一个属性中有用户ID uId，将其映射到需要的userId，做统一处理。而这个处理过程需要把映射管理传递给Map<String , string> link，也就是准确地描述了当前MQ中某个属性名称，映射为指定的某个属性名称。接收到的MQ消息基本是JSON格式，可以转换为MAP结构。最后，使用反射调用的方式对类型赋值。</String></p>
<p><strong>MQ消息适配测试验证:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_MQAdapter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        SimpleDateFormat s = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        Date parse = s.parse(<span class="hljs-string">&quot;2020-06-01 23:20:16&quot;</span>);<br><br>        create_account create_account = <span class="hljs-keyword">new</span> create_account();<br>        create_account.setNumber(<span class="hljs-string">&quot;100001&quot;</span>);<br>        create_account.setAddress(<span class="hljs-string">&quot;河北省.廊坊市.广阳区.大学里职业技术学院&quot;</span>);<br>        create_account.setAccountDate(parse);<br>        create_account.setDesc(<span class="hljs-string">&quot;在校开户&quot;</span>);<br><br>        HashMap&lt;String, String&gt; link01 = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        link01.put(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-string">&quot;number&quot;</span>);<br>        link01.put(<span class="hljs-string">&quot;bizId&quot;</span>, <span class="hljs-string">&quot;number&quot;</span>);<br>        link01.put(<span class="hljs-string">&quot;bizTime&quot;</span>, <span class="hljs-string">&quot;accountDate&quot;</span>);<br>        link01.put(<span class="hljs-string">&quot;desc&quot;</span>, <span class="hljs-string">&quot;desc&quot;</span>);<br><br>        RebateInfo rebateInfo01 = MQAdapter.filter(create_account.toString(), link01);<br>        System.out.println(<span class="hljs-string">&quot;mq.create_account(适配前)&quot;</span> + create_account.toString());<br>        System.out.println(<span class="hljs-string">&quot;mq.create_account(适配后)&quot;</span> + JSON.toJSONString(rebateInfo01));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里分别模拟传入了两个不同的MQ消息，并设置字段的映射关系。在实际业务开发场景中，可以把这种映射配置关系交给配置文件或数据库后台，以减少编码。</p>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mq.create_account(适配前)&#123;<span class="hljs-string">&quot;accountDate&quot;</span>:<span class="hljs-number">1591024816000</span>,<span class="hljs-string">&quot;address&quot;</span>:<span class="hljs-string">&quot;河北省.廊坊市.广阳区.大学里职业技术学院&quot;</span>,<span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;在校开户&quot;</span>,<span class="hljs-string">&quot;number&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>&#125;<br>mq.create_account(适配后)&#123;<span class="hljs-string">&quot;bizId&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;bizTime&quot;</span>:<span class="hljs-string">&quot;1591024816000&quot;</span>,<span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;在校开户&quot;</span>,<span class="hljs-string">&quot;userId&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，同样的字段值在实现适配前后，分别有统一的字段属性，开发时也就非常的简单了。另外，有一个非常重要的地方，除了反射的使用，还可以加入代理类，把映射的配置交给代理类，不需要手动创建类的每一个MQ。</p>
<p><strong>接口适配需求阐述：</strong></p>
<p>随着业务的发展，营销活动本身会修改，不再只是接入MQ就发放奖励。因为拉新的数量越来越多，需要做一些限制。因此增加了只有首单用户才发放奖励的规定，也就是每月、每年的首单或新人首次下单才发放奖励，而不是之前每一次下单都发放奖励。这时就需要对这种方式进行限制，而此时MQ中并没有判断首单的属性。只能通过接口进行查询。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cn.bugstack.design.service.OrderService.queryUserOrderCount(String userId)</td>
<td>出参 long，查询订单数量</td>
</tr>
<tr>
<td>cn.bugstack.design.service.POPOrderService.isFirstOrder(String uId)</td>
<td>出参 boolean，判断是否首单</td>
</tr>
</tbody>
</table>
</div>
<p>两个接口的判断逻辑和使用方式不同，不同的接口提供方也有不同的出参。一个是直接判断是否为首单，另一个需要根据订单数量判断，因此，这里需要通过适配器的模式实现。虽然使用if语句也可以实现，但是这样的写法会导致后期难以维护。</p>
<p><strong>定义统一适配接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderAdapterService</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirst</span><span class="hljs-params">(String uId)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>接口的实现需要完成此接口定义的方法，并把具体的逻辑包装到指定的类中，满足单一职责。</p>
<p><strong>分别实现两个不同的接口：</strong></p>
<ol>
<li><p><strong>内部商品接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内部订单，判断首单逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsideOrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderAdapterService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> OrderService orderService = <span class="hljs-keyword">new</span> OrderService();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirst</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderService.queryUserOrderCount(uId) &lt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>第三方商品接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方订单，判断首单逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POPOrderAdapterServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderAdapterService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> POPOrderService popOrderService = <span class="hljs-keyword">new</span> POPOrderService();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFirst</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> popOrderService.isFirstOrder(uId);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>这两种接口都实现了各自的判断方式，尤其对于提供订单数量的接口，需要自己判断当前接到MQ时订单数量是否小于或等于1，以此判断是否为首单。</p>
<p><strong>注意：</strong>在实际的业务开发中，由于下单消息的延时，可能这种方式是不准确的。本书主要为了体现不同接口的统一适配。</p>
<p>最终，两种不同类型的服务接口都可以按照统一的标准判断是否为首单。</p>
<p><strong>接口适配验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_itfAdapter</span><span class="hljs-params">()</span> </span>&#123;<br>    OrderAdapterService popOrderAdapterService = <span class="hljs-keyword">new</span> POPOrderAdapterServiceImpl();<br>    System.out.println(<span class="hljs-string">&quot;判断首单，接口适配（POP）：&quot;</span> + popOrderAdapterService.isFirst(<span class="hljs-string">&quot;100001&quot;</span>));<br><br>    OrderAdapterService insideOrderService = <span class="hljs-keyword">new</span> InsideOrderServiceImpl();<br>    System.out.println(<span class="hljs-string">&quot;判断首单，接口适配（自营）：&quot;</span> + insideOrderService.isFirst(<span class="hljs-string">&quot;100001&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">12.234</span> [main] INFO  c.b.design.service.POPOrderService - POP商家，查询用户的订单是否为首单：<span class="hljs-number">100001</span><br>判断首单，接口适配（第三方）：<span class="hljs-keyword">true</span><br><span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">12.234</span> [main] INFO  c.b.design.service.POPOrderService - 自营商家，查询用户的订单是否为首单：<span class="hljs-number">100001</span><br>判断首单，接口适配（内部）：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure>
<p>从测试结果来看，此时的接口已经统一包装，外部使用者不需要关心内部的具体逻辑。而且在调用时，只需要传入统一的参数即可，这样就能满足适配的作用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从本章可以看出，即使不使用适配器模式，也可以实现这些功能。但是使用了适配器模式可以让代码更干净、整洁，减少大量重复的判断和使用，同时也让代码更易于维护和扩展。尤其对于MQ等多种消息体中有不同属性的同类值（abc=”123”、def=”123”），进行适配再加上代理类，就可以使用简单的配置方式接入对方提供的MQ消息，而不需要重复地开发，非常利于扩展。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="桥接模式介绍"><a href="#桥接模式介绍" class="headerlink" title="桥接模式介绍"></a>桥接模式介绍</h3><p>桥接模式的主要作用是通过将抽象部分与实现部分分离，将多种可匹配的使用进行组合。其核心实现是在A类中含有B类接口，通过构造函数传递B类的实现，这个B类就是设计的桥。手机通过“桥”（蓝牙）可以连接玩具车、电视、冰箱和空调等智能家居。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-5.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这样的桥接模式存在于日常开发中的哪些场景里呢？包括 JDBC 多种驱动程序的实现、同品牌类型的台式机和笔记本电脑、业务实现中的多类接口同组过滤服务等。这些场景都比较适合用桥接模式实现，因为在一些组合中，如果每一个类都实现不同的服务，可能会出现笛卡儿积，而使用桥接模式就可以变得非常简单。</p>
<h3 id="多支付和多模式组合场景"><a href="#多支付和多模式组合场景" class="headerlink" title="多支付和多模式组合场景"></a>多支付和多模式组合场景</h3><p>在支付服务行业中，有微信、支付宝及一些其他支付服务，但是对于商家来说，并不能只接受某一种支付方式。如果商家只支持使用微信或支付宝付款，那么就会让顾客为难，商品销量也会受到影响。</p>
<p>这时就出现了第三方平台，它们把市面上的多种支付服务都集中到自己平台中，再把这些平台提供给店铺、超市等商家使用，同时支持人脸支付、指纹支付和密码支付等多种方式。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-6.png" srcset="/img/loading.gif" lazyload alt></p>
<p>下面的案例模拟一个第三方平台承接各种支付功能，同时使用人脸支付让用户支付起来更加容易。这里就出现了多支付与多模式的组合使用，如果给每一种支付方式都实现一种支付模式，即使是继承类的方式也需要开发多个功能类，并且随着后面接入了更多的支付服务或支付方式，将呈现爆炸式扩展。</p>
<p>这种场景该如何实现呢？</p>
<h3 id="违背设计模式实现-1"><a href="#违背设计模式实现-1" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-7.png" srcset="/img/loading.gif" lazyload alt></p>
<p>在这个工程结构中只有一个服务类 PayController，里面都是 if…else，它实现了支付类型和支付模式的全部功能。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(PayController.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doPay</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount, <span class="hljs-keyword">int</span> channelType, <span class="hljs-keyword">int</span> modeType)</span> </span>&#123;<br>        <span class="hljs-comment">// 微信支付</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == channelType) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;密码支付，风控校验环境安全&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;人脸支付，风控校验脸部识别&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;指纹支付，风控校验指纹信息&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 支付宝支付</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == channelType) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;密码支付，风控校验环境安全&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;人脸支付，风控校验脸部识别&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == modeType) &#123;<br>                logger.info(<span class="hljs-string">&quot;指纹支付，风控校验指纹信息&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 PayController 类中，有一个支付服务功能，提供必要字段：用户 ID、交易 ID、金额、渠道和模式，传递给doPay方法，以及控制支付类型。以上的if…else应该是最差的一种写法，因为即使写if…else，也应该以优化的方式写，尽可能减少使用次数。</p>
<p><strong>测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_pay</span><span class="hljs-params">()</span> </span>&#123;<br>        PayController pay = <span class="hljs-keyword">new</span> PayController();<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；微信支付、人脸方式。&quot;</span>);<br>        pay.doPay(<span class="hljs-string">&quot;weixin_1092033111&quot;</span>, <span class="hljs-string">&quot;100000109893&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；支付宝支付、指纹方式。&quot;</span>);<br>        pay.doPay(<span class="hljs-string">&quot;jlu19dlxo111&quot;</span>,<span class="hljs-string">&quot;100000109894&quot;</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上分别测试了两种不同的支付类型和支付模式：微信人脸支付和支付宝指纹支付。</p>
<p>运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">模拟测试场景；微信支付、人脸方式。<br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 模拟微信渠道支付划账开始。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 人脸支付，风控校验脸部识别<br><br>模拟测试场景；支付宝支付、指纹方式。<br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 模拟支付宝渠道支付划账开始。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">09.265</span> <span class="hljs-selector-attr">[main]</span> INFO  cn<span class="hljs-selector-class">.bugstack</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.PayController</span> - 指纹支付，风控校验指纹信息<br></code></pre></td></tr></table></figure>
<p>从测试结果看，已经满足了不同支付类型和支付模式的组合，但是这样的代码在后面的维护以及扩展过程中都会变得非常复杂。</p>
<h3 id="桥接模式重构代码"><a href="#桥接模式重构代码" class="headerlink" title="桥接模式重构代码"></a>桥接模式重构代码</h3><p>从上面的if…else实现方式来看，这是两种不同类型的相互组合。可以把支付类型和支付模式分离，通过抽象类依赖实现类的方式进行桥接。按照这种方式拆分后，支付方式与支付模式可以单独使用，当需要组合时，只需要把模式传递给各类支付方式。</p>
<p>桥接模式的关键是选择桥接点拆分，看能否找到这样类似的相互组合，如果没有就不用必须使用桥接模式。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-8.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>Pay是一个抽象类，下面是它的两种支付类型：微信支付和支付宝支付</li>
<li>IPayMode是一个接口，下面是它的三种支付模式：密码支付、人脸支付和指纹支付</li>
<li>支付类型×支付模式=相应的组合</li>
</ul>
<p><strong>注意：</strong>针对不同的支付模式，人脸支付和指纹支付校验逻辑也有差异，可以使用适配器模式进行处理，这里并非本节重点所以不做介绍，可以阅读适配器模式章节。</p>
<p><strong>支付类型桥接抽象类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pay</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(Pay.class);<br><br>    <span class="hljs-keyword">protected</span> IPayMode payMode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pay</span><span class="hljs-params">(IPayMode payMode)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.payMode = payMode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">transfer</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个类中定义了支付类型需要实现的划账接口transfer和桥接接口IPayMode，并在构造函数中实现用户方自行选择支付方式。如果没有接触过此类支付需求，可以重点关注IPayMode payMode，这部分是桥接模式的核心。</p>
<p><strong>两种支付类型的实现：</strong></p>
<ol>
<li><p><strong>微信支付</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pay</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WxPay</span><span class="hljs-params">(IPayMode payMode)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(payMode);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">transfer</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">boolean</span> security = payMode.security(uId);<br>        logger.info(<span class="hljs-string">&quot;模拟微信渠道支付风控校验。uId：&#123;&#125; tradeId：&#123;&#125; security：&#123;&#125;&quot;</span>, uId, tradeId, security);<br>        <span class="hljs-keyword">if</span> (!security) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账拦截。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0001&quot;</span>;<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;模拟微信渠道支付划账成功。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>支付宝支付</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZfbPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pay</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZfbPay</span><span class="hljs-params">(IPayMode payMode)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(payMode);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">transfer</span><span class="hljs-params">(String uId, String tradeId, BigDecimal amount)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账开始。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">boolean</span> security = payMode.security(uId);<br>        logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付风控校验。uId：&#123;&#125; tradeId：&#123;&#125; security：&#123;&#125;&quot;</span>, uId, tradeId, security);<br>        <span class="hljs-keyword">if</span> (!security) &#123;<br>            logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账拦截。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0001&quot;</span>;<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;模拟支付宝渠道支付划账成功。uId：&#123;&#125; tradeId：&#123;&#125; amount：&#123;&#125;&quot;</span>, uId, tradeId, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>这里分别模拟了调用第三方的两种支付渠道：微信和支付宝。当然，作为支付综合平台，可能不只接入了这两种渠道，还会有其他渠道。另外，可以看到，在支付时分别调用了风控的接口进行校验，也就是不同的模式支付（人脸、指纹），都需要通过指定的风控校验，才能保证支付安全。</p>
<p><strong>定义支付模式接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPayMode</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>任何一种支付模式，包括人脸、指纹和密码，都会通过风控校验不同程度的安全信息，这里定义一个安全校验接口。</p>
<p><strong>三种支付模式风控（人脸、指纹和密码）：</strong></p>
<ol>
<li><p><strong>人脸</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayFaceMode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPayMode</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(PayCypher.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;人脸支付，风控校验脸部识别&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>指纹</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayFingerprintMode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPayMode</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(PayCypher.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;指纹支付，风控校验指纹信息&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>密码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayCypher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPayMode</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Logger logger = LoggerFactory.getLogger(PayCypher.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">security</span><span class="hljs-params">(String uId)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;密码支付，风控校验环境安全&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>这里实现了人脸、指纹和密码三种支付模式的风控校验，在用户选择不同支付模式时，会进行相应的风控拦截，以保障支付安全。</p>
<p><strong>测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_pay</span><span class="hljs-params">()</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；微信支付、人脸方式。&quot;</span>);<br>        Pay wxPay = <span class="hljs-keyword">new</span> WxPay(<span class="hljs-keyword">new</span> PayFaceMode());<br>        wxPay.transfer(<span class="hljs-string">&quot;weixin_1092033111&quot;</span>, <span class="hljs-string">&quot;100000109893&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；支付宝支付、指纹方式。&quot;</span>);<br>        Pay zfbPay = <span class="hljs-keyword">new</span> ZfbPay(<span class="hljs-keyword">new</span> PayFingerprintMode());<br>        zfbPay.transfer(<span class="hljs-string">&quot;jlu19dlxo111&quot;</span>, <span class="hljs-string">&quot;100000109894&quot;</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>与上面的 if…else 实现方式相比，这里的调用方式变得整洁、干净和易用：new WxPay（new PayFaceMode（））、new ZfbPay（new PayFingerprintMode（））。外部使用接口的用户不需要关心具体的实现，只要按需选择使用即可。以上优化主要针对桥接模式的使用进行重构if逻辑部分。对于调用部分，可以使用抽象工厂或策略模式配合MAP结构。在 Map 结构中，Key 作为逻辑名称、Value 作为逻辑实现。通过这种方式把服务配置到Map键值对中，可以更方便地获取和使用，从而避免大量使用if…else。因为这里主要展示桥接模式，所以就不再额外多加代码，避免喧宾夺主。</p>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">模拟测试场景；微信支付、人脸方式。<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟微信渠道支付划账开始。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.mode.PayCypher - 人脸支付，风控校验脸部识别<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟微信渠道支付风控校验。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> security：<span class="hljs-keyword">true</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.565</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟微信渠道支付划账成功。uId：weixin_1092033111 tradeId：<span class="hljs-number">100000109893</span> amount：<span class="hljs-number">100</span><br><br>模拟测试场景；支付宝支付、指纹方式。<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟支付宝渠道支付划账开始。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> amount：<span class="hljs-number">100</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.mode.PayCypher - 指纹支付，风控校验指纹信息<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟支付宝渠道支付风控校验。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> security：<span class="hljs-keyword">true</span><br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">32.580</span> [main] INFO  cn.bugstack.design.channel.Pay - 模拟支付宝渠道支付划账成功。uId：jlu19dlxo111 tradeId：<span class="hljs-number">100000109894</span> amount：<span class="hljs-number">100</span><br><br>进程已结束,退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>从测试结果来看，内容也是一样的，但是整体的实现方式有了很大的变化。所以，有时不能只看结果，也要看具体的实现过程。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过模拟微信与支付宝两种支付类型在不同支付模式下的组合使用，体现了桥接模式的精髓。这种设计模式简化了代码的开发，给后续的需求迭代增加了很好的扩展性。</p>
<p>从桥接模式的实现形式来看，它满足了单一职责和开闭原则，让每一部分内容都很清晰，易于维护和扩展。但如果实现的是高内聚的代码，则会很复杂。所以在选择重构代码时，需要考虑整体的设计。如果运用的设计模式不合理，也会让代码变得难以开发和维护。</p>
<p>任何一种设计模式的选择和使用都应该以符合场景为主，不能刻意使用。由于业务的复杂性，可能需要用到多种设计模式，才能将代码设计得更加合理。但这种经验需要从实际的项目中总结经验，并且不断地实践运用。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="组合模式介绍"><a href="#组合模式介绍" class="headerlink" title="组合模式介绍"></a>组合模式介绍</h3><p>使用乐高玩具，通过一系列的连接组织出一棵 结构树。而这种通过把相似对象或方法组合成一组可被调用的结构树 对象的设计思路，称为组合模式。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-9.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这种设计方式可以让服务组节点进行自由组合并对外提供服务，例如有三个原子校验功能服务（A：身份证；B：银行卡；C：手机号）并对外提供调用。有些调用方需要使用 AB 组合，有些调用方需要使用 CBA 组合，还有一些调用方可能只使用三者中的一个。这时就可以使用组合模式构建服务，对于不同类型的调用方配置不同的组织关系树，而这个树形结构可以配置到数据库中，通过程序图形界面控制树形结构的创建和修改。</p>
<p>所以，不同的设计模式用得恰到好处，可以让代码逻辑非常清晰且易于扩展，同时也可以降低团队人员学习项目的成本。</p>
<h3 id="决策树场景模拟"><a href="#决策树场景模拟" class="headerlink" title="决策树场景模拟"></a>决策树场景模拟</h3><p>如图所示为一个简化版的营销规则决策树，根据性别、年龄的不同组合，发放不同类型的优惠券，目的是刺激消费，对精准用户进行促活。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-10.png" srcset="/img/loading.gif" lazyload alt></p>
<p>虽然我们可能没有开发过营销项目，但可能时时刻刻都在被营销着。例如，男生喜欢经常浏览机械键盘、笔记本电脑和汽车装饰等，商家会推荐此类商品的信息或优惠通知。女生喜欢浏览衣服、化妆品和箱包等，商家会推荐此类商品的信息或促销消息。虽然用户进入的是同一款软件，但最终展示的内容会略有不同，这些都是营销的案例。对于不常使用电商软件的用户，商家可能还会稍微加大折扣的力度，来增加用户黏性。</p>
<p>这里模拟一个类似的决策场景，体现组合模式在其中起到的作用。另外，组合模式不仅可以运用于规则决策树，还可以做服务包装，将不同的接口进行组合配置，对外提供服务能力，降低开发成本。</p>
<h3 id="违背设计模式实现-2"><a href="#违背设计模式实现-2" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>这里举一个关于if…else诞生的例子，介绍运营伙伴与研发人员之间的故事导致的事故。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>日期</th>
<th>需求</th>
<th>紧急程度</th>
<th>程序员（话外音）</th>
</tr>
</thead>
<tbody>
<tr>
<td>星期一，早上</td>
<td>哥哥，老板说要做一下营销活动，给男生和女生发不同的优惠券</td>
<td>很紧急，下班就要</td>
<td>行吧，也不难，加一下判断就上线</td>
</tr>
<tr>
<td>星期二，下午</td>
<td>哥哥，上线后效果非常好，老板说要让咱们按照年轻、中年和老年加一下判断，准确刺激消费</td>
<td>超紧急，明天就要</td>
<td>也不难，加就加吧</td>
</tr>
<tr>
<td>星期三，晚上</td>
<td>喂，睡了吗？老板说咱们这次活动很成功，是否可以再细分一下，把单身、结婚和有娃的都加上不同的判断，这样更能刺激消费</td>
<td>贼紧急，最快上线</td>
<td>已经意思到if…else越来越多了</td>
</tr>
<tr>
<td>星期四，凌晨</td>
<td>哇！你们太棒了，上戏真快，嘻嘻！有个小请求，需要调整一下年龄段，因为现在学生谈恋爱时更容易买某某东西，要改一下值！辛苦辛苦！</td>
<td>老板在等着呢</td>
<td>一大堆值要修改，哎！这么多if…else</td>
</tr>
<tr>
<td>星期五，半夜</td>
<td>喂，坏了，怎么发的优惠券不对了，有客诉了，很多女生都来投诉，你快看看，老板他……</td>
<td>一头汗，哎，值的位置粘错了</td>
<td>流下了悔恨的泪水</td>
</tr>
</tbody>
</table>
</div>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-11.png" srcset="/img/loading.gif" lazyload alt></p>
<p>上面的工程结构非常简单，把判断逻辑使用if…else写到一个类中。使用面向过程的优点是代码实现得快，但缺点也很多：不好维护和扩展，出了问题难以排查，新加功能的风险较高等。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(EngineController.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String userId, <span class="hljs-keyword">final</span> String userSex, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userAge)</span> </span>&#123;<br><br>        logger.info(<span class="hljs-string">&quot;ifelse实现方式判断用户结果。userId：&#123;&#125; userSex：&#123;&#125; userAge：&#123;&#125;&quot;</span>, userId, userSex, userAge);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;man&quot;</span>.equals(userSex)) &#123;<br>            <span class="hljs-keyword">if</span> (userAge &lt; <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实A&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (userAge &gt;= <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实B&quot;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;woman&quot;</span>.equals(userSex)) &#123;<br>            <span class="hljs-keyword">if</span> (userAge &lt; <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实C&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (userAge &gt;= <span class="hljs-number">25</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;果实D&quot;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果不考虑可扩展性和可维护性，上面的代码实现起来是最快的，而且从代码结构上看也便于理解。但非常不建议用这种方式实现代码逻辑，因为if语句嵌套太多，随着功能逻辑的扩展，会有越来越多的if语句，最终就是常说的一片烂代码。</p>
<p><strong>测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ApiTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_EngineController</span><span class="hljs-params">()</span> </span>&#123;<br>        EngineController engineController = <span class="hljs-keyword">new</span> EngineController();<br>        String process = engineController.process(<span class="hljs-string">&quot;Oli09pLkdjh&quot;</span>, <span class="hljs-string">&quot;man&quot;</span>, <span class="hljs-number">29</span>);<br>        logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, process);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里模拟了一个用户ID，并传输性别为man、年龄为29，预期结果为果实B。</p>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">36</span>:<span class="hljs-number">25.650</span> [main] INFO  cn.bugstack.design.EngineController - ifelse实现方式判断用户结果。userId：Oli09pLkdjh userSex：man userAge：<span class="hljs-number">29</span><br><span class="hljs-number">14</span>:<span class="hljs-number">36</span>:<span class="hljs-number">25.654</span> [main] INFO  cn.bugstack.design.test.ApiTest - 测试结果：果实B<br></code></pre></td></tr></table></figure>
<p>从测试结果来看，程序运行正常并且符合预期，只不过实现方式并不是我们推荐的。接下来会采用组合模式优化这部分代码。</p>
<h3 id="组合模式重构代码"><a href="#组合模式重构代码" class="headerlink" title="组合模式重构代码"></a>组合模式重构代码</h3><p>重构代码的改动量相对来说会比较大，为了把不同类型的决策节点和最终的果实组装成一棵可被程序运行的决策树，需要做适配设计和工厂方法调用，具体会体现在定义接口和抽象类、初始化配置决策节点（性别、年龄）上。建议多阅读几遍这部分代码，最好动手实践。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-12.png" srcset="/img/loading.gif" lazyload alt></p>
<p>树形结构原子模块实现关系从LogicFilter开始定义适配的决策过滤器，BaseLogic是对接口的实现，以提供最基本的通用方法。UserAgeFilter和UserGenerFilter是两个具体的实现类，用于判断年龄和性别。树形结构执行引擎是对这棵可以被组织出来的决策树进行执行的引擎，同样定义了引擎接口和基础的配置，在配置里面设定了需要的模式决策节点。</p>
<p><strong>决策树对象类：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>包路径</th>
<th>类</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>model.aggregates</td>
<td>TreeRich</td>
<td>聚合对象：包含组织树信息</td>
</tr>
<tr>
<td>model.vo</td>
<td>EngineResult</td>
<td>决策结果：返回对象信息</td>
</tr>
<tr>
<td>model.vo</td>
<td>TreeNode</td>
<td>树节点：包括叶子节点，果实节点</td>
</tr>
<tr>
<td>model.vo</td>
<td>TreeNodeLink</td>
<td>树节点链路关系</td>
</tr>
<tr>
<td>model.vo</td>
<td>TreeRoot</td>
<td>树根信息</td>
</tr>
</tbody>
</table>
</div>
<p>以上是在model包下的对象，用于描述决策树的各项信息类，包括：聚合对象、决策结果、树节点、树节点链路关系和树根信息。</p>
<p><strong>树节点逻辑过滤器接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LogicFilter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 逻辑决策器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> matterValue          决策值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeNodeLineInfoList 决策节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 下一个节点Id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Long <span class="hljs-title">filter</span><span class="hljs-params">(String matterValue, List&lt;TreeNodeLink&gt; treeNodeLineInfoList)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取决策值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> decisionMatter 决策物料</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 决策值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这部分定义了适配的通用接口和相应的方法：逻辑决策器方法、获取决策值方法，让每一个提供决策能力的节点都必须实现此接口，保证统一性。</p>
<p><strong>决策抽象类提供基础服务：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseLogic</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LogicFilter</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">filter</span><span class="hljs-params">(String matterValue, List&lt;TreeNodeLink&gt; treeNodeLinkList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TreeNodeLink nodeLine : treeNodeLinkList) &#123;<br>            <span class="hljs-keyword">if</span> (decisionLogic(matterValue, nodeLine)) <span class="hljs-keyword">return</span> nodeLine.getNodeIdTo();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">decisionLogic</span><span class="hljs-params">(String matterValue, TreeNodeLink nodeLink)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (nodeLink.getRuleLimitType()) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> matterValue.equals(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &gt; Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &lt; Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &lt;= Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-keyword">return</span> Double.parseDouble(matterValue) &gt;= Double.parseDouble(nodeLink.getRuleLimitValue());<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在抽象方法中实现了接口方法，同时定义了基本的决策方法：1、2、3、4、5，等于、小于、大于、小于或等于、大于或等于的判断逻辑。同时定义了抽象方法，让每一个实现接口的类都必须按照规则提供决策值，这个决策值用于进行逻辑比对。</p>
<p><strong>树节点逻辑实现类：</strong></p>
<ol>
<li><p><strong>年龄节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAgeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseLogic</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> decisionMatter.get(<span class="hljs-string">&quot;age&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>性别节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGenderFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseLogic</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">matterValue</span><span class="hljs-params">(Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> decisionMatter.get(<span class="hljs-string">&quot;gender&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>以上两个决策逻辑的节点获取值的方式都非常简单，只获取用户的入参即可。实际的业务开发可能需要通过数据库、RPC接口和缓存运算等各种方式获取产品需要的信息。</p>
<p><strong>决策引擎接口定义：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IEngine</span> </span>&#123;<br><br>    <span class="hljs-function">EngineResult <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Long treeId, <span class="hljs-keyword">final</span> String userId, TreeRich treeRich, <span class="hljs-keyword">final</span> Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于调用方来说，也同样需要定义统一的接口操作，这样的好处是便于后续扩展出不同类型的决策引擎，也就是建造不同的决策工厂。</p>
<p><strong>决策节点配置：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Map&lt;String, LogicFilter&gt; logicFilterMap;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        logicFilterMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>        logicFilterMap.put(<span class="hljs-string">&quot;userAge&quot;</span>, <span class="hljs-keyword">new</span> UserAgeFilter());<br>        logicFilterMap.put(<span class="hljs-string">&quot;userGender&quot;</span>, <span class="hljs-keyword">new</span> UserGenderFilter());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, LogicFilter&gt; <span class="hljs-title">getLogicFilterMap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> logicFilterMap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLogicFilterMap</span><span class="hljs-params">(Map&lt;String, LogicFilter&gt; logicFilterMap)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.logicFilterMap = logicFilterMap;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里可以将服务的决策节点配置到Map结构中，这样的Map结构可以抽取到XML或数据库中，就可以方便地在 ERP 界面中配置服务了。当需要变更时，不用改动代码，便于管理。</p>
<p><strong>基础决策引擎功能：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EngineConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IEngine</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(EngineBase.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> EngineResult <span class="hljs-title">process</span><span class="hljs-params">(Long treeId, String userId, TreeRich treeRich, Map&lt;String, String&gt; decisionMatter)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> TreeNode <span class="hljs-title">engineDecisionMaker</span><span class="hljs-params">(TreeRich treeRich, Long treeId, String userId, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        TreeRoot treeRoot = treeRich.getTreeRoot();<br>        Map&lt;Long, TreeNode&gt; treeNodeMap = treeRich.getTreeNodeMap();<br>        <span class="hljs-comment">// 规则树根ID</span><br>        Long rootNodeId = treeRoot.getTreeRootNodeId();<br>        TreeNode treeNodeInfo = treeNodeMap.get(rootNodeId);<br>        <span class="hljs-comment">//节点类型[NodeType]；1子叶、2果实</span><br>        <span class="hljs-keyword">while</span> (treeNodeInfo.getNodeType().equals(<span class="hljs-number">1</span>)) &#123;<br>            String ruleKey = treeNodeInfo.getRuleKey();<br>            LogicFilter logicFilter = logicFilterMap.get(ruleKey);<br>            String matterValue = logicFilter.matterValue(treeId, userId, decisionMatter);<br>            Long nextNode = logicFilter.filter(matterValue, treeNodeInfo.getTreeNodeLinkList());<br>            treeNodeInfo = treeNodeMap.get(nextNode);<br>            logger.info(<span class="hljs-string">&quot;决策树引擎=&gt;&#123;&#125; userId：&#123;&#125; treeId：&#123;&#125; treeNode：&#123;&#125; ruleKey：&#123;&#125; matterValue：&#123;&#125;&quot;</span>, treeRoot.getTreeName(), userId, treeId, treeNodeInfo.getTreeNodeId(), ruleKey, matterValue);<br>        &#125;<br>        <span class="hljs-keyword">return</span> treeNodeInfo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里主要提供决策树流程的处理过程，有点像通过链路的关系（性别、年龄）在二叉树中寻找果实节点的过程。同时提供一个抽象方法，执行决策流程的方法，供外部做具体的实现。</p>
<p><strong>决策引擎的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeEngineHandle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EngineBase</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EngineResult <span class="hljs-title">process</span><span class="hljs-params">(Long treeId, String userId, TreeRich treeRich, Map&lt;String, String&gt; decisionMatter)</span> </span>&#123;<br>        <span class="hljs-comment">// 决策流程</span><br>        TreeNode treeNode = engineDecisionMaker(treeRich, treeId, userId, decisionMatter);<br>        <span class="hljs-comment">// 决策结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EngineResult(userId, treeId, treeNode.getTreeNodeId(), treeNode.getNodeValue());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里对于决策引擎的实现就非常简单了，通过传递进来的必要信息——决策树信息、决策物料值，做具体的树形结构决策。</p>
<p><strong>初始化决策树数据：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 节点：1</span><br>    TreeNode treeNode_01 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_01.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_01.setTreeNodeId(<span class="hljs-number">1L</span>);<br>    treeNode_01.setNodeType(<span class="hljs-number">1</span>);<br>    treeNode_01.setNodeValue(<span class="hljs-keyword">null</span>);<br>    treeNode_01.setRuleKey(<span class="hljs-string">&quot;userGender&quot;</span>);<br>    treeNode_01.setRuleDesc(<span class="hljs-string">&quot;用户性别[男/女]&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：1-&gt;11</span><br>    TreeNodeLink treeNodeLink_11 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_11.setNodeIdFrom(<span class="hljs-number">1L</span>);<br>    treeNodeLink_11.setNodeIdTo(<span class="hljs-number">11L</span>);<br>    treeNodeLink_11.setRuleLimitType(<span class="hljs-number">1</span>);<br>    treeNodeLink_11.setRuleLimitValue(<span class="hljs-string">&quot;man&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：1-&gt;12</span><br>    TreeNodeLink treeNodeLink_12 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_12.setNodeIdFrom(<span class="hljs-number">1L</span>);<br>    treeNodeLink_12.setNodeIdTo(<span class="hljs-number">12L</span>);<br>    treeNodeLink_12.setRuleLimitType(<span class="hljs-number">1</span>);<br>    treeNodeLink_12.setRuleLimitValue(<span class="hljs-string">&quot;woman&quot;</span>);<br><br>    List&lt;TreeNodeLink&gt; treeNodeLinkList_1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    treeNodeLinkList_1.add(treeNodeLink_11);<br>    treeNodeLinkList_1.add(treeNodeLink_12);<br><br>    treeNode_01.setTreeNodeLinkList(treeNodeLinkList_1);<br><br>    <span class="hljs-comment">// 节点：11</span><br>    TreeNode treeNode_11 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_11.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_11.setTreeNodeId(<span class="hljs-number">11L</span>);<br>    treeNode_11.setNodeType(<span class="hljs-number">1</span>);<br>    treeNode_11.setNodeValue(<span class="hljs-keyword">null</span>);<br>    treeNode_11.setRuleKey(<span class="hljs-string">&quot;userAge&quot;</span>);<br>    treeNode_11.setRuleDesc(<span class="hljs-string">&quot;用户年龄&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：11-&gt;111</span><br>    TreeNodeLink treeNodeLink_111 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_111.setNodeIdFrom(<span class="hljs-number">11L</span>);<br>    treeNodeLink_111.setNodeIdTo(<span class="hljs-number">111L</span>);<br>    treeNodeLink_111.setRuleLimitType(<span class="hljs-number">3</span>);<br>    treeNodeLink_111.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：11-&gt;112</span><br>    TreeNodeLink treeNodeLink_112 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_112.setNodeIdFrom(<span class="hljs-number">11L</span>);<br>    treeNodeLink_112.setNodeIdTo(<span class="hljs-number">112L</span>);<br>    treeNodeLink_112.setRuleLimitType(<span class="hljs-number">5</span>);<br>    treeNodeLink_112.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    List&lt;TreeNodeLink&gt; treeNodeLinkList_11 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    treeNodeLinkList_11.add(treeNodeLink_111);<br>    treeNodeLinkList_11.add(treeNodeLink_112);<br><br>    treeNode_11.setTreeNodeLinkList(treeNodeLinkList_11);<br><br>    <span class="hljs-comment">// 节点：12</span><br>    TreeNode treeNode_12 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_12.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_12.setTreeNodeId(<span class="hljs-number">12L</span>);<br>    treeNode_12.setNodeType(<span class="hljs-number">1</span>);<br>    treeNode_12.setNodeValue(<span class="hljs-keyword">null</span>);<br>    treeNode_12.setRuleKey(<span class="hljs-string">&quot;userAge&quot;</span>);<br>    treeNode_12.setRuleDesc(<span class="hljs-string">&quot;用户年龄&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：12-&gt;121</span><br>    TreeNodeLink treeNodeLink_121 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_121.setNodeIdFrom(<span class="hljs-number">12L</span>);<br>    treeNodeLink_121.setNodeIdTo(<span class="hljs-number">121L</span>);<br>    treeNodeLink_121.setRuleLimitType(<span class="hljs-number">3</span>);<br>    treeNodeLink_121.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    <span class="hljs-comment">// 链接：12-&gt;122</span><br>    TreeNodeLink treeNodeLink_122 = <span class="hljs-keyword">new</span> TreeNodeLink();<br>    treeNodeLink_122.setNodeIdFrom(<span class="hljs-number">12L</span>);<br>    treeNodeLink_122.setNodeIdTo(<span class="hljs-number">122L</span>);<br>    treeNodeLink_122.setRuleLimitType(<span class="hljs-number">5</span>);<br>    treeNodeLink_122.setRuleLimitValue(<span class="hljs-string">&quot;25&quot;</span>);<br><br>    List&lt;TreeNodeLink&gt; treeNodeLinkList_12 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    treeNodeLinkList_12.add(treeNodeLink_121);<br>    treeNodeLinkList_12.add(treeNodeLink_122);<br><br>    treeNode_12.setTreeNodeLinkList(treeNodeLinkList_12);<br><br>    <span class="hljs-comment">// 节点：111</span><br>    TreeNode treeNode_111 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_111.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_111.setTreeNodeId(<span class="hljs-number">111L</span>);<br>    treeNode_111.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_111.setNodeValue(<span class="hljs-string">&quot;果实A&quot;</span>);<br><br>    <span class="hljs-comment">// 节点：112</span><br>    TreeNode treeNode_112 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_112.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_112.setTreeNodeId(<span class="hljs-number">112L</span>);<br>    treeNode_112.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_112.setNodeValue(<span class="hljs-string">&quot;果实B&quot;</span>);<br><br>    <span class="hljs-comment">// 节点：121</span><br>    TreeNode treeNode_121 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_121.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_121.setTreeNodeId(<span class="hljs-number">121L</span>);<br>    treeNode_121.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_121.setNodeValue(<span class="hljs-string">&quot;果实C&quot;</span>);<br><br>    <span class="hljs-comment">// 节点：122</span><br>    TreeNode treeNode_122 = <span class="hljs-keyword">new</span> TreeNode();<br>    treeNode_122.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeNode_122.setTreeNodeId(<span class="hljs-number">122L</span>);<br>    treeNode_122.setNodeType(<span class="hljs-number">2</span>);<br>    treeNode_122.setNodeValue(<span class="hljs-string">&quot;果实D&quot;</span>);<br><br>    <span class="hljs-comment">// 树根</span><br>    TreeRoot treeRoot = <span class="hljs-keyword">new</span> TreeRoot();<br>    treeRoot.setTreeId(<span class="hljs-number">10001L</span>);<br>    treeRoot.setTreeRootNodeId(<span class="hljs-number">1L</span>);<br>    treeRoot.setTreeName(<span class="hljs-string">&quot;规则决策树&quot;</span>);<br><br>    Map&lt;Long, TreeNode&gt; treeNodeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    treeNodeMap.put(<span class="hljs-number">1L</span>, treeNode_01);<br>    treeNodeMap.put(<span class="hljs-number">11L</span>, treeNode_11);<br>    treeNodeMap.put(<span class="hljs-number">12L</span>, treeNode_12);<br>    treeNodeMap.put(<span class="hljs-number">111L</span>, treeNode_111);<br>    treeNodeMap.put(<span class="hljs-number">112L</span>, treeNode_112);<br>    treeNodeMap.put(<span class="hljs-number">121L</span>, treeNode_121);<br>    treeNodeMap.put(<span class="hljs-number">122L</span>, treeNode_122);<br><br>    treeRich = <span class="hljs-keyword">new</span> TreeRich(treeRoot, treeNodeMap);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意：</strong>这部分是组合模式非常重要的使用，在已经建造好的决策树关系下，可以创建出树的各个节点，以及对节点间使用链路进行串联。即使后续需要做任何业务的扩展，都可以在里面添加相应的节点，并做动态化的配置。这部分手动组合的方式可以提取到数据库中，也可以扩展到图形界面配置操作。</p>
<p><strong>测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_tree</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;决策树组合结构信息：\r\n&quot;</span> + JSON.toJSONString(treeRich));<br><br>    IEngine treeEngineHandle = <span class="hljs-keyword">new</span> TreeEngineHandle();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试数据</span><br><span class="hljs-comment">     * 果实A：gender=man、age=22</span><br><span class="hljs-comment">     * 果实B：gender=man、age=29</span><br><span class="hljs-comment">     * 果实C：gender=woman、age=22</span><br><span class="hljs-comment">     * 果实D：gender=woman、age=29</span><br><span class="hljs-comment">     */</span><br>    Map&lt;String, String&gt; decisionMatter = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    decisionMatter.put(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;man&quot;</span>);<br>    decisionMatter.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;29&quot;</span>);<br><br>    EngineResult result = treeEngineHandle.process(<span class="hljs-number">10001L</span>, <span class="hljs-string">&quot;Oli09pLkdjh&quot;</span>, treeRich, decisionMatter);<br>    logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, JSON.toJSONString(result));<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在单元测试中，提供了通过组合模式创建出的流程决策树，调用时传入了决策树的ID。在业务开发中，可以很方便地解耦决策树与业务的绑定关系，按需传入决策树ID即可。这里的入参提供了需要决策的信息男（man）、年龄（29 岁）的参数信息。另外，以下数据也可以模拟测试。</p>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.805</span> [main] INFO  cn.bugstack.design.test.ApiTest - 决策树组合结构信息：<br>&#123;<span class="hljs-string">&quot;treeNodeMap&quot;</span>:&#123;<span class="hljs-number">112</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实B&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">112</span>&#125;,<span class="hljs-number">1</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleDesc&quot;</span>:<span class="hljs-string">&quot;用户性别[男/女]&quot;</span>,<span class="hljs-string">&quot;ruleKey&quot;</span>:<span class="hljs-string">&quot;userGender&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;treeNodeLinkList&quot;</span>:[&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;man&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;woman&quot;</span>&#125;]&#125;,<span class="hljs-number">121</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实C&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">121</span>&#125;,<span class="hljs-number">122</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实D&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">122</span>&#125;,<span class="hljs-number">11</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleDesc&quot;</span>:<span class="hljs-string">&quot;用户年龄&quot;</span>,<span class="hljs-string">&quot;ruleKey&quot;</span>:<span class="hljs-string">&quot;userAge&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;treeNodeLinkList&quot;</span>:[&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">111</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">112</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;]&#125;,<span class="hljs-number">12</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ruleDesc&quot;</span>:<span class="hljs-string">&quot;用户年龄&quot;</span>,<span class="hljs-string">&quot;ruleKey&quot;</span>:<span class="hljs-string">&quot;userAge&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;treeNodeLinkList&quot;</span>:[&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">121</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;nodeIdFrom&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;nodeIdTo&quot;</span>:<span class="hljs-number">122</span>,<span class="hljs-string">&quot;ruleLimitType&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;ruleLimitValue&quot;</span>:<span class="hljs-string">&quot;25&quot;</span>&#125;]&#125;,<span class="hljs-number">111</span>:&#123;<span class="hljs-string">&quot;nodeType&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实A&quot;</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeNodeId&quot;</span>:<span class="hljs-number">111</span>&#125;&#125;,<span class="hljs-string">&quot;treeRoot&quot;</span>:&#123;<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;treeName&quot;</span>:<span class="hljs-string">&quot;规则决策树&quot;</span>,<span class="hljs-string">&quot;treeRootNodeId&quot;</span>:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.821</span> [main] INFO  c.b.d.d.service.engine.EngineBase - 决策树引擎=&gt;规则决策树 userId：Oli09pLkdjh treeId：<span class="hljs-number">10001</span> treeNode：<span class="hljs-number">11</span> ruleKey：userGender matterValue：man<br><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.821</span> [main] INFO  c.b.d.d.service.engine.EngineBase - 决策树引擎=&gt;规则决策树 userId：Oli09pLkdjh treeId：<span class="hljs-number">10001</span> treeNode：<span class="hljs-number">112</span> ruleKey：userAge matterValue：<span class="hljs-number">29</span><br><span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">29.821</span> [main] INFO  cn.bugstack.design.test.ApiTest - 测试结果：&#123;<span class="hljs-string">&quot;nodeId&quot;</span>:<span class="hljs-number">112</span>,<span class="hljs-string">&quot;nodeValue&quot;</span>:<span class="hljs-string">&quot;果实B&quot;</span>,<span class="hljs-string">&quot;success&quot;</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;treeId&quot;</span>:<span class="hljs-number">10001</span>,<span class="hljs-string">&quot;userId&quot;</span>:<span class="hljs-string">&quot;Oli09pLkdjh&quot;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>从测试结果可以得出程序运行正常，这与使用if…else编码风格实现的结果是一致的。但代码经过组合模式重构后，非常便于业务功能的拓展和代码维护。此外，整体的组织关系框架及调用决策流程已经搭建完成，如果阅读到此还没有完全理解，可以参考源代码工程结构并运行调试。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>从以上的决策树场景来看，组合模式主要解决的是在不同结构的组织下，一系列简单逻辑节点或者扩展的复杂逻辑节点对外部的调用仍然可以非常简单。这种设计模式保证了开闭原则，无须更改模型结构就可以提供新的逻辑节点，并配合组织出新的关系树。当然，如果是一些功能差异化非常大的接口，则包装起来也会变得比较困难，但也并非不能很好地处理，只不过需要做一些适配和特定的开发。</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="装饰器模式介绍"><a href="#装饰器模式介绍" class="headerlink" title="装饰器模式介绍"></a>装饰器模式介绍</h3><p>装饰器模式就像俄罗斯套娃，它的核心是在不改变原有类的基础上给类新增功能。对于不改变原有类，可能有的人会想到继承、AOP 切面，虽然这些方式都可以实现，但是使用装饰器模式是另外一种更灵活的思路，能够避免继承导致的子类过多问题，也可以避免AOP带来的复杂性问题。</p>
<p>很多熟悉的场景都用到了装饰器模式，例如是否熟悉 new BufferedReader（new FileReader（””））；这段代码？大家在学习Java开发的字节流、字符流和文件流的内容时都见到过，一层嵌套一层，字节流转字符流等。这就是使用装饰器模式的一种体现。</p>
<h3 id="单点登录场景模拟"><a href="#单点登录场景模拟" class="headerlink" title="单点登录场景模拟"></a>单点登录场景模拟</h3><p>本案例模拟一个单点登录权限功能扩充的场景。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-13.png" srcset="/img/loading.gif" lazyload alt></p>
<p>在业务开发的初期，往往运营人员使用的是 ERP 系统，只需要登录账户验证即可，验证通过后即可访问 ERP 的所有资源。但随着业务的不断发展，团队里开始出现专门的运营人员、营销人员和数据人员，每类人员对ERP的使用需求不同，有些需要创建活动，有些只是查看数据。同时，为了保证数据的安全，不会让每位运营人员都有最高的权限。</p>
<p>那么，以往使用的 SSO 是一个组件化通用的服务，不能在里面添加需要的用户访问验证功能。这时就可以使用装饰器模式扩充原有的单点登录服务，同时也保证原有功能不受破坏，可以继续使用。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-14.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这里模拟的是Spring类HandlerInterceptor，实现接口功能SsoInterceptor模拟的单点登录拦截服务。为了避免引入太多的 Spring 内容，影响对设计模式的理解，这里使用了同名的类和方法，尽可能减少外部的依赖。</p>
<p><strong>模拟Spring的HandlerInterceptor：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际的单点登录开发会基于 org.springframework.web.servlet.HandlerInterceptor 实现。这里为了减少对Spring包的引入，自己实现一个这样的功能类。</p>
<p><strong>模拟单点登录功能：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SsoInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟获取cookie</span><br>        String ticket = request.substring(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>        <span class="hljs-comment">// 模拟校验</span><br>        <span class="hljs-keyword">return</span> ticket.equals(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的模拟实现非常简单，只是截取字符串，在实际使用时，需要从HttpServletRequest request对象中获取cookie信息，解析 ticket 值并校验。在返回的里面也非常简单，只要获取到了 success，就认为是允许登录。实际的业务代码会更加复杂，这里只是简单模拟了整个过程，方便学习。</p>
<h3 id="违背设计模式实现-3"><a href="#违背设计模式实现-3" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>继承类的实现方式是一种比较通用的方式，通过继承后重写方法，并将逻辑覆盖进去。对于一些简单的且不需要持续维护和扩展的场景，此种方式的实现并不会有什么问题，也不会导致子类过多。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-15.png" srcset="/img/loading.gif" lazyload alt></p>
<p>以上的工程结构非常简单，只是通过 LoginSsoDecorator 继承 SsoInterceptor，重写方法功能。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginSsoDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SsoInterceptor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; authMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        authMap.put(<span class="hljs-string">&quot;huahua&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>        authMap.put(<span class="hljs-string">&quot;doudou&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 模拟获取cookie</span><br>        String ticket = request.substring(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>        <span class="hljs-comment">// 模拟校验</span><br>        <span class="hljs-keyword">boolean</span> success = ticket.equals(<span class="hljs-string">&quot;success&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        String userId = request.substring(<span class="hljs-number">8</span>);<br>        String method = authMap.get(userId);<br><br>        <span class="hljs-comment">// 模拟方法校验</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;queryUserInfo&quot;</span>.equals(method);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这部分代码的实现方式是通过继承类后重写方法，将个人可访问方法的功能添加到方法中。这段代码比较清晰，如果面对比较复杂的业务流程，代码就会很变得混乱。注意，这里已经设定好两个可以访问的用户ID：huahua、doudou，会在测试中使用。</p>
<p><strong>测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_LoginSsoDecorator</span><span class="hljs-params">()</span> </span>&#123;<br>        LoginSsoDecorator ssoDecorator = <span class="hljs-keyword">new</span> LoginSsoDecorator();<br>        String request = <span class="hljs-string">&quot;1successhuahua&quot;</span>;<br>        <span class="hljs-keyword">boolean</span> success = ssoDecorator.preHandle(request, <span class="hljs-string">&quot;ewcdqwt40liuiu&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;登录校验：&quot;</span> + request + (success ? <span class="hljs-string">&quot; 放行&quot;</span> : <span class="hljs-string">&quot; 拦截&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里模拟的内容相当于登录过程中的校验操作，判断用户是否可登录以及是否可访问方法。</p>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">登录校验：1successhuahua 放行<br></code></pre></td></tr></table></figure>
<p>从测试结果来看满足预期，已经对用户 huahua 做了放行。在学习的过程中，可以尝试模拟单点登录并继承扩展功能。</p>
<h3 id="装饰器模式重构代码"><a href="#装饰器模式重构代码" class="headerlink" title="装饰器模式重构代码"></a>装饰器模式重构代码</h3><p>装饰器主要解决的是直接继承时因功能的不断横向扩展导致子类膨胀的问题，而使用装饰器模式比直接继承更加灵活，同时也不再需要维护子类。</p>
<p>在装饰器模式中，有四点比较重要：</p>
<ul>
<li>抽象构件角色（Component）：定义抽象接口</li>
<li>具体构件角色（ConcreteComponent）：实现抽象接口，可以是 一组</li>
<li>装饰角色（Decorator）：定义抽象类并实现接口中的方法，保证一致性</li>
<li>具体装饰角色（ConcreteDecorator）：扩展装饰具体的实现逻辑</li>
</ul>
<p>通过以上四种实现装饰器模式，主要核心内容会体现在抽象类的定义和实现方面。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-16.png" srcset="/img/loading.gif" lazyload alt></p>
<p>重点的类是SsoDecorator，它表示一个抽象类主要完成了对接口 HandlerInterceptor 的继承。当装饰角色继承接口后，会提供构造函数 SsoDecorator（HandlerInterceptor handlerInterceptor），入参是继承的接口实现类，可以很方便地扩展出不同的功能组件。</p>
<p><strong>抽象类装饰角色：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SsoDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> HandlerInterceptor handlerInterceptor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SsoDecorator</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SsoDecorator</span><span class="hljs-params">(HandlerInterceptor handlerInterceptor)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.handlerInterceptor = handlerInterceptor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> handlerInterceptor.preHandle(request, response, handler);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在装饰类中，有三点需要注意：实现了处理接口，提供了构造函数，覆盖了方法preHandle。以上三点是装饰器模式的核心处理部分，可以替换对子类继承的方式，实现逻辑功能的扩展。</p>
<p><strong>装饰角色逻辑实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginSsoDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SsoDecorator</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginSsoDecorator.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; authMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        authMap.put(<span class="hljs-string">&quot;huahua&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>        authMap.put(<span class="hljs-string">&quot;doudou&quot;</span>, <span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginSsoDecorator</span><span class="hljs-params">(HandlerInterceptor handlerInterceptor)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(handlerInterceptor);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(String request, String response, Object handler)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">super</span>.preHandle(request, response, handler);<br>        <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        String userId = request.substring(<span class="hljs-number">8</span>);<br>        String method = authMap.get(userId);<br>        logger.info(<span class="hljs-string">&quot;模拟单点登录方法访问拦截校验：&#123;&#125; &#123;&#125;&quot;</span>, userId, method);<br>        <span class="hljs-comment">// 模拟方法校验</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;queryUserInfo&quot;</span>.equals(method);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在具体的装饰类实现中，继承了装饰类 SsoDecorator，现在可以扩展方法 preHandle 的功能。在具体的实现代码中可以看到，这里只关心扩展部分的功能，同时不会影响原有类的核心服务，也不会因为使用继承方式而导致出现多余子类，增加了整体的灵活性。</p>
<p><strong>测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_LoginSsoDecorator</span><span class="hljs-params">()</span> </span>&#123;<br>        LoginSsoDecorator ssoDecorator = <span class="hljs-keyword">new</span> LoginSsoDecorator(<span class="hljs-keyword">new</span> SsoInterceptor());<br>        String request = <span class="hljs-string">&quot;1successhuahua&quot;</span>;<br>        <span class="hljs-keyword">boolean</span> success = ssoDecorator.preHandle(request, <span class="hljs-string">&quot;ewcdqwt40liuiu&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;登录校验：&quot;</span> + request + (success ? <span class="hljs-string">&quot; 放行&quot;</span> : <span class="hljs-string">&quot; 拦截&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里测试了装饰器模式的使用，通过将原有单点登录类new SsoInterceptor（）传递给装饰器，让装饰器可以执行扩充的功能。同时，传递者和装饰器都可以是多组的。在实际的业务开发中，往往由于有 太多类型的子类要实现，导致不易于维护，可以使用装饰器模式替代。</p>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">04.942</span> [main] INFO  cn.bugstack.design.LoginSsoDecorator - 模拟单点登录方法访问拦截校验：huahua queryUserInfo<br>登录校验：1successhuahua 放行<br></code></pre></td></tr></table></figure>
<p>测试结果符合预期，扩展了对方法拦截的校验性。如果在学习的过程中用过单点登录，那么可以适当地在里面采用扩展装饰器模式练习。另外，还有一种场景也可以使用装饰器。例如，之前实现某个接口接收单个消息，但由于外部的升级变为发送list集合消息，但又不希望所有的代码类都修改这部分逻辑，就可以使用装饰器模式进行适配list集合，给使用者的依然是for循环后的单个消息。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>装饰器模式满足单一职责原则，可以在自己的装饰类中完成功能逻辑的扩展而不影响主类，同时可以按需在运行时添加和删除这部分逻辑。另外，装饰器模式和继承父类重写方法在某些时候要按需选择，并非某个方式就是最好的。装饰器模式实现的重点是对抽象类继承接口方式的使用，同时设定被继承的接口可以通过构造函数传递其实现类，由此增加扩展性，并重写方法中可以通过父类实现的功能。装饰器模式就像夏天热时穿短裤，冬天冷时穿棉裤，下雨时穿雨衣一 样，我们本身并没有被改变，而外形却用不同的服饰表现。生活中的场景比比皆是，如果能够将生活中的例子融入代码实现中，往往会创造出更加优雅的实现方式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="外观模式介绍"><a href="#外观模式介绍" class="headerlink" title="外观模式介绍"></a>外观模式介绍</h3><p>物流公司的货物从上架到分拣出库，对外部的送货人和取货人来说，他们并不需要知道仓库内的工作。这种模式称为外观模式，也叫门面模式。它主要解决的是降低调用方使用接口时的复杂逻辑组合。在调用方与实际的接口提供方之间添加了一个中间层，向包装逻辑提供API接口。有时外观模式也被用在中间件层，用服务中的通用性复杂逻辑包装中间件层，让使用方可以只关心业务开发，简化调用。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-17.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这种设计模式在设计产品功能时也经常会遇到，例如以往注册成为一家网站的用户时，往往要添加很多信息，包括姓名、昵称、手机号、QQ、邮箱和住址等，但现在只需要一步即可，无论是手机号还是微信，都提供了这种登录服务。对于服务端应用开发来说，以前是提供了一整套的接口，现在注册时并没有这些信息，那么服务端就需要包装接口，在前端调用注册时，服务端各个渠道获取相应的用户信息。如果获取不到，会让用户后续补全，以此来提高用户的注册量和活跃度。</p>
<h3 id="中间件场景模拟"><a href="#中间件场景模拟" class="headerlink" title="中间件场景模拟"></a>中间件场景模拟</h3><p>本章模拟一个将所有服务接口添加白名单的场景。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-18.png" srcset="/img/loading.gif" lazyload alt></p>
<p>在项目不断壮大发展的过程中，每一次发版上线都需要测试，而这部分测试验证一般会通过白名单开量或切量的方式验证。如果在每一个接口中都添加这种逻辑，就会非常麻烦且不易维护。另外，这是一类具备通用逻辑的共性需求，非常适合开发成组件，以此治理服务，从而让研发人员可以将精力放在业务功能逻辑的开发上。</p>
<p>一般情况下，外观模式通常用在复杂的场景中，或有多个接口需要包装以统一对外提供服务时。此种使用方式相对简单，在日常的业务开发中也是最常用的。本例把这种设计思路放到中间件层，让服务变得可以统一控制。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-19.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这是一个 SpringBoot 的 HelloWorld 工程，在工程中提供了查询用户信息的接口HelloWorldController.queryUserInfo，为后续扩展此接口的白名单过滤做准备。</p>
<p><strong>定义基础查询接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@DoDoor</span> 自定义注解</span><br><span class="hljs-comment">     * key：需要从入参取值的属性字段，如果是对象则从对象中取值，如果是单个值则直接使用</span><br><span class="hljs-comment">     * returnJson：预设拦截时返回值，是返回对象的Json</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * http://localhost:8080/api/queryUserInfo?userId=1001</span><br><span class="hljs-comment">     * http://localhost:8080/api/queryUserInfo?userId=小团团</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DoDoor(key = &quot;userId&quot;, returnJson = &quot;&#123;\&quot;code\&quot;:\&quot;1111\&quot;,\&quot;info\&quot;:\&quot;非白名单可访问用户拦截！\&quot;&#125;&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/api/queryUserInfo&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">queryUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;虫虫:&quot;</span> + userId, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;天津市南开区旮旯胡同100号&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里提供了一个基本的查询服务，通过入参userId查询用户信息，后续需要扩展白名单功能。白名单是指只有指定用户才可以查询，其他用户不能查询。</p>
<p><strong>设置Application启动类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(HelloWorldApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里是通用的SpringBoot启动类。需要添加的是一个配置注解@Configuration，便于后续读取白名单配置。</p>
<h3 id="违背设计模式实现-4"><a href="#违背设计模式实现-4" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>最简单的做法是直接修改代码。累加if块既是实现需求最快也是最慢的方式，快是指修改当前内容快，慢是指如果同类的内容有几百个，都需要使用这种修改方式，会让后续扩展和维护的进度越来越慢。</p>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20.png" srcset="/img/loading.gif" lazyload alt></p>
<p>以上的实现方式是模拟一个API接口类，在里面添加白名单功能，但类似这种接口有很多地方需要修改，这也是不推荐使用此种方式的主要原因。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldController</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">queryUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String userId)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 做白名单拦截</span><br>        List&lt;String&gt; userList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        userList.add(<span class="hljs-string">&quot;1001&quot;</span>);<br>        userList.add(<span class="hljs-string">&quot;aaaa&quot;</span>);<br>        userList.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!userList.contains(userId)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;1111&quot;</span>, <span class="hljs-string">&quot;非白名单可访问用户拦截！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;虫虫:&quot;</span> + userId, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;天津市南开区旮旯胡同100号&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从以上的实现方式可以看出，白名单的逻辑代码占据了一大块，但它不是业务功能流程中的逻辑，只是因为上线过程中需要在开量前测试验证。如果平时对待此类需求是用这种方式解决的，那么可以按照此种设计模式进行优化，让后续的扩展和剔除更容易。</p>
<h3 id="外观模式重构代码"><a href="#外观模式重构代码" class="headerlink" title="外观模式重构代码"></a>外观模式重构代码</h3><p>这次重构的核心是使用外观模式，结合SpringBoot中自定义starter中间件开发的方式，统一处理所有需要开白名单逻辑的代码。</p>
<p>在接下来的实现过程中，涉及的知识点包括：</p>
<ul>
<li>SpringBoot的starter中间件开发方式</li>
<li>面向切面编程和自定义注解的使用方法</li>
<li>外部自定义配置信息的透传。SpringBoot与Spring不同，对于此类方式获取白名单配置存在差异</li>
</ul>
<p><strong>工程结构：</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-21.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>注意：</strong>设计模式讲求的是思想，而不是固定的实现方式。</p>
<p><strong>配置服务类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String userStr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StarterService</span><span class="hljs-params">(String userStr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userStr = userStr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String[] split(String separatorChar) &#123;<br>        <span class="hljs-keyword">return</span> StringUtils.split(<span class="hljs-keyword">this</span>.userStr, separatorChar);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置服务类的内容比较简单，只是为了获取 SpringBoot 中配置文件的信息内容。</p>
<p><strong>配置类注解定义：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;itstack.door&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterServiceProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String userStr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserStr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userStr;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserStr</span><span class="hljs-params">(String userStr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userStr = userStr;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置类注解用于定义后续在 application.yml 中添加 itstack.door 的配置信息。</p>
<p><strong>获取自定义配置类信息：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(StarterService.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(StarterServiceProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterAutoConfigure</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StarterServiceProperties properties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;itstack.door&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span><br>    <span class="hljs-function">StarterService <span class="hljs-title">starterService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StarterService(properties.getUserStr());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码是获取配置的过程，主要是对注解@Configuration、@ConditionalOnClass、@EnableConfigurationProperties的定义，这一部分主要是与SpringBoot的结合使用方法。</p>
<p><strong>切面注解定义：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DoDoor &#123;<br><br>    <span class="hljs-function">String <span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">returnJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>切面注解定义了外观模式切面注解，后续将此注解添加到需要扩展白名单的方法上。这里提供了两个入参：key获取某个字段，例如用户ID；returnJson确定白名单拦截后返回的具体内容。</p>
<p><strong>白名单切面逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoJoinPoint</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(DoJoinPoint.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StarterService starterService;<br><br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(cn.bugstack.design.door.annotation.DoDoor)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aopPoint</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;aopPoint()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doRouter</span><span class="hljs-params">(ProceedingJoinPoint jp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Method method = getMethod(jp);<br>        DoDoor door = method.getAnnotation(DoDoor.class);<br><br>        String keyValue = getFiledValue(door.key(), jp.getArgs());<br>        logger.info(<span class="hljs-string">&quot;itstack door handler method：&#123;&#125; value：&#123;&#125;&quot;</span>, method.getName(), keyValue);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == keyValue || <span class="hljs-string">&quot;&quot;</span>.equals(keyValue)) <span class="hljs-keyword">return</span> jp.proceed();<br><br>        String[] split = starterService.split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-comment">// 白名单过滤</span><br>        <span class="hljs-keyword">for</span> (String str : split) &#123;<br>            <span class="hljs-keyword">if</span> (keyValue.equals(str)) &#123;<br>                <span class="hljs-keyword">return</span> jp.proceed();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 拦截</span><br>        <span class="hljs-keyword">return</span> returnObject(door, method);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">getMethod</span><span class="hljs-params">(JoinPoint jp)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>        Signature sig = jp.getSignature();<br>        MethodSignature methodSignature = (MethodSignature) sig;<br>        <span class="hljs-keyword">return</span> getClass(jp).getMethod(methodSignature.getName(), methodSignature.getParameterTypes());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Class&lt;? extends Object&gt; getClass(JoinPoint jp) <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>        <span class="hljs-keyword">return</span> jp.getTarget().getClass();<br>    &#125;<br><br>    <span class="hljs-comment">//返回对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">returnObject</span><span class="hljs-params">(DoDoor doGate, Method method)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;<br>        Class&lt;?&gt; returnType = method.getReturnType();<br>        String returnJson = doGate.returnJson();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(returnJson)) &#123;<br>            <span class="hljs-keyword">return</span> returnType.newInstance();<br>        &#125;<br>        <span class="hljs-keyword">return</span> JSON.parseObject(returnJson, returnType);<br>    &#125;<br><br>    <span class="hljs-comment">//获取属性值</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFiledValue</span><span class="hljs-params">(String filed, Object[] args)</span> </span>&#123;<br>        String filedValue = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == filedValue || <span class="hljs-string">&quot;&quot;</span>.equals(filedValue)) &#123;<br>                    filedValue = BeanUtils.getProperty(arg, filed);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>].toString();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> filedValue;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里包括的内容较多，核心逻辑主要是 Object doRouter（ProceedingJoinPoint jp），接下来分别介绍：</p>
<ul>
<li><p>@Pointcut(“@annotation(cn.bugstack.design.door.annot ation.DoDoor)”)</p>
<p>定义切面，这里采用的是注解路径，也就是所有加入这个注解的方法都会被切面管理</p>
</li>
<li><p>getFiledValue</p>
<p>获取指定key，也就是获取入参中的某个属性，这里主要是获取用户ID，通过ID拦截校验</p>
</li>
<li><p>returnObject</p>
<p>返回拦截后的转换对象，当非白名单用户访问时，会返回一些提示信息</p>
</li>
<li><p>doRouter</p>
<p>切面核心逻辑，这部分主要是判断当前访问的用户ID是否为白名单用户。如果是，则放行jp.proceed（）；，否则返回自定义的拦截提示信息</p>
</li>
</ul>
<p><strong>重构后工程验证：</strong></p>
<p>这里的测试会在工程cn-bugstack-design-13.0-0中进行，通过引入jar包、配置注解的方式验证。</p>
<p><strong>引入中间件POM配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.bugstack.design<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tutorials-13.0-2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>打包白名单控制中间件工程cn-bugstack-design-13.0-2，给外部提供jar包服务。在实际的开发中，将这种jar包上传到Maven仓库，供调用方引入。</p>
<p><strong>配置application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 自定义中间件配置</span><br><span class="hljs-attr">itstack:</span><br>  <span class="hljs-attr">door:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">userStr:</span> <span class="hljs-number">1001</span><span class="hljs-string">,aaaa,ccc</span> <span class="hljs-comment">#白名单用户ID，多个逗号隔开</span><br></code></pre></td></tr></table></figure>
<p>这里主要加入了白名单的开关和用户ID，用逗号隔开。即用户ID为1001、aaaa和ccc的三位用户可以正常访问接口。</p>
<p><strong>在Controller中添加自定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * http://localhost:8080/api/queryUserInfo?userId=1001</span><br><span class="hljs-comment"> * http://localhost:8080/api/queryUserInfo?userId=小团团</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@DoDoor(key = &quot;userId&quot;, returnJson = &quot;&#123;\&quot;code\&quot;:\&quot;1111\&quot;,\&quot;info\&quot;:\&quot;非白名单可访问用户拦截！\&quot;&#125;&quot;)</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/api/queryUserInfo&quot;, method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">queryUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String userId)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo(<span class="hljs-string">&quot;虫虫:&quot;</span> + userId, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;天津市南开区旮旯胡同100号&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>核心的内容主要是对自定义的注解添加@DoDoor，即外观模式的中间件化实现。</p>
<ul>
<li>key：是需要从入参中取值的属性字段，如果是对象，则从对象中取值；如果是单个值，则直接使用</li>
<li>returnJson：是预设拦截时的返回值，是返回对象的JSON文件</li>
</ul>
<p><strong>启动SpringBoot</strong></p>
<p>启动正常，SpringBoot 已经可以对外提供服务。启动的过程非常简单，直接在类HelloWorldApplication中运行即可</p>
<p><strong>访问接口测试</strong></p>
<ol>
<li><p><strong>白名单用户访问</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-22.png" srcset="/img/loading.gif" lazyload alt></p>
<p>此时的测试结果显示正常，可以收到接口数据。</p>
</li>
<li><p><strong>非白名单用户访问</strong></p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-23.png" srcset="/img/loading.gif" lazyload alt></p>
<p>这次把userId换成小团团，此时返回的信息已经是被拦截的信息。而这个拦截信息正是自定义注解中的信息@DoDoor（key=”userId”，returnJson=”{\”code\”：\”1111\”，\”info\”：\”非白名单可访问用户拦截！\”}”）。</p>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>本章通过中间件的方式实现外观模式，这种设计可以很好地增强代码的隔离性及复用性，不仅使用起来非常灵活，也降低了对每一个系统开发白名单拦截服务带来的风险及测试成本。可能有读者认为这只是非常简单的白名单控制，会有是否需要这样处理的疑问。但往往一个小小的开始会影响后续迭代的扩展，实际的业务开发往往也会复杂得多。很多时候不是设计模式没有用，而是研发人员的编程开发经验不足，导致即使学了设计模式也很难驾驭。毕竟这些知识都是经过一些实际操作提炼出来的，只要按照本书中案例的方式学习实操，是可以提升代码架构和设计能力的。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="享元模式介绍"><a href="#享元模式介绍" class="headerlink" title="享元模式介绍"></a>享元模式介绍</h3><p>享元模式主要用于共享通用对象，减少内存的使用，提升系统的访问效率。较大的对象通常比较耗费内存，需要查询大量的接口或使用数据库资源，因此有必要统一抽离出来作为共享对象使用。</p>
<p>另外，享元模式可以分为在服务端和在客户端，一般在互联网H5和Web场景下，大部分数据都需要在服务端处理，如数据库连接池的使用、多线程线程池的使用。除了这些功能，有些需要经过服务端包装处理再下发给客户端，因为服务端需要做享元处理。但在一些游戏场 景中，很多客户端需要渲染地图效果，如树木、花草、鱼虫，通过设置不同的元素描述，使用享元共用对象，可以减少内存的占用，让客户端的游戏更加流畅。在享元模式的实现过程中，需要用到享元工厂管理独立的对象和共享的对象，避免出现线程安全的问题。</p>
<h3 id="缓存优化查询场景"><a href="#缓存优化查询场景" class="headerlink" title="缓存优化查询场景"></a>缓存优化查询场景</h3><p>本案例模拟商品秒杀场景中使用享元模式优化查询。</p>
<p><img src="/2022/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-24.png" srcset="/img/loading.gif" lazyload alt></p>
<p>你是否经历过一个商品下单功能的项目，从最初的日均十几单到一个月后每个时段流量破万。如果没有相关经验，最初可能会使用数据库行级锁的方式保证商品库存的扣减操作。随着业务的快速发展，参与秒杀的用户越来越多，这时数据库已经无法支撑，所以一般会使用Redis的分布式锁控制商品库存。另外，针对不同商品信息的查询，不需要每次都从数据库中获取，因为除了商品库存，其他商品信息都是固定不变的，所以一般会缓存到Redis中。这里模拟使用享元模式搭建工厂结构，提供活动商品的查询服务。商品信息相当于不变的信息，商品库存相当于变化的信息。</p>
<h3 id="违背设计模式实现-5"><a href="#违背设计模式实现-5" class="headerlink" title="违背设计模式实现"></a>违背设计模式实现</h3><p>对于这部分逻辑的查询，一般情况下都是先查询固定不变的商品信息，再使用过滤的信息或通过添加if判断的方式补充变化的信息，也就是商品库存。虽然采用这种编写方式在最开始并不会发现什么问题，但随着方法逻辑的增加，就会有越来越多的重复代码。</p>
<p><strong>工程结构：</strong></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>设计模式笔记（三）结构型模式</div>
      <div>http://yoursite.com/2022/08/21/设计模式笔记（三）结构型模式/</div>
    </div>
    <div class="license-meta">
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式笔记（二）创建型模式">
                        <span class="hidden-mobile">设计模式笔记（二）创建型模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
