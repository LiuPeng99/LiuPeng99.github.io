

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
    <meta name="description" content="Lambda表达式需求分析创建一个新的线程，指定线程要执行的任务 123456789101112131415public class Demo01Lambda &amp;#123;    public static void main(String[] args) &amp;#123;        &#x2F;&#x2F;开启一个新的线程        new Thread(new Runnable() &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK8新特性笔记">
<meta property="og:url" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Lambda表达式需求分析创建一个新的线程，指定线程要执行的任务 123456789101112131415public class Demo01Lambda &amp;#123;    public static void main(String[] args) &amp;#123;        &#x2F;&#x2F;开启一个新的线程        new Thread(new Runnable() &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-1.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-2.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-3.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-4.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-5.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-6.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-7.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-8.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-9.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-10.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-11.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-13.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-14.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-15.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-16.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-17.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-18.png">
<meta property="og:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-19.png">
<meta property="article:published_time" content="2022-08-14T10:18:11.073Z">
<meta property="article:modified_time" content="2022-08-19T06:42:40.584Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/2022/08/14/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/JDK8新特性笔记/image-1.png">
  
  
  
  <title>JDK8新特性笔记 - </title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"MktjiUfWXW9zem7A0x05gCWO-gzGzoHsz","app_key":"lEDgafWi9K8r0wRObdJ78mOw","server_url":"https://mktjiufw.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>:)L</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JDK8新特性笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-14 18:18" pubdate>
          2022年8月14日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          58k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          484 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JDK8新特性笔记</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：1 个月前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>创建一个新的线程，指定线程要执行的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//开启一个新的线程</span><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;新线程中执行的代码：&quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;).start();<br>        System.out.println(<span class="hljs-string">&quot;主线程中的代码：&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;新线程Lambda表达式：&quot;</span> + Thread.currentThread().getName());<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>Thread类需要一个Runnable接口作为参数，其中的抽象方法run方法是用来指定线程任务内容的核心</li>
<li>为了指定run方法体，不得不需要一个Runnable的实现类</li>
<li>为了省去定义一个Runnable的实现类，不得不使用匿名内部类</li>
<li>必须覆盖重写抽象的run方法，所有的方法名称、方法参数、方法返回值都不得不重写一遍，而且不能出错</li>
<li>但是，在实际上我们只在乎方法体中的代码</li>
</ul>
<h2 id="Lambda表达式初体验"><a href="#Lambda表达式初体验" class="headerlink" title="Lambda表达式初体验"></a>Lambda表达式初体验</h2><p>Lambda表达式是一个匿名函数，可以理解为一段可以传递的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>	System.out.println(<span class="hljs-string">&quot;新线程Lambda表达式：&quot;</span> + Thread.currentThread().getName());<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>Lambda表达式的优点：简化了匿名内部类的使用，语法更简单。</p>
<p>匿名内部类语法冗余，体验了Lambda表达式后，发现Lambda表达式时简化匿名内部类的一种方式。</p>
<h2 id="Lambda语法规则"><a href="#Lambda语法规则" class="headerlink" title="Lambda语法规则"></a>Lambda语法规则</h2><p>lambda表达式使用场景(前提)：</p>
<ul>
<li>方法的参数或局部变量类型必须为接口才能使用Lambda</li>
<li>⼀个接口中只包含一个方法，则可以使用Lambda表达式，这样的接口称之为“函数接口” （@FunctionalInterface）</li>
</ul>
<p>语法： (params) -&gt; expression</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">第一部分 括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数<br>第二部分 一个箭头符号：-&gt;<br>第三部分 方法体，可以是表达式和代码块<br><br>参数列表 ：<br> 括号中参数列表的参数类型可以省略不写<br> 括号中的参数只有⼀个，那么参数类型和()都可以省略不写<br> <br>方法体：<br> 如果&#123;&#125;中的代码只有一行，无论是否有返回值，可以省略&#123;&#125;和<span class="hljs-keyword">return</span>及语句分号<br></code></pre></td></tr></table></figure>
<h3 id="Lambda练习1"><a href="#Lambda练习1" class="headerlink" title="Lambda练习1"></a>Lambda练习1</h3><p><strong>无参、无返回值的Lambda</strong></p>
<p>定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建主方法使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//匿名内部类</span><br>        goShow(<span class="hljs-keyword">new</span> UserService() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类 show方法执行了&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        <br>        <span class="hljs-comment">//Lambda表达式</span><br>        goShow(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Lambda show方法执行了&quot;</span>);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goShow</span><span class="hljs-params">(UserService userService)</span> </span>&#123;<br>        userService.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">匿名内部类 show方法执行了</span><br><span class="hljs-section">----------</span><br>Lambda show方法执行了<br></code></pre></td></tr></table></figure>
<h3 id="Lambda练习2"><a href="#Lambda练习2" class="headerlink" title="Lambda练习2"></a>Lambda练习2</h3><p><strong>有参、有返回值的Lambda</strong></p>
<p>创建一个Person对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Integer height;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们在List集合中保存多个Person对象，然后对这些对象做根据age排序操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">165</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">170</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">175</span>));<br><br>        <span class="hljs-comment">//匿名内部类</span><br>        <span class="hljs-comment">/*Collections.sort(list, new Comparator&lt;Person&gt;() &#123;</span><br><span class="hljs-comment">            @Override</span><br><span class="hljs-comment">            public int compare(Person o1, Person o2) &#123;</span><br><span class="hljs-comment">                return o1.getAge() - o2.getAge();</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;);</span><br><span class="hljs-comment">        for (Person person : list) &#123;</span><br><span class="hljs-comment">            System.out.println(person);</span><br><span class="hljs-comment">        &#125;*/</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        <br>        <span class="hljs-comment">//Lambda表达式</span><br>        Collections.sort(list, (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span> (Person person : list) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Person(<span class="hljs-attribute">name</span>=张三, <span class="hljs-attribute">age</span>=18, <span class="hljs-attribute">height</span>=165)<br>Person(<span class="hljs-attribute">name</span>=王五, <span class="hljs-attribute">age</span>=20, <span class="hljs-attribute">height</span>=175)<br>Person(<span class="hljs-attribute">name</span>=李四, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">height</span>=170)<br></code></pre></td></tr></table></figure>
<h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@FunctionalInterface</span> 这是一个标志注解，被该注解修饰的接口只能声明一个抽象方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Lambda表达式的原理"><a href="#Lambda表达式的原理" class="headerlink" title="Lambda表达式的原理"></a>Lambda表达式的原理</h2><p>匿名内部类的本质是在编译时生成一个Class文件，XXX$1.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Lambda</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//开启一个新的线程</span><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;新线程中执行的代码：&quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;).start();<br>        System.out.println(<span class="hljs-string">&quot;主线程中的代码：&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-comment">/*new Thread(() -&gt; &#123;</span><br><span class="hljs-comment">            System.out.println(&quot;新线程Lambda表达式：&quot; + Thread.currentThread().getName());</span><br><span class="hljs-comment">        &#125;).start();*/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="JDK8新特性笔记/image-1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>还可以通过 javap 反编译来查看生成的代码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">javap -c -<span class="hljs-selector-tag">p</span> 文件名<span class="hljs-selector-class">.class</span><br>-c:表示对代码进行反汇编<br>-<span class="hljs-selector-tag">p</span>:显示所有的类和成员<br></code></pre></td></tr></table></figure>
<p>反汇编的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">PS C:\IDEA\IdeaProjects\JDK8Test\target\classes\pers\lp\lambda&gt; javap -c -p Demo02Lambda.class<br>Compiled from <span class="hljs-string">&quot;Demo02Lambda.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pers</span>.<span class="hljs-title">lp</span>.<span class="hljs-title">lambda</span>.<span class="hljs-title">Demo02Lambda</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> pers.lp.lambda.Demo02Lambda();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokedynamic #<span class="hljs-number">2</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:show:()Lpers/lp/lambda/service/UserService;</span><br>       <span class="hljs-number">5</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method goShow:(Lpers/lp/lambda/service/UserService;)V</span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goShow</span><span class="hljs-params">(pers.lp.lambda.service.UserService)</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokeinterface #<span class="hljs-number">4</span>,  <span class="hljs-number">1</span>            <span class="hljs-comment">// InterfaceMethod pers/lp/lambda/service/UserService.show:()V</span><br>       <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>    Code:<br>       <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String Lambda show方法又执行了</span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在反编译的源码中我们看到了一个静态方法 <code>lambda$main$0()</code> 这个方法里面做了什么事情呢？我们通过debug的方式来查看下：</p>
<p><img src="JDK8新特性笔记/image-2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>可以发现方法体中的代码实在 lambda$main$0 中执行的。</p>
<p>上面的效果可以理解为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Lambda</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ……<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>()&#123;<br>        System.out.println(<span class="hljs-string">&quot;Lambda show方法又执行了&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了更加直观的理解这个内容，我们可以在运行的时候添加</p>
<p><code>-Djdk.internal.lambda.dumpProxyClasses</code>这个参数会将内部class码输出到一个文件中</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java -Djdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.lambda</span><span class="hljs-selector-class">.dumpProxyClasses</span> 要运行的包名.类名<br></code></pre></td></tr></table></figure>
<p>命令执行</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">E:\workspace\OpenClassWorkSpace\JDK8Demo\target\classes&gt;java -Djdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.lambda</span><span class="hljs-selector-class">.dumpProxyClasses</span> com<span class="hljs-selector-class">.bobo</span><span class="hljs-selector-class">.jdk</span><span class="hljs-selector-class">.lambda</span><span class="hljs-selector-class">.Demo03Lambda</span> Lambda <br></code></pre></td></tr></table></figure>
<p>show 方法执行了…</p>
<p><img src="JDK8新特性笔记/image-3.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>反编译后的内容：</p>
<p><img src="JDK8新特性笔记/image-4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>可以看到这个匿名的内部类实现了UserService接口，并重写了show()方法。在show方法中调用了Demo03Lambda.lambda$main$0(),也就是调用了Lambda中的内容。</p>
<p>上面的效果可以理解为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03Lambda</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		goShow(<span class="hljs-keyword">new</span> UserService() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>				Demo03Lambda.lambda$main$<span class="hljs-number">0</span>();<br>			&#125;<br>		&#125;);<br>		System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>	&#125;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goShow</span><span class="hljs-params">(UserService userService)</span></span>&#123;<br>		userService.show();<br>	&#125;<br>    <br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>		System.out.println(<span class="hljs-string">&quot;Lambda show 方法执行了...&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>小结：</p>
<p>匿名内部类在编译的时候会产生一个class</p>
<p>Lambda表达式在程序运行的时候动态生成class</p>
<ol>
<li>在类中新增了一个方法，这个方法的方法体就是Lambda表达式中的代码</li>
<li>还会形成一个匿名内部类，实现接口，重写抽象方法</li>
<li>在接口中重写方法会调用新生成的方法</li>
</ol>
<h2 id="Lambda和匿名内部类的对比"><a href="#Lambda和匿名内部类的对比" class="headerlink" title="Lambda和匿名内部类的对比"></a>Lambda和匿名内部类的对比</h2><p>Lambda和匿名内部类的对比：</p>
<ol>
<li>所需类型不同：<ul>
<li>Lambda表达式需要的类型必须是<code>接口</code></li>
<li>匿名内部类的类型可以是 <code>类、抽象类、接口</code></li>
</ul>
</li>
<li>抽象方法的数量不同：<ul>
<li>Lambda表达式所需的接口中只能有<code>一个抽象方法</code></li>
<li>匿名内部类所需的接口中的<code>抽象方法的数量是任意的</code></li>
</ul>
</li>
<li>实现原理不同：<ul>
<li>Lambda表达式是在<code>程序运行时动态生成class</code></li>
<li>匿名内部类是在<code>编译后生成一个class</code></li>
</ul>
</li>
</ol>
<h1 id="接口中新增的方法"><a href="#接口中新增的方法" class="headerlink" title="接口中新增的方法"></a>接口中新增的方法</h1><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><p>在JDK8之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>	静态常量;<br>	抽象方法;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>JDK8之后，对接口做了增强，接口中允许有默认方法和静态方法：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">interface 接口名&#123;<br>	静态常量<span class="hljs-comment">;</span><br>	抽象方法<span class="hljs-comment">;</span><br>	默认方法<span class="hljs-comment">;</span><br>	静态方法<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p><strong>为什么要增加默认方法？</strong></p>
<p>在JDK8之前接口中只能有静态变量、抽象方法，会存在以下问题：</p>
<p>如果接口中新增抽象方法，那么实现类都必须要重写这个抽象方法，非常不利于接口的扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Interface</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A a1 = <span class="hljs-keyword">new</span> B();<br>        A a2 = <span class="hljs-keyword">new</span> C();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//在接口中新增抽象方法，所有实现都都必须重写这个抽象方法</span><br>    <span class="hljs-comment">//不利于接口扩展</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>接口中默认方法的语法规则</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>    修饰符 <span class="hljs-keyword">default</span> 返回值类型 方法名&#123;<br>        方法体;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认方法通过实例调用吗，默认方法可以被继承，也可以重写接口中的默认方法。<strong>实例.默认方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Interface</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//实现类直接调用接口中的默认方法</span><br>        A a1 = <span class="hljs-keyword">new</span> B();<br>        a1.test3();<br>        <span class="hljs-comment">//实现类重写接口中的默认方法</span><br>        A a2 = <span class="hljs-keyword">new</span> C();<br>        a2.test3();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//在接口中新增抽象方法，所有实现都都必须重写这个抽象方法</span><br>    <span class="hljs-comment">//不利于接口扩展</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//接口中定义的默认方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接口中的默认方法执行了&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;C 实现类重写了默认方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CCC&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">接口中的默认方法执行了<br><span class="hljs-built_in">C</span> 实现类重写了默认方法<br></code></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>JDK8中为接口新增了静态方法，作用也是为了提高接口的扩展性。</p>
<p><strong>接口中静态方法的语法规则</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>    修饰符 <span class="hljs-keyword">static</span> 返回值类型 方法名&#123;<br>        方法体;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接口中的静态方法在实现类中是不能被重写的，因此调用的方式是：<strong>接口.静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Interface</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A a1 = <span class="hljs-keyword">new</span> B();<br>        a1.test3();<br>        A a2 = <span class="hljs-keyword">new</span> C();<br>        a2.test3();<br>        A.test4();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//在接口中新增抽象方法，所有实现都都必须重写这个抽象方法</span><br>    <span class="hljs-comment">//不利于接口扩展</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//接口中定义的默认方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接口中的默认方法执行了&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//接口中定义的静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接口中的静态方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;world&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;C 实现类重写了默认方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CCC&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">接口中的默认方法执行了<br><span class="hljs-built_in">C</span> 实现类重写了默认方法<br>接口中的静态方法<br></code></pre></td></tr></table></figure>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h2 id="函数式接口的由来"><a href="#函数式接口的由来" class="headerlink" title="函数式接口的由来"></a>函数式接口的由来</h2><p>我们知道使用Lambda表达式的前提是需要有函数式接口，而<strong>Lambda表达式使用时不关心接口名、抽象方法名，只关心抽象方法的参数列表和返回值类型</strong>。因此为了让我们使用Lambda表达式更方便，在JDK中提供了大量常用的函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Fun</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        fun1((arr) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>                sum += i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(Operator operator)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-keyword">int</span> sum = operator.getSum(arr);<br>        System.out.println(<span class="hljs-string">&quot;sum = &quot;</span> + sum);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Operator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="函数式接口介绍"><a href="#函数式接口介绍" class="headerlink" title="函数式接口介绍"></a>函数式接口介绍</h2><p>在JDK中帮我们提供的有函数式接口，主要是在 <code>java.util.function</code> 包中。</p>
<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p><strong>无参、有返回值的接口</strong>。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>来看看Supplier中的<code>get</code>方法的使用：</p>
<p>使用示例：计算出数组中的最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Supplier 函数式接口get的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupplierTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        fun1(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;;<br>            <span class="hljs-comment">//计算出数组中的最大值</span><br>            Arrays.sort(arr);<br>            <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(Supplier&lt;Integer&gt; supplier)</span> </span>&#123;<br>        <span class="hljs-comment">//get()是一个无参、有返回值的抽象方法</span><br>        Integer max = supplier.get();<br>        System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">max</span> = <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p><strong>有参、无返回值的接口</strong>。Consumer接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Performs this operation on the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; after)</span> </span>&#123;<br>        Objects.requireNonNull(after);<br>    	<span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先来看看Consumer中的<code>accept</code>方法的使用：</p>
<p>使用示例：将输入的数据统一转换为小写输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ConsumerTest 函数式接口accept的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str) -&gt; &#123;<br>            System.out.println(str + <span class="hljs-string">&quot;-&gt;转换为小写：&quot;</span> + str.toLowerCase());<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Consumer&lt;String&gt; consumer)</span> </span>&#123;<br>        consumer.accept(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">H<span class="hljs-function"><span class="hljs-title">ello</span> World-&gt;</span>转换为小写：hello world<br></code></pre></td></tr></table></figure>
<p>接着看看Consumer中的默认方法<code>andThen</code>的使用：</p>
<p>如果一个方法的参数和返回值全部是Consumer类型，那么就可以实现消费一个数据的时候，首先做一个操作，然后再做一个操作，实现组合。</p>
<p>使用示例：将输入的数据统一转换为大写输出，然后转换为小写输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ConsumerTest 函数式接口andThen的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerAndThenTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str1) -&gt; &#123;<br>            System.out.println(str1 + <span class="hljs-string">&quot;转换为小写：&quot;</span> + str1.toLowerCase());<br>        &#125;, (str2) -&gt; &#123;<br>            System.out.println(str2 + <span class="hljs-string">&quot;转换为大写：&quot;</span> + str2.toUpperCase());<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Consumer&lt;String&gt; c1, Consumer&lt;String&gt; c2)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>        <span class="hljs-comment">//转换为小写</span><br>		<span class="hljs-comment">//c1.accept(str);</span><br>        <span class="hljs-comment">//转换为大写</span><br>		<span class="hljs-comment">//c2.accept(str);</span><br>        <span class="hljs-comment">//先转小写，然后转大写</span><br>		<span class="hljs-comment">//c1.andThen(c2).accept(str);</span><br>        <span class="hljs-comment">//先转大写，然后转小写</span><br>        c2.andThen(c1).accept(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Hello</span> World转换为大写：HELLO WORLD<br>Hello World转换为小写：hello world<br></code></pre></td></tr></table></figure>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><strong>有参、有返回值的接口</strong>。根据一个类型的数据得到另一个类型的数据，前者为前置条件，后者为后置条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Applies this function to the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the function argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the function result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br>    <br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先来看看Function中的<code>apply</code>方法的使用：</p>
<p>使用示例：传递一个字符串返回一个数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * FunctionTest 函数式接口apply的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(msg -&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.valueOf(msg);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Function&lt;String, Integer&gt; function)</span> </span>&#123;<br>        Integer apply = function.apply(<span class="hljs-string">&quot;666&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;apply = &quot;</span> + apply);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认方法 <code>andThen</code> 也是用来进行组合操作的：</p>
<p>使用示例：传递一个字符串得到一个数值，再从数值得到一个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * FunctionTest 函数式接口andThen的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionAndThenTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((msg1) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.valueOf(msg1);<br>        &#125;, (msg2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> String.valueOf(msg2);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Function&lt;String, Integer&gt; f1, Function&lt;Integer, String&gt; f2)</span> </span>&#123;<br>        String apply = f1.andThen(f2).apply(<span class="hljs-string">&quot;666&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;apply = &quot;</span> + apply);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认方法 <code>compose</code> 的作用顺序与  <code>andThen</code> 方法正好相反。</p>
<p>静态方法 <code>identity</code> 则是，输入什么参数就返回什么参数</p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p><strong>有参、有返回值（boolean）的接口</strong>。对某种类型的数据进行判断，从而得到一个boolean值结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Evaluates this predicate on the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if the input argument matches the predicate,</span><br><span class="hljs-comment">     * otherwise &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先来看看Predicate中的<code>test</code>方法的使用：</p>
<p>使用示例：判断字符串的长度是否超过5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Predicate 函数式接口test的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredicateTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> str.length() &gt; <span class="hljs-number">5</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> b = predicate.test(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串长度超过5了吗？&quot;</span> + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">字符串长度超过<span class="hljs-number">5</span>了吗？<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p>在Predicate中还有 <code>and</code> <code>or</code> <code>negate</code> 默认方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Predicate 函数式接口默认方法 and or negate</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredicateDefaultTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test((str1) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> str1.contains(<span class="hljs-string">&quot;H&quot;</span>);<br>        &#125;, (str2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> str2.contains(<span class="hljs-string">&quot;W&quot;</span>);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2)</span> </span>&#123;<br>        <span class="hljs-comment">//p1包含H 同时 p2包含W</span><br>        <span class="hljs-keyword">boolean</span> b1 = p1.and(p2).test(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.out.println(b1);<br>        <span class="hljs-comment">//p1包含H 或者 p2包含W</span><br>        <span class="hljs-keyword">boolean</span> b2 = p1.or(p2).test(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.out.println(b2);<br>        <span class="hljs-comment">//p1不包含H</span><br>        <span class="hljs-keyword">boolean</span> b3 = p1.negate().test(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.out.println(b3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h2 id="为什么使用方法引用"><a href="#为什么使用方法引用" class="headerlink" title="为什么使用方法引用"></a>为什么使用方法引用</h2><p>在使用Lambda表达式的时候，也会出现代码冗余的情况。</p>
<p>比如：用Lambda表达式求一个数组的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        printElement((arr) -&gt; &#123;<br>            <span class="hljs-comment">//Lambda表达式中的代码和getTotal中的代码冗余了</span><br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>                sum += i;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;数组之和：&quot;</span> + sum);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">//求数组中的所有元素的和</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTotal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数组之和：&quot;</span> + sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printElement</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">int</span>[]&gt; consumer)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;;<br>        consumer.accept(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们发现Lambda表达式中要执行的代码和我们另外一个方法中的代码是一样的，这时就没有必要重写这一份逻辑了， 于是我们可以“引用”重复代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// :: 方法引用</span><br>        printElement(FunctionRefTest02::getTotal);<br>    &#125;<br><br>    <span class="hljs-comment">//求数组中的所有元素的和</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTotal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数组之和：&quot;</span> + sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printElement</span><span class="hljs-params">(Consumer&lt;<span class="hljs-keyword">int</span>[]&gt; consumer)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;;<br>        consumer.accept(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="方法引用语法规则"><a href="#方法引用语法规则" class="headerlink" title="方法引用语法规则"></a>方法引用语法规则</h2><p>符号表示：<code>::</code></p>
<p>符号说明：双冒号是方法引用运算符，而它所在的表达式被称为<code>方法引用</code></p>
<p>应用场景：如果Lambda表达式所要实现的方案，已经有其他方法存在相同的方案，那么则可以使用方法引用。</p>
<p>常见的引用方式：</p>
<ol>
<li><strong>instanceName::methodName 对象::方法名</strong></li>
<li><strong>ClassName::staticMethodName 类名::静态方法</strong></li>
<li><strong>ClassName::methodName 类名::普通方法</strong></li>
<li><strong>ClassName::new    类名::new 调用的构造器</strong></li>
<li><strong>TypeName[]::new    数组类型[]::new 调用数组的构造器</strong></li>
</ol>
<blockquote>
<p>注意事项：</p>
<ol>
<li>被引用的方法，参数要和接口中的抽象方法的参数一样</li>
<li>当接口抽象方法有返回值时，被引用的方法也必须有返回值</li>
</ol>
</blockquote>
<h3 id="对象-方法名"><a href="#对象-方法名" class="headerlink" title="对象::方法名"></a>对象::方法名</h3><p>如果一个类中已经存在了一个成员方法，则可以通过对象名引用成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        Supplier&lt;Long&gt; supplier1 = () -&gt; &#123;<br>            <span class="hljs-keyword">return</span> date.getTime();<br>        &#125;;<br>        System.out.println(supplier1.get());<br>        <span class="hljs-comment">//方法引用</span><br>        Supplier&lt;Long&gt; supplier2 = date::getTime;<br>        System.out.println(supplier2.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="类名-静态方法"><a href="#类名-静态方法" class="headerlink" title="类名::静态方法"></a>类名::静态方法</h3><p>也是比较常用的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest04</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Long&gt; supplier1 = () -&gt; &#123;<br>            <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>        &#125;;<br>        System.out.println(supplier1.get());<br>        <span class="hljs-comment">//方法引用</span><br>        Supplier&lt;Long&gt; supplier2 = System::currentTimeMillis;<br>        System.out.println(supplier2.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="类名-普通方法"><a href="#类名-普通方法" class="headerlink" title="类名::普通方法"></a>类名::普通方法</h3><p> Java面向对象中，类名只能调用静态方法，而在方法引用中却可以类名引用实例方法。</p>
<p>当然使用这种形式也是有前提的，<strong>用第一个参数作为方法的调用者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest05</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;String, Integer&gt; function1 = (s) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> s.length();<br>        &#125;;<br>        System.out.println(function1.apply(<span class="hljs-string">&quot;hello&quot;</span>));<br>        <span class="hljs-comment">//方法引用</span><br>        Function&lt;String, Integer&gt; function2 = String::length;<br>        System.out.println(function2.apply(<span class="hljs-string">&quot;world&quot;</span>));<br><br>        BiFunction&lt;String, Integer, String&gt; biFunction = String::substring;<br>        String str = biFunction.apply(<span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-number">3</span>);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="类名-构造器"><a href="#类名-构造器" class="headerlink" title="类名::构造器"></a>类名::构造器</h3><p> 由于构造器的名称和类名完全一致，所以构造器引用要使用 <code>::new</code> 的格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest06</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Person&gt; supplier1 = () -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();<br>        &#125;;<br>        System.out.println(supplier1.get());<br>        <span class="hljs-comment">//方法引用</span><br>        Supplier&lt;Person&gt; supplier2 = Person::<span class="hljs-keyword">new</span>;<br>        System.out.println(supplier2.get());<br>        BiFunction&lt;String, Integer, Person&gt; function = Person::<span class="hljs-keyword">new</span>;<br>        System.out.println(function.apply(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数组-构造器"><a href="#数组-构造器" class="headerlink" title="数组::构造器"></a>数组::构造器</h3><p>数组是怎么构造出来的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionRefTest07</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;Integer, String[]&gt; function1 = (len) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[len];<br>        &#125;;<br>        String[] a1 = function1.apply(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;数组的长度是：&quot;</span> + a1.length);<br>        <span class="hljs-comment">//方法引用</span><br>        Function&lt;Integer, String[]&gt; function2 = String[]::<span class="hljs-keyword">new</span>;<br>        String[] a2 = function2.apply(<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;数组的长度是：&quot;</span> + a2.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>小结：方法引用是对Lambda表达式在符合特定情况下的一种缩写方式，它使得我们的Lambda表达式更加的精简，也可以理解为lambda表达式的缩写形式，不过要注意的是方法引用只能引用已经存在的方法。</p>
</blockquote>
<h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><h2 id="集合处理数据的弊端"><a href="#集合处理数据的弊端" class="headerlink" title="集合处理数据的弊端"></a>集合处理数据的弊端</h2><p>当我们在需要对集合中的元素进行操作的时候，除了必须的添加、删除、获取外，最典型的操作就是集合遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个List集合</span><br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;成龙&quot;</span>, <span class="hljs-string">&quot;周星驰&quot;</span>);<br>        <span class="hljs-comment">//1、先获取所有姓张的信息</span><br>        List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list) &#123;<br>            <span class="hljs-keyword">if</span> (s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)) &#123;<br>                list1.add(s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//2、再获取名字长度为3的用户</span><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list1) &#123;<br>            <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">3</span>) &#123;<br>                list2.add(s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//3、输出符合前两个条件的用户信息</span><br>        <span class="hljs-keyword">for</span> (String s : list2) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码针对于不同的需求必须一次次的循环，这时我们希望有高效的处理方式，这时我们就可以通过JDK8中提供的Stream API来解决。</p>
<p>Stream更加优雅的解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个List集合</span><br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;成龙&quot;</span>, <span class="hljs-string">&quot;周星驰&quot;</span>);<br>        <span class="hljs-comment">//1、先获取所有姓张的信息</span><br>        <span class="hljs-comment">//2、再获取名字长度为3的用户</span><br>        <span class="hljs-comment">//3、输出符合前两个条件的用户信息</span><br>        list.stream()<br>                .filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>                .filter(s -&gt; s.length() == <span class="hljs-number">3</span>)<br>                .forEach(s -&gt; System.out.println(s));<br>        System.out.println(<span class="hljs-string">&quot;-----方法引用-----&quot;</span>);<br>        list.stream()<br>                .filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>                .filter(s -&gt; s.length() == <span class="hljs-number">3</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的Stream API代码的含义：获取流、过滤张、过滤长度3，逐一打印。代码相比于之前的不断循环更加的简洁直观。</p>
<h2 id="Stream流式思想"><a href="#Stream流式思想" class="headerlink" title="Stream流式思想"></a>Stream流式思想</h2><blockquote>
<p>注意：Stream和IO流(InputStream/OutputStream)没有任何关系，请暂时忘记对传统IO流的固有印 象！</p>
</blockquote>
<p>Stream流式思想类似于工厂车间的“生产流水线”，Stream流不是一种数据结构，不保存数据，而是对数 据进行加工 处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商 品。</p>
<p><img src="JDK8新特性笔记/image-5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>Stream API能让我们快速完成许多复杂的操作，如筛选、切片、映射、查找、去除重复，统计，匹配和 归约。</p>
<h2 id="Stream流的获取方式"><a href="#Stream流的获取方式" class="headerlink" title="Stream流的获取方式"></a>Stream流的获取方式</h2><p>获取一个Stream流非常简单，常见的有两种获取方式：</p>
<ol>
<li>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取；</li>
<li><code>Stream</code>接口的静态方法<code>of</code>可以获取对应的流；</li>
</ol>
<h3 id="根据Collection集合中的stream方法获取"><a href="#根据Collection集合中的stream方法获取" class="headerlink" title="根据Collection集合中的stream方法获取"></a>根据Collection集合中的stream方法获取</h3><p>首先 <code>java.util.Collection</code> 接口中加入了default方法 stream，也就是说Collection接口下的所有的实现都可以通过steam方法来获取Stream流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; lits = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        lits.stream();<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        set.stream();<br>        Vector vector = <span class="hljs-keyword">new</span> Vector();<br>        vector.stream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是Map接口没有实现Collection接口，这时我们可以根据Map获取对应的key-value的集合再来获取Stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest04</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//key</span><br>        Stream&lt;String&gt; stream1 = map.keySet().stream();<br>        <span class="hljs-comment">//value</span><br>        Stream&lt;Object&gt; stream2 = map.values().stream();<br>        <span class="hljs-comment">//entry</span><br>        Stream&lt;Map.Entry&lt;String, Object&gt;&gt; stream3 = map.entrySet().stream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="根据Stream接口中的静态方法of方法获取"><a href="#根据Stream接口中的静态方法of方法获取" class="headerlink" title="根据Stream接口中的静态方法of方法获取"></a>根据Stream接口中的静态方法of方法获取</h3><p>由于数组对象不可能添加默认方法，所以<code>Stream</code>接口中提供了静态方法<code>of</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest05</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过Stream的of方法获取</span><br>        Stream&lt;String&gt; a = Stream.of(<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-string">&quot;a3&quot;</span>);<br>        a.forEach(System.out::println);<br><br>        String[] arr1 = &#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>&#125;;<br>        Stream&lt;String&gt; arr11 = Stream.of(arr1);<br>        arr11.forEach(System.out::println);<br><br>        Integer[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        Stream&lt;Integer&gt; arr22 = Stream.of(arr2);<br>        arr22.forEach(System.out::println);<br><br>        <span class="hljs-comment">//注意：基本数据类型的数组是不行的</span><br>        <span class="hljs-keyword">int</span>[] arr3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        Stream&lt;<span class="hljs-keyword">int</span>[]&gt; arr33 = Stream.of(arr3);<br>        arr33.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">a1</span><br><span class="hljs-built_in">a2</span><br><span class="hljs-built_in">a3</span><br>aa<br><span class="hljs-keyword">bb</span><br><span class="hljs-keyword"></span>cc<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>[I@<span class="hljs-number">36</span>d64342<br><br>进程已结束,退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h2 id="Stream流常用方法介绍"><a href="#Stream流常用方法介绍" class="headerlink" title="Stream流常用方法介绍"></a>Stream流常用方法介绍</h2><p>Stream流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法作用</th>
<th>返回值类型</th>
<th>方法种类</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计个数</td>
<td>long</td>
<td>终结</td>
</tr>
<tr>
<td>forEach</td>
<td>逐一处理</td>
<td>void</td>
<td>终结</td>
</tr>
<tr>
<td>filter</td>
<td>过滤</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td>limit</td>
<td>取用前几个</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td>skip</td>
<td>跳过前几个</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td>map</td>
<td>映射</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td>concat</td>
<td>组合</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
</tbody>
</table>
</div>
<p><strong>终结方法</strong>：返回值类型不再是 Stream 类型的方法，不再支持链式调用。终结方法包括 <code>count</code> 和 <code>forEach</code> 方法。</p>
<p><strong>非终结方法</strong>：返回值类型仍然是 Stream 类型的方法，支持链式调用。（除了终结方法外，其余方法均为非终结方法。）</p>
<p><strong>Stream注意事项(重要)</strong> </p>
<ol>
<li>Stream只能操作一次</li>
<li>Stream方法返回的是新的流</li>
<li>Stream不调用终结方法，中间的操作不会执行</li>
</ol>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>Stream流中的count方法用来统计其中的元素个数的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>该方法返回一个long值，代表元素的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamCount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> count = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>).count();<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream流中的forEach方法用来遍历流中的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该方法接受一个Consumer接口，会将每一个流元素交给函数处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamforEach</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>c<br></code></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Stream流中的filter方法用于过滤数据，返回符合条件的数据。</p>
<p><img src="JDK8新特性笔记/image-6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>可以通过filter方法将一个流转换成另一个子集流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该接口接收一个Predicate函数式接口参数作为筛选条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamFilter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)<br>                .filter(s -&gt; s.contains(<span class="hljs-string">&quot;b&quot;</span>))<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">b</span><br><span class="hljs-symbol">bb</span><br></code></pre></td></tr></table></figure>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>Stream流中的limit方法可以对流进行截取处理，获取前n个数据。</p>
<p><img src="JDK8新特性笔记/image-7.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br></code></pre></td></tr></table></figure>
<p>参数是一个long类型的数值，如果集合当前长度大于参数就进行截取，否则不操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamLimit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)<br>                .limit(<span class="hljs-number">3</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>c<br></code></pre></td></tr></table></figure>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>Stream流中的skip方法用于跳过前面几个元素，获取后面的元素</p>
<p><img src="JDK8新特性笔记/image-8.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure>
<p>操作实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamSkip</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)<br>                .skip(<span class="hljs-number">3</span>)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">aa<br>bb<br>cc<br></code></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Stream流中的map方法用于将流中的元素映射到另一个流中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">Stream&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends R&gt; mapper)</span></span>;<br></code></pre></td></tr></table></figure>
<p><img src="JDK8新特性笔记/image-9.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMap</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>)<br>                <span class="hljs-comment">//.map(s -&gt; Integer.valueOf(s))</span><br>                .map(Integer::valueOf)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td></tr></table></figure>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>Stream流中的sorted方法用于将数据排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure>
<p>在使用的时候可以根据自然规则排序，也可以根据比较器指定的规则来排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamSorted</span> </span>&#123;<br>    <span class="hljs-comment">// sorted(): 根据元素的自然顺序排序</span><br>    <span class="hljs-comment">// sorted(Comparator&lt;? super T&gt; comparator): 根据比较器指定的规则排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>                <span class="hljs-comment">//.sorted()</span><br>                .sorted((o1, o2) -&gt; o2 - o1)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>4<br>3<br>2<br>1<br></code></pre></td></tr></table></figure>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>Stream流中的distinct方法用于去掉重复数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">distinct</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p><img src="JDK8新特性笔记/image-10.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDistinct</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>).distinct().forEach(System.out::println);<br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        Stream.of(<br>                <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>),<br>                <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>),<br>                <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>))<br>                .distinct()<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1<br>5<br>8<br>4<br>7<br>3<br>----------<br>执行有参构造：张三,18<br>执行有参构造：李四,19<br>执行有参构造：张三,20<br>Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-attribute">age</span>=19&#125;<br>Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attribute">age</span>=20&#125;<br></code></pre></td></tr></table></figure>
<p>Stream流中的distinct方法对于基本数据类型是可以直接出重的，但是对于自定义类型，我们是必须重写hashCode和equals方法来移除重复元素。</p>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>Stream流中的match方法用于判断数据是否匹配指定的条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 元素是否有任意一个满足条件</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">anyMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br><span class="hljs-comment">// 元素是否都满足条件</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>; <br><span class="hljs-comment">// 元素是否都不满足条件</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">noneMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>; <br></code></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMatch</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> b = Stream.of(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>                <span class="hljs-comment">//.anyMatch(e -&gt; e &gt; 4);</span><br>                <span class="hljs-comment">//.allMatch(e -&gt; e &gt; 4);</span><br>                .noneMatch(e -&gt; e &lt; <span class="hljs-number">0</span>);<br>        System.out.println(b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>Stream流中的find方法用于找到某些数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">findFirst</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">findAny</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p><img src="JDK8新特性笔记/image-11.png" srcset="/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>注意：</p>
<p>findFirst总能保证找到第一个元素，</p>
<p>findAny在并行操作中，可能会返回Stream中的第一个元素，但不能保证</p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamFind</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Optional&lt;Integer&gt; first = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).findFirst();<br>        System.out.println(<span class="hljs-string">&quot;first = &quot;</span> + first.get());<br><br>        Optional&lt;Integer&gt; any = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).findAny();<br>        System.out.println(<span class="hljs-string">&quot;any = &quot;</span> + any.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="max、min"><a href="#max、min" class="headerlink" title="max、min"></a>max、min</h3><p>Stream流中的max、min方法用于获取最大值和最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">max</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">min</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMaxMin</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Optional&lt;Integer&gt; max = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).max((o1, o2) -&gt; o1 - o2);<br>        System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + max);<br>        Optional&lt;Integer&gt; min = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>).min((o1, o2) -&gt; o1 - o2);<br>        System.out.println(<span class="hljs-string">&quot;min = &quot;</span> + min);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>Stream流中的reduce方法用于将所有数据归纳得到一个数据</p>
<p><img src="JDK8新特性笔记/image-13.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamReduce</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer reduce1 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>                .reduce(<span class="hljs-number">0</span>, (x, y) -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;x = &quot;</span> + x + <span class="hljs-string">&quot;, y = &quot;</span> + y);<br>                    <span class="hljs-keyword">return</span> x + y;<br>                &#125;);<br>        <span class="hljs-comment">// reduce:</span><br>        <span class="hljs-comment">// 第一次将默认做赋值给x, 取出第一个元素赋值给y,进行操作</span><br>        <span class="hljs-comment">// 第二次,将第一次的结果赋值给x, 取出二个元素赋值给y,进行操作</span><br>        <span class="hljs-comment">// 第三次,将第二次的结果赋值给x, 取出三个元素赋值给y,进行操作</span><br>        <span class="hljs-comment">// 第四次,将第三次的结果赋值给x, 取出四个元素赋值给y,进行操作</span><br>        System.out.println(<span class="hljs-string">&quot;reduce1 = &quot;</span> + reduce1);<br><br>        <span class="hljs-keyword">int</span> reduce2 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(<span class="hljs-string">&quot;reduce3 = &quot;</span> + reduce2);<br><br>        <span class="hljs-comment">//获取最大值</span><br>        <span class="hljs-keyword">int</span> max = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::max);<br>        System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = <span class="hljs-number">0</span>, y = <span class="hljs-number">1</span><br><span class="hljs-attr">x</span> = <span class="hljs-number">1</span>, y = <span class="hljs-number">3</span><br><span class="hljs-attr">x</span> = <span class="hljs-number">4</span>, y = <span class="hljs-number">1</span><br><span class="hljs-attr">x</span> = <span class="hljs-number">5</span>, y = <span class="hljs-number">4</span><br><span class="hljs-attr">reduce1</span> = <span class="hljs-number">9</span><br><span class="hljs-attr">reduce3</span> = <span class="hljs-number">9</span><br><span class="hljs-attr">max</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<h3 id="map、reduce组合使用"><a href="#map、reduce组合使用" class="headerlink" title="map、reduce组合使用"></a>map、reduce组合使用</h3><p>在实际开发中我们经常会将map和reduce一块来使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMapReduce</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1、求出所有年龄的总和</span><br>        Integer sumAge = Stream.of(<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">21</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>)<br>                        <span class="hljs-comment">//实现数据类型的转换</span><br>                ).map(Person::getAge)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(<span class="hljs-string">&quot;sumAge = &quot;</span> + sumAge);<br><br>        <span class="hljs-comment">//2、求出所有年龄中的最大值</span><br>        Integer maxAge = Stream.of(<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">21</span>),<br>                        <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>)<br>                        <span class="hljs-comment">//实现数据类型的转换,符合reduce对数据的要求</span><br>                ).map(Person::getAge)<br>                <span class="hljs-comment">//reduce实现数据的处理</span><br>                .reduce(<span class="hljs-number">0</span>, Math::max);<br>        System.out.println(<span class="hljs-string">&quot;maxAge = &quot;</span> + maxAge);<br><br>        <span class="hljs-comment">//3、统计字符a的出现次数</span><br>        Integer count = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br>                .map(ch -&gt; <span class="hljs-string">&quot;a&quot;</span>.equals(ch) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">sumAge</span> = <span class="hljs-number">100</span><br><span class="hljs-attr">maxAge</span> = <span class="hljs-number">22</span><br><span class="hljs-attr">count</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<h3 id="mapToInt"><a href="#mapToInt" class="headerlink" title="mapToInt"></a>mapToInt</h3><p>Stream流中的mapToInt方法用于将Stream中的Integer类型转换成int类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">IntStream <span class="hljs-title">mapToInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-keyword">super</span> T&gt; mapper)</span></span>;<br></code></pre></td></tr></table></figure>
<p><img src="JDK8新特性笔记/image-14.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMapToInt</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//Integer占用的内存比int多很多，在Stream流操作中会自动装箱和拆箱</span><br>        Stream&lt;Integer&gt; stream = Arrays.stream(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;);<br><br>        <span class="hljs-comment">//不必要的拆箱</span><br>        <span class="hljs-comment">/*Integer result1 = stream</span><br><span class="hljs-comment">                .filter(i -&gt; i.intValue() &gt; 3)</span><br><span class="hljs-comment">                .reduce(0, Integer::sum);</span><br><span class="hljs-comment">        System.out.println(result1);*/</span><br><br>        <span class="hljs-comment">//自动拆箱</span><br>        <span class="hljs-comment">/*Integer result2 = stream</span><br><span class="hljs-comment">                .filter(i -&gt; i &gt; 3)</span><br><span class="hljs-comment">                .reduce(0, Integer::sum);</span><br><span class="hljs-comment">        System.out.println(result2);*/</span><br><br>        <span class="hljs-comment">//可以先将流中Integer数据转换为int数据，后续直接操作int类型</span><br>        IntStream intStream1 = stream.mapToInt(Integer::intValue);<br>        <span class="hljs-keyword">int</span> result3 = intStream1<br>                .filter(i -&gt; i &gt; <span class="hljs-number">3</span>)<br>                .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        System.out.println(result3);<br><br>        <span class="hljs-comment">//将IntStream转化为Stream&lt;Integer&gt;</span><br>        <span class="hljs-comment">//IntStream rangeClosed(int startInclusive，int endInclusive)</span><br>        <span class="hljs-comment">//以增量步长1返回一个从startInclusive(包括)到endInclusive(包括)的IntStream</span><br>        IntStream intStream2 = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        Stream&lt;Integer&gt; boxed = intStream2.boxed();<br>        boxed.forEach(s -&gt; System.out.println(s.getClass() + <span class="hljs-string">&quot;,&quot;</span> + s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">15</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">3</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Integer</span>,<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>Stream流中的concat方法用于将两个流合并成为一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">concat</span><span class="hljs-params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span> </span>&#123;<br>    Objects.requireNonNull(a);<br>    Objects.requireNonNull(b);<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    Spliterator&lt;T&gt; split = <span class="hljs-keyword">new</span> Streams.ConcatSpliterator.OfRef&lt;&gt;(<br>            (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());<br>    Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());<br>    <span class="hljs-keyword">return</span> stream.onClose(Streams.composedClose(a, b));<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamConcat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>        Stream&lt;String&gt; stream2 = Stream.of(<span class="hljs-string">&quot;李四&quot;</span>);<br>        Stream.concat(stream1, stream2).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">张三<br>李四<br></code></pre></td></tr></table></figure>
<h3 id="Stream综合案例"><a href="#Stream综合案例" class="headerlink" title="Stream综合案例"></a>Stream综合案例</h3><p>现在有两个<code>ArrayList</code>集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行下列若干操作：</p>
<ol>
<li>第一个队伍只要名字为3个字的成员姓名；</li>
<li>第一个队伍筛选之后只要前3个人；</li>
<li>第二个队伍只要姓张的成员姓名；</li>
<li>第二个队伍筛选之后不要前2个人；</li>
<li>将两个队伍合并为一个队伍；</li>
<li>根据姓名创建<code>Person</code>对象；</li>
<li>打印整个队伍的<code>Person</code>对象信息。</li>
</ol>
<p>两个队伍（集合）的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamCase</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list1 = Arrays.asList(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>,<br>                <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>, <span class="hljs-string">&quot;洪七 公&quot;</span>);<br>        List&lt;String&gt; list2 = Arrays.asList(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;赵丽颖&quot;</span>,<br>                <span class="hljs-string">&quot;张二狗&quot;</span>, <span class="hljs-string">&quot;张天爱&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Person</code>类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Stream实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamCase</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list1 = Arrays.asList(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>,<br>                <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>, <span class="hljs-string">&quot;洪七 公&quot;</span>);<br>        List&lt;String&gt; list2 = Arrays.asList(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;赵丽颖&quot;</span>,<br>                <span class="hljs-string">&quot;张二狗&quot;</span>, <span class="hljs-string">&quot;张天爱&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        <span class="hljs-comment">// 1. 第一个队伍只保留姓名长度为3的成员</span><br>        <span class="hljs-comment">// 2. 第一个队伍筛选之后只要前3个人</span><br>        Stream&lt;String&gt; stream1 = list1.stream().filter(s -&gt; s.length() == <span class="hljs-number">3</span>).limit(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 3. 第二个队伍只要姓张的成员</span><br>        <span class="hljs-comment">// 4. 第二个队伍筛选之后不要前两个人</span><br>        Stream&lt;String&gt; stream2 = list2.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).skip(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 5. 将两个队伍合并为一个队伍</span><br>        <span class="hljs-comment">// 6. 根据姓名创建Person对象</span><br>        <span class="hljs-comment">// 7. 打印整个队伍的Person信息</span><br>        Stream.concat(stream1, stream2).map(Person::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;宋远桥&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;苏星河&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张二狗&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张天爱&#x27;</span>&#125;<br>Person&#123;<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Stream流结果收集"><a href="#Stream流结果收集" class="headerlink" title="Stream流结果收集"></a>Stream流结果收集</h2><p>对流操作完成之后，如果需要将流的结果保存到集合或数组中，可以收集流中的数据。</p>
<h3 id="结果收集到集合"><a href="#结果收集到集合" class="headerlink" title="结果收集到集合"></a>结果收集到集合</h3><p>Stream流提供 <code>collect</code> 方法，其参数需要一个 <code>java.util.stream.Collector</code> 接口对象来指定收集到哪种集合中。而在<code>java.util.stream.Collectors</code> 类提供了一些方法，可以作为 Collector`接口的实例：</p>
<ul>
<li><code>public static Collector&gt; toList()</code> ：转换为 List 集合</li>
<li><code>public static Collector&gt; toSet()</code> ：转换为 Set 集合</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToCollection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>);<br>        <span class="hljs-comment">//收集到List中</span><br>        List&lt;String&gt; list = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toList());<br>        System.out.println(list);<br>        <span class="hljs-comment">//收集到Set中</span><br>        Set&lt;String&gt; set = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toSet());<br>        System.out.println(set);<br><br>        <span class="hljs-comment">//如果需要获取的类型为具体的实现，比如：ArrayList、HashSet</span><br>        ArrayList&lt;String&gt; arrayList = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword">new</span>));<br>        System.out.println(arrayList);<br>        HashSet&lt;String&gt; hashSet = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).collect(Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>));<br>        System.out.println(hashSet);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[aa, bb, cc, aa]<br>[aa, bb, cc]<br>[aa, bb, cc, aa]<br>[aa, bb, cc]<br></code></pre></td></tr></table></figure>
<h3 id="结果收集到数组"><a href="#结果收集到数组" class="headerlink" title="结果收集到数组"></a>结果收集到数组</h3><p>Stream中提供了<code>toArray</code>方法来将结果放到一个数组中，返回值类型是<code>Object[]</code>,如果我们要指定返回的类型，那么可以使用另一个重载的<code>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToArray</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//返回的数组中的元素是 Object类型</span><br>        Object[] objects = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).toArray();<br>        System.out.println(objects.getClass());<br>        <span class="hljs-comment">//如果需要指定返回的数组中的元素类型</span><br>        String[] strings = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>).toArray(String[]::<span class="hljs-keyword">new</span>);<br>        System.out.println(strings.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> [Ljava.lang.<span class="hljs-keyword">Object</span>;<br><span class="hljs-keyword">class</span> [Ljava.lang.<span class="hljs-keyword">String</span>;<br></code></pre></td></tr></table></figure>
<h3 id="对流中的数据进行聚合计算"><a href="#对流中的数据进行聚合计算" class="headerlink" title="对流中的数据进行聚合计算"></a>对流中的数据进行聚合计算</h3><p>当我们使用Stream流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作。比如获取最大值，获取最小 值，求总和，平均值，统计数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToAggregate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">77</span>));<br>        <span class="hljs-comment">//获取最大值</span><br>        Optional&lt;Student&gt; max = studentStream.collect(Collectors.maxBy((o1, o2) -&gt; o1.getScore() - o2.getScore()));<br>        System.out.println(max);<br>        <span class="hljs-comment">//获取最小值</span><br>        Optional&lt;Student&gt; min = studentStream.collect(Collectors.minBy((o1, o2) -&gt; o1.getScore() - o2.getScore()));<br>        System.out.println(min);<br>        <span class="hljs-comment">//求年龄总和</span><br>        Integer sumAge = studentStream.collect(Collectors.summingInt(Student::getAge));<br>        System.out.println(sumAge);<br>        <span class="hljs-comment">//求分数平均值</span><br>        Double avgScore = studentStream.collect(Collectors.averagingInt(Student::getScore));<br>        System.out.println(avgScore);<br>        <span class="hljs-comment">//统计学生数量</span><br>        Long count = studentStream.collect(Collectors.counting());<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：Stream流只能使用一次！如果多次使用则会出现stream has already been operated upon or closed异常</p>
</blockquote>
<h3 id="对流中的数据进行分组"><a href="#对流中的数据进行分组" class="headerlink" title="对流中的数据进行分组"></a>对流中的数据进行分组</h3><p>使用示例：根据分数来进行分组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToGroup</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">55</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">33</span>));<br>		<span class="hljs-comment">//Map&lt;Integer, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.groupingBy(Student::getAge));</span><br><br>        <span class="hljs-comment">//将分数大于60的分为一组，小于60的分为另一组</span><br>        studentStream.collect(Collectors.groupingBy(s -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (s.getScore() &gt; <span class="hljs-number">60</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;及格&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不及格&quot;</span>;<br>            &#125;<br>        &#125;)).forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">&quot;::&quot;</span> + v);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">不及格::[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;迪丽热巴&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=55&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-attribute">age</span>=52, <span class="hljs-attribute">score</span>=33&#125;]<br>及格::[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;赵丽颖&#x27;</span>, <span class="hljs-attribute">age</span>=58, <span class="hljs-attribute">score</span>=95&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;杨颖&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=88&#125;]<br></code></pre></td></tr></table></figure>
<h3 id="对流中的数据进行多级分组"><a href="#对流中的数据进行多级分组" class="headerlink" title="对流中的数据进行多级分组"></a>对流中的数据进行多级分组</h3><p>使用示例：先根据age分组，然后再根据score分组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToMultiGroup</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">55</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">33</span>));<br>        <span class="hljs-comment">//Map&lt;Integer, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.groupingBy(Student::getAge));</span><br><br>        <span class="hljs-comment">//先根据age分组，然后再根据score分组</span><br>        Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; map = studentStream.collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(s -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (s.getScore() &gt;= <span class="hljs-number">90</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;优秀&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.getScore() &gt;= <span class="hljs-number">80</span> &amp;&amp; s.getScore() &lt; <span class="hljs-number">90</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;良好&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.getScore() &gt;= <span class="hljs-number">60</span> &amp;&amp; s.getScore() &lt; <span class="hljs-number">80</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;及格&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不及格&quot;</span>;<br>            &#125;<br>        &#125;)));<br>        map.forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">&quot;==&quot;</span> + v);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">52</span>==&#123;不及格=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-attribute">age</span>=52, <span class="hljs-attribute">score</span>=33&#125;]&#125;<br><span class="hljs-attribute">56</span>==&#123;不及格=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;迪丽热巴&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=55&#125;], 良好=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;杨颖&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=88&#125;]&#125;<br><span class="hljs-attribute">58</span>==&#123;优秀=[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;赵丽颖&#x27;</span>, <span class="hljs-attribute">age</span>=58, <span class="hljs-attribute">score</span>=95&#125;]&#125;<br></code></pre></td></tr></table></figure>
<h3 id="对流中的数据进行分区"><a href="#对流中的数据进行分区" class="headerlink" title="对流中的数据进行分区"></a>对流中的数据进行分区</h3><p><code>Collectors.partitioningBy</code> 会根据Boolean值，把集合分割为两个列表，一个true列表，一个false列表。</p>
<p><img src="JDK8新特性笔记/image-15.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToPartition</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">77</span>));<br>        Map&lt;Boolean, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.partitioningBy(s -&gt; s.getScore() &gt; <span class="hljs-number">90</span>));<br>        map.forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">&quot;==&quot;</span> + v);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">false</span>==[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;杨颖&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=88&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-attribute">age</span>=52, <span class="hljs-attribute">score</span>=77&#125;]<br><span class="hljs-attribute">true</span>==[Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;赵丽颖&#x27;</span>, <span class="hljs-attribute">age</span>=58, <span class="hljs-attribute">score</span>=95&#125;, Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;迪丽热巴&#x27;</span>, <span class="hljs-attribute">age</span>=56, <span class="hljs-attribute">score</span>=99&#125;]<br></code></pre></td></tr></table></figure>
<h3 id="对流中的数据进行拼接"><a href="#对流中的数据进行拼接" class="headerlink" title="对流中的数据进行拼接"></a>对流中的数据进行拼接</h3><p><code>Collectors.joining</code> 会根据指定的连接符，将所有元素连接成一个字符串。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamToJoining</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Student&gt; studentStream = Stream.of(<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>),<br>                <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">77</span>));<br>        String collect = studentStream<br>                .map(Student::getName)<br>                .collect(Collectors.joining(<span class="hljs-string">&quot;&gt;_&lt;&quot;</span>, <span class="hljs-string">&quot;^_^&quot;</span>, <span class="hljs-string">&quot;^v^&quot;</span>));<br>        System.out.println(collect);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">^<span class="hljs-literal">_</span>^赵丽颖&gt;<span class="hljs-literal">_</span>&lt;杨颖&gt;<span class="hljs-literal">_</span>&lt;迪丽热巴&gt;<span class="hljs-literal">_</span>&lt;柳岩^v^<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>小结</strong></p>
<p>收集Stream流中的结果：</p>
<p>到集合中: Collectors.toList()/Collectors.toSet()/Collectors.toCollection() </p>
<p>到数组中: toArray()/toArray(类型[]::new) </p>
<p>聚合计算: Collectors.maxBy/Collectors.minBy/Collectors.counting/Collectors.summingInt/Collectors.averagingInt </p>
<p>分组: Collectors.groupingBy </p>
<p>分区: Collectors.partitionBy </p>
<p>拼接: Collectors.joinging</p>
</blockquote>
<h1 id="并行的Stream流"><a href="#并行的Stream流" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h1><p><strong>目标</strong></p>
<ul>
<li><p>了解串行的Stream流</p>
</li>
<li><p>掌握获取并行Stream流的两种方式</p>
</li>
</ul>
<h2 id="串行的Stream流"><a href="#串行的Stream流" class="headerlink" title="串行的Stream流"></a>串行的Stream流</h2><p>目前我们使用的Stream流是串行的，就是在一个线程上执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamSerial</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> count = Stream.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>)<br>                .filter(s -&gt; &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;,s = &quot;</span> + s);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;)<br>                .count();<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">4</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">5</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">3</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">9</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main],s = <span class="hljs-number">6</span><br><span class="hljs-attribute">count</span> = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
<h2 id="并行的Stream流-1"><a href="#并行的Stream流-1" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h2><p><code>parallelStream</code>其实就是一个并行执行的流。它通过默认的<code>ForkJoinPool</code>，可以提高多线程任务的速度。</p>
<h3 id="获取并行流"><a href="#获取并行流" class="headerlink" title="获取并行流"></a>获取并行流</h3><p><strong>获取并行Stream流的两种方式：</strong></p>
<ul>
<li>直接获取并行的流</li>
<li>将串行流转成并行流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取并行流的两种方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelGet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//直接获取并行流</span><br>        Stream&lt;Integer&gt; parallelStream1 = list.parallelStream();<br>        <span class="hljs-comment">//将已有的串行流转成并行流</span><br>        Stream&lt;Integer&gt; parallelStream2 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).parallel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="操作并行流"><a href="#操作并行流" class="headerlink" title="操作并行流"></a>操作并行流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作并行流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelOperate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> count = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>                .parallel()<br>                .filter(s -&gt; &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;, s = &quot;</span> + s);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;)<br>                .count();<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">11</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">3</span><br><span class="hljs-attribute">Thread</span>[main,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">4</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">6</span><br><span class="hljs-attribute">Thread</span>[ForkJoinPool.commonPool-worker-<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,main], s = <span class="hljs-number">5</span><br><span class="hljs-attribute">count</span> = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>小结</strong></p>
<p>获取并行流有两种方式:</p>
<p>直接获取并行流: parallelStream()</p>
<p>将串行流转成并行流: parallel()</p>
</blockquote>
<h2 id="并行流和串行流对比"><a href="#并行流和串行流对比" class="headerlink" title="并行流和串行流对比"></a>并行流和串行流对比</h2><p>我们通过for循环、串行Stream流、并行Stream流来对5亿个数字求和。来看消耗时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelCompare</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> times = <span class="hljs-number">500000000L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        start = System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;消耗时间：&quot;</span> + (end - start));<br>    &#125;<br><br>    <span class="hljs-comment">//普通for循环 消耗时间：306</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFor</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通for循环：&quot;</span>);<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; times; i++) &#123;<br>            res += i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//串行流处理 消耗时间：696</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSerial</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;串行流：&quot;</span>);<br>        LongStream<br>                .rangeClosed(<span class="hljs-number">0</span>, times)<br>                .reduce(<span class="hljs-number">0</span>, Long::sum);<br>    &#125;<br><br>    <span class="hljs-comment">//并行流处理 消耗时间：75</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParallel</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;并行流：&quot;</span>);<br>        LongStream<br>                .rangeClosed(<span class="hljs-number">0</span>, times)<br>                .parallel()<br>                .reduce(<span class="hljs-number">0</span>, Long::sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过案例我们可以看到并行流的效率是最高的。</p>
<p>Stream并行处理的过程会分而治之，也就是将一个大的任务切分成了多个小任务，这表示每个任务都是 一个线程操作。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>在多线程的处理下，肯定会出现数据安全问题。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; listOld = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            listOld.add(i);<br>        &#125;<br>        System.out.println(listOld.size());<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//使用并行流来向集合中添加数据</span><br>        listOld.parallelStream().forEach(listNew::add);<br>        System.out.println(listNew.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1000</span><br><span class="hljs-number">837</span><br></code></pre></td></tr></table></figure>
<p>我们发现明明是向集合中添加1000个元素，而实际上却只有837个元素。</p>
<p>针对这类问题，我们有那些解决方案呢？</p>
<ol>
<li>加同步锁</li>
<li>使用线程安全的容器</li>
<li>通过Stream中的<code>toArray()</code> / <code>collect()</code>操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamParallelThreadSafe</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加同步锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Object obj = <span class="hljs-keyword">new</span> Object();<br>        IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br>                .parallel()<br>                .forEach(i -&gt; &#123;<br>                    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                        listNew.add(i);<br>                    &#125;<br>                &#125;);<br>        System.out.println(listNew.size());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用线程安全的容器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//将线程不安全的容器包装为线程安全的容器  或者直接使用Vector也可以</span><br>        List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(listNew);<br>        IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br>                .parallel()<br>                .forEach(synchronizedList::add);<br>        System.out.println(synchronizedList.size());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 我们还可以通过Stream中的 toArray方法或者 collect方法来操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Integer&gt; listNew = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">/*Object[] list = IntStream.rangeClosed(1, 1000)</span><br><span class="hljs-comment">                .parallel()</span><br><span class="hljs-comment">                .boxed()</span><br><span class="hljs-comment">                .toArray();*/</span><br>        List&lt;Integer&gt; list = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br>                .parallel()<br>                .boxed()<br>                .collect(Collectors.toList());<br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>parallelStream使用的是Fork/Join框架。Fork/Join框架自 JDK7 引入。Fork/Join框架可以将一个大任务拆分为很多小任务来异步执行。</p>
<h3 id="Fork-Join原理-分治法"><a href="#Fork-Join原理-分治法" class="headerlink" title="Fork/Join原理-分治法"></a>Fork/Join原理-分治法</h3><p>ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法， ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。</p>
<p><img src="JDK8新特性笔记/image-16.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="Fork-Join原理-工作窃取算法"><a href="#Fork-Join原理-工作窃取算法" class="headerlink" title="Fork/Join原理-工作窃取算法"></a>Fork/Join原理-工作窃取算法</h3><p>Fork/Join最核心的地方就是利用了现代硬件设备多核，在一个操作时候会有空闲的cpu，那么如何利用好这个空闲的cpu就成了提高性能的关键，而这里我们要提到的工作窃取（work-stealing）算法就是整个Fork/Join框架的核心理念 。Fork/Join工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p>
<p><img src="JDK8新特性笔记/image-17.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖 的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来 执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的 任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就 去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任 务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永 远从双端队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争， 比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<p>上文中已经提到了在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，也就是我们使用了ForkJoinPool的ParallelStream。</p>
<p>对于ForkJoinPool通用线程池的线程数量，通常使用默认值就可以了，即运行时计算机的处理器数量。可以通过设置系统属性：java.util.concurrent.ForkJoinPool.common.parallelism=N （N为线程数量），来调整ForkJoinPool的线程数量，可以尝试调整成不同的参数来观察每次的输出结果。</p>
<h3 id="Fork-Join案例"><a href="#Fork-Join案例" class="headerlink" title="Fork/Join案例"></a>Fork/Join案例</h3><p>需求：使用Fork/Join计算1-10000的和，当一个任务的计算数量大于3000时拆分任务，数量小于3000时计算。</p>
<p><img src="JDK8新特性笔记/image-18.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool();<br>        SumRecursiveTask sumRecursiveTask = <span class="hljs-keyword">new</span> SumRecursiveTask(<span class="hljs-number">1</span>, <span class="hljs-number">10000L</span>);<br>        Long result = forkJoinPool.invoke(sumRecursiveTask);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;消耗时间：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumRecursiveTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> THRESHOLD = <span class="hljs-number">3000L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> end;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SumRecursiveTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> length = end - start;<br>        <span class="hljs-keyword">if</span> (length &lt;= THRESHOLD) &#123;<br>            <span class="hljs-comment">//任务不再拆分了，可以计算了</span><br>            <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = start; i &lt;= end; i++) &#123;<br>                sum += i;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;计算: &quot;</span> + start + <span class="hljs-string">&quot; -&gt; &quot;</span> + end + <span class="hljs-string">&quot;,结果为: &quot;</span> + sum);<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//数量大于阈值，任务还需要再拆分</span><br>            <span class="hljs-keyword">long</span> middle = (start + end) / <span class="hljs-number">2</span>;<br>            System.out.println(<span class="hljs-string">&quot;拆分: 左边 &quot;</span> + start + <span class="hljs-string">&quot; -&gt; &quot;</span> + middle + <span class="hljs-string">&quot;, 右边 &quot;</span> + (middle +<br>                    <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; -&gt; &quot;</span> + end);<br>            SumRecursiveTask left = <span class="hljs-keyword">new</span> SumRecursiveTask(start, middle);<br>            left.fork();<br>            SumRecursiveTask right = <span class="hljs-keyword">new</span> SumRecursiveTask(middle, end);<br>            right.fork();<br>            <span class="hljs-keyword">return</span> left.join() + right.join();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">拆分:</span> <span class="hljs-string">左边</span> <span class="hljs-number">1</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">5000</span><span class="hljs-string">,</span> <span class="hljs-string">右边</span> <span class="hljs-number">5001</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">10000</span><br><span class="hljs-string">拆分:</span> <span class="hljs-string">左边</span> <span class="hljs-number">1</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">2500</span><span class="hljs-string">,</span> <span class="hljs-string">右边</span> <span class="hljs-number">2501</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">5000</span><br><span class="hljs-string">拆分:</span> <span class="hljs-string">左边</span> <span class="hljs-number">5000</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">7500</span><span class="hljs-string">,</span> <span class="hljs-string">右边</span> <span class="hljs-number">7501</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">10000</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">5000</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">7500</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">15631250</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">2500</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">5000</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">9378750</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">7500</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">10000</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">21883750</span><br><span class="hljs-string">计算:</span> <span class="hljs-number">1</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">2500</span><span class="hljs-string">,结果为:</span> <span class="hljs-number">3126250</span><br><span class="hljs-string">result</span> <span class="hljs-string">=</span> <span class="hljs-number">50020000</span><br><span class="hljs-string">消耗时间：69</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>小结</strong></p>
<ol>
<li>parallelStream是线程不安全的。</li>
<li>parallelStream适用的场景是CPU密集型的，只是做到别浪费CPU，假如本身电脑CPU的负载就很大，还到处用并行流的话，反而不能起到正向作用。</li>
<li>I/O密集型：磁盘I/O、网络I/O都属于I/O操作，这部分操作是较少消耗CPU资源。一般并行流中不适用于I/O密集型的操作，就比如使用并流行进行大批量的消息推送，涉及到了大量I/O，此时使用并行流反而会导致慢很多。</li>
<li>在使用并行流的时候是无法保证元素的顺序的，即使你用了同步集合也只能保证元素都正确但无法保证其中的顺序。</li>
</ol>
</blockquote>
<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><p>这个Optional类主要是解决空指针异常。</p>
<h2 id="以前对null的处理"><a href="#以前对null的处理" class="headerlink" title="以前对null的处理"></a>以前对null的处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//Optional.of(T t)方式 不支持null</span><br>    Optional&lt;String&gt; op1 = Optional.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-comment">//Optional&lt;Object&gt; op2 = Optional.of(null);</span><br><br>    <span class="hljs-comment">//Optional.ofNullable(T t)方式 支持null</span><br>    Optional&lt;String&gt; op3 = Optional.ofNullable(<span class="hljs-string">&quot;李四&quot;</span>);<br>    Optional&lt;Object&gt; op4 = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">//Optional.empty()方式 直接创建一个空的Optional对象</span><br>    Optional&lt;Object&gt; op5 = Optional.empty();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Optional类介绍"><a href="#Optional类介绍" class="headerlink" title="Optional类介绍"></a>Optional类介绍</h2><p>Optional是一个没有子类的工具类，Optional是一个可以为null的容器对象。它的主要作用就是为了解决避免null检查，防止NullPointerException。</p>
<p><img src="JDK8新特性笔记/image-19.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="Optional的基本使用"><a href="#Optional的基本使用" class="headerlink" title="Optional的基本使用"></a>Optional的基本使用</h2><h3 id="Optional类的创建方式"><a href="#Optional类的创建方式" class="headerlink" title="Optional类的创建方式"></a>Optional类的创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个 Optional 实例</span><br>Optional.of(T t)<br><span class="hljs-comment">//若 t 不为 null,创建 Optional 实例,否则创建空实例</span><br>Optional.ofNullable(T t)<br><span class="hljs-comment">//创建一个空的 Optional 实例</span><br>Optional.empty()<br></code></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//Optional.of(T t)方式 不支持null</span><br>    Optional&lt;String&gt; op1 = Optional.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-comment">//Optional&lt;Object&gt; op2 = Optional.of(null);</span><br><br>    <span class="hljs-comment">//Optional.ofNullable(T t)方式 支持null</span><br>    Optional&lt;String&gt; op3 = Optional.ofNullable(<span class="hljs-string">&quot;李四&quot;</span>);<br>    Optional&lt;Object&gt; op4 = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">//Optional.empty()方式 直接创建一个空的Optional对象</span><br>    Optional&lt;Object&gt; op5 = Optional.empty();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Optional类的常用方法"><a href="#Optional类的常用方法" class="headerlink" title="Optional类的常用方法"></a>Optional类的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否包含值,包含值返回true，不包含值返回false</span><br>isPresent()<br><span class="hljs-comment">//如果Optional有值则将其返回，否则抛出NoSuchElementException</span><br>get()<br><span class="hljs-comment">//如果调用对象包含值，返回该值，否则返回参数t</span><br>orElse(T t)<br><span class="hljs-comment">//如果调用对象包含值，返回该值，否则返回Lambda表达式的返回值</span><br>orElseGet(Supplier s)<br></code></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    Optional&lt;String&gt; op1 = Optional.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>    Optional&lt;String&gt; op2 = Optional.empty();<br><br>    <span class="hljs-keyword">if</span> (op1.isPresent()) &#123;<br>        String s1 = op1.get();<br>        System.out.println(<span class="hljs-string">&quot;用户名称：&quot;</span> + s1);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (op2.isPresent()) &#123;<br>        String s2 = op2.get();<br>        System.out.println(s2);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;op2是一个空Optional对象&quot;</span>);<br>    &#125;<br><br>    String s3 = op1.orElse(<span class="hljs-string">&quot;李四&quot;</span>);<br>    System.out.println(s3);<br>    <br>    Object s4 = op2.orElse(<span class="hljs-string">&quot;王五&quot;</span>);<br>    System.out.println(s4);<br><br>    String s5 = op2.orElseGet(() -&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;);<br>    System.out.println(s5);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">用户名称：张三<br>op2是一个空<span class="hljs-keyword">Optional</span>对象<br>张三<br>王五<br>hello<br></code></pre></td></tr></table></figure>
<h1 id="日期和时间-API"><a href="#日期和时间-API" class="headerlink" title="日期和时间 API"></a>日期和时间 API</h1><h2 id="旧版日期和时间-API-存在的问题"><a href="#旧版日期和时间-API-存在的问题" class="headerlink" title="旧版日期和时间 API 存在的问题"></a>旧版日期和时间 API 存在的问题</h2><p>在旧版本中JDK对于日期和时间这块的时间是非常差的。</p>
<ol>
<li>设计差： 在java.util和java.sql的包中都有日期类，java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期。此外用于格式化和解析的类在java.text包中定义。</li>
<li>非线程安全：java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li>时区处理麻烦：日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和 java.util.TimeZone类，但他们同样存在上述所有的问题。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeDemo01</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//1、设计不合理</span><br>        Date date = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">2022</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>);<br>        System.out.println(date);<br><br>        <span class="hljs-comment">//2、时间格式化和解析操作是线程不安全的</span><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(sdf.parse(<span class="hljs-string">&quot;2022-08-18&quot;</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="新版日期和时间-API-介绍"><a href="#新版日期和时间-API-介绍" class="headerlink" title="新版日期和时间 API 介绍"></a>新版日期和时间 API 介绍</h2><p>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于 <code>java.time</code> 包中，下面是一些关键字：</p>
<ul>
<li><code>LocalDate</code> ：表示日期，包含年月日，格式为 2019-10-16</li>
<li><code>LocalTime</code> ：表示时间，包含时分秒，格式为 16:38:54.158549300</li>
<li><code>LocalDateTime</code> ：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</li>
<li><code>DateTimeFormatter</code> ：日期时间格式化类</li>
<li><code>Instant</code>：时间戳，表示一个特定的时间瞬间</li>
<li><code>Duration</code>：用于计算2个时间(LocalTime，时分秒)的距离</li>
<li><code>Period</code>：用于计算2个日期(LocalDate，年月日)的距离</li>
<li><code>ZonedDateTime</code> ：包含时区的时间</li>
</ul>
<p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天， 闰年是366天。</p>
<p>此外Java 8还提供了4套其他历法，分别是：</p>
<ul>
<li>ThaiBuddhistDate：泰国佛教历</li>
<li>MinguoDate：中华民国历</li>
<li>JapaneseDate：日本历</li>
<li>HijrahDate：伊斯兰历</li>
</ul>
<h3 id="日期和时间的常见操作"><a href="#日期和时间的常见操作" class="headerlink" title="日期和时间的常见操作"></a>日期和时间的常见操作</h3><p>LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDK8 日期操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1、创建指定的日期</span><br>    LocalDate date1 = LocalDate.of(<span class="hljs-number">2022</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>);<br>    System.out.println(<span class="hljs-string">&quot;date1 = &quot;</span> + date1);<br><br>    <span class="hljs-comment">//2、得到当前的日期</span><br>    LocalDate now = LocalDate.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br><br>    <span class="hljs-comment">//3、根据LocalDate对象获取对应的日期信息</span><br>    System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + now.getYear());<br>    System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + now.getMonth().getValue());<br>    System.out.println(<span class="hljs-string">&quot;日：&quot;</span> + now.getDayOfMonth());<br>    System.out.println(<span class="hljs-string">&quot;星期：&quot;</span> + now.getDayOfWeek().getValue());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDK8 时间操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1、得到指定的时间</span><br>    LocalTime time = LocalTime.of(<span class="hljs-number">5</span>, <span class="hljs-number">26</span>, <span class="hljs-number">33</span>, <span class="hljs-number">23145</span>);<br>    System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + time);<br><br>    <span class="hljs-comment">//2、获取当前的时间</span><br>    LocalTime now = LocalTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br><br>    <span class="hljs-comment">//3、获取时间信息</span><br>    System.out.println(<span class="hljs-string">&quot;时：&quot;</span> + now.getHour());<br>    System.out.println(<span class="hljs-string">&quot;分：&quot;</span> + now.getMinute());<br>    System.out.println(<span class="hljs-string">&quot;秒：&quot;</span> + now.getSecond());<br>    System.out.println(<span class="hljs-string">&quot;纳秒：&quot;</span> + now.getNano());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDK8 日期时间操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、获取指定的日期时间</span><br>    LocalDateTime dateTime = LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>, <span class="hljs-number">10</span>, <span class="hljs-number">22</span>, <span class="hljs-number">36</span>, <span class="hljs-number">213</span>);<br>    System.out.println(<span class="hljs-string">&quot;dateTime = &quot;</span>+dateTime);<br><br>    <span class="hljs-comment">//2、获取当前的日期时间</span><br>    LocalDateTime now = LocalDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span>+now );<br><br>    <span class="hljs-comment">//3、获取日期时间信息</span><br>    System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + now.getYear());<br>    System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + now.getMonth().getValue());<br>    System.out.println(<span class="hljs-string">&quot;日：&quot;</span> + now.getDayOfMonth());<br>    System.out.println(<span class="hljs-string">&quot;星期：&quot;</span> + now.getDayOfWeek().getValue());<br>    System.out.println(<span class="hljs-string">&quot;时：&quot;</span> + now.getHour());<br>    System.out.println(<span class="hljs-string">&quot;分：&quot;</span> + now.getMinute());<br>    System.out.println(<span class="hljs-string">&quot;秒：&quot;</span> + now.getSecond());<br>    System.out.println(<span class="hljs-string">&quot;纳秒：&quot;</span> + now.getNano());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="日期和时间的修改与比较"><a href="#日期和时间的修改与比较" class="headerlink" title="日期和时间的修改与比较"></a>日期和时间的修改与比较</h3><p>对日期时间的修改，最简单的方式是使用withAttribute方法。 withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。每次操作都是返回了一个新的对象，所以在多线程场景下是数据安全的。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日期时间的修改</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br>    <span class="hljs-comment">// 修改日期时间，修改后返回新的对象</span><br>    LocalDateTime localDateTime = now.withYear(<span class="hljs-number">1999</span>);<br>    System.out.println(<span class="hljs-string">&quot;now :&quot;</span> + now);<br>    System.out.println(<span class="hljs-string">&quot;修改后的：&quot;</span> + localDateTime);<br>    System.out.println(<span class="hljs-string">&quot;月份：&quot;</span> + now.withMonth(<span class="hljs-number">10</span>));<br>    System.out.println(<span class="hljs-string">&quot;天：&quot;</span> + now.withDayOfMonth(<span class="hljs-number">6</span>));<br>    System.out.println(<span class="hljs-string">&quot;小时：&quot;</span> + now.withHour(<span class="hljs-number">8</span>));<br>    System.out.println(<span class="hljs-string">&quot;分钟:&quot;</span> + now.withMinute(<span class="hljs-number">15</span>));<br>    <span class="hljs-comment">// 在当前日期时间的基础上 加上/减去指定的时间</span><br>    System.out.println(<span class="hljs-string">&quot;两天后:&quot;</span> + now.plusDays(<span class="hljs-number">2</span>));<br>    System.out.println(<span class="hljs-string">&quot;10年后:&quot;</span> + now.plusYears(<span class="hljs-number">10</span>));<br>    System.out.println(<span class="hljs-string">&quot;6个月后 = &quot;</span> + now.plusMonths(<span class="hljs-number">6</span>));<br>    System.out.println(<span class="hljs-string">&quot;10年前 = &quot;</span> + now.minusYears(<span class="hljs-number">10</span>));<br>    System.out.println(<span class="hljs-string">&quot;半年前 = &quot;</span> + now.minusMonths(<span class="hljs-number">6</span>));<br>    System.out.println(<span class="hljs-string">&quot;一周前 = &quot;</span> + now.minusDays(<span class="hljs-number">7</span>));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日期时间的比较</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//在JDK8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期，可直接进行比较。</span><br>    LocalDateTime now = LocalDateTime.now();<br>    LocalDateTime dateTime = LocalDateTime.of(<span class="hljs-number">1999</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);<br>    System.out.println(now.isBefore(dateTime));<br>    System.out.println(now.equals(dateTime));<br>    System.out.println(now.isAfter(dateTime));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="格式化和解析操作"><a href="#格式化和解析操作" class="headerlink" title="格式化和解析操作"></a>格式化和解析操作</h3><p>通过 <code>java.time.format.DateTimeFormatter</code> 类可以进行日期时间解析与格式化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//得到当前日期时间</span><br>    LocalDateTime now = LocalDateTime.now();<br><br>    <span class="hljs-comment">//通过 ofPattern 方法来指定特定的格式</span><br>    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-comment">//将日期时间 格式化为 字符串</span><br>    String format = now.format(formatter);<br>    System.out.println(<span class="hljs-string">&quot;format = &quot;</span> + format);<br><br>    <span class="hljs-comment">//将字符串 解析为 日期时间</span><br>    LocalDateTime parse = LocalDateTime.parse(<span class="hljs-string">&quot;1999-10-10 10:10:10&quot;</span>, formatter);<br>    System.out.println(<span class="hljs-string">&quot;parse = &quot;</span> + parse);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Instant类"><a href="#Instant类" class="headerlink" title="Instant类"></a>Instant类</h3><p>在JDK8中给我们新增一个Instant类(时间戳/时间线)，内部保存了从1970年1月1日 00:00:00 以来的秒和纳秒</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Instant 时间戳，可以用来统计时间消耗</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Instant now = Instant.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span> + now);<br>    <span class="hljs-comment">//获取从1970年一月一日 00:00:00 到现在的纳秒</span><br>    System.out.println(now.getNano());<br>    Thread.sleep(<span class="hljs-number">5</span>);<br>    Instant now1 = Instant.now();<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (now1.getNano() - now.getNano()));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="计算日期时间差"><a href="#计算日期时间差" class="headerlink" title="计算日期时间差"></a>计算日期时间差</h3><p>JDK8中提供了两个工具类<code>Duration/Period</code>：计算日期时间差</p>
<ul>
<li><code>Duration</code>：用来计算两个时间差(LocalTime)</li>
<li><code>Period</code>:用来计算两个日期差(LocalDate)</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test09</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Duration 计算时间的差距</span><br>    LocalTime nowTime = LocalTime.now();<br>    LocalTime time = LocalTime.of(<span class="hljs-number">15</span>, <span class="hljs-number">38</span>, <span class="hljs-number">36</span>);<br>    Duration duration = Duration.between(time, nowTime);<br>    System.out.println(<span class="hljs-string">&quot;相差的天数:&quot;</span> + duration.toDays());<br>    System.out.println(<span class="hljs-string">&quot;相差的小时数:&quot;</span> + duration.toHours());<br>    System.out.println(<span class="hljs-string">&quot;相差的分钟数:&quot;</span> + duration.toMinutes());<br>    System.out.println(<span class="hljs-string">&quot;相差的秒数:&quot;</span> + duration.toSeconds());<br><br>    <span class="hljs-comment">// Period 计算日期的差距</span><br>    LocalDate nowDate = LocalDate.now();<br>    LocalDate date = LocalDate.of(<span class="hljs-number">1999</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    Period period = Period.between(date, nowDate);<br>    System.out.println(<span class="hljs-string">&quot;相差的年:&quot;</span> + period.getYears());<br>    System.out.println(<span class="hljs-string">&quot;相差的月:&quot;</span> + period.getMonths());<br>    System.out.println(<span class="hljs-string">&quot;相差的天:&quot;</span> + period.getDays());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="时间矫正器"><a href="#时间矫正器" class="headerlink" title="时间矫正器"></a>时间矫正器</h3><p>有时我们可能需要获取例如：将日期调整到“下一个月的第一天”等操作。可以通过时间校正器来进行。</p>
<ul>
<li><code>TemporalAdjuster</code> : 时间校正器</li>
<li><code>TemporalAdjusters</code> : 该类通过静态方法提供了大量的常用TemporalAdjuster的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    <span class="hljs-comment">//得到当前的日期调整到下个月的一号</span><br>    TemporalAdjuster firstDayOfNextMonth= temporal -&gt; &#123;<br>        LocalDateTime dateTime = (LocalDateTime) temporal;<br>        LocalDateTime nextMonth = dateTime.plusMonths(<span class="hljs-number">1</span>).withDayOfMonth(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nextMonth;<br>    &#125;;<br>    LocalDateTime newDateTime = now.with(firstDayOfNextMonth);<br>    System.out.println(<span class="hljs-string">&quot;newDateTime = &quot;</span>+newDateTime);<br><br>    <span class="hljs-comment">//可以通过 TemporalAdjusters 来实现</span><br>    LocalDateTime newDateTime2 = now.with(TemporalAdjusters.firstDayOfNextMonth());<br>    System.out.println(<span class="hljs-string">&quot;newDateTime2 = &quot;</span>+newDateTime2);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="日期时间的时区"><a href="#日期时间的时区" class="headerlink" title="日期时间的时区"></a>日期时间的时区</h3><p>不带时区的：LocalDate、LocalTime、LocalDateTime</p>
<p>带时区的：ZonedDateTime</p>
<p>其中每个时区都对应着 ID，ID的格式为 “区域/城市” 例如 ：Asia/Shanghai 等</p>
<p>ZoneId：该类中包含了所有的时区信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//获取所有的时区ID</span><br>    <span class="hljs-comment">//ZoneId.getAvailableZoneIds().forEach(System.out::println);</span><br><br>    <span class="hljs-comment">//获取当前时间,中国使用的东八区的时区，比标准时间早8个小时</span><br>    LocalDateTime now = LocalDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now = &quot;</span>+now);<br><br>    <span class="hljs-comment">//使用计算机默认的时区，创建日期时间</span><br>    ZonedDateTime now1 = ZonedDateTime.now();<br>    System.out.println(<span class="hljs-string">&quot;now1 = &quot;</span>+now1);<br><br>    <span class="hljs-comment">//使用指定的时区创建日期时间</span><br>    ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(<span class="hljs-string">&quot;America/Marigot&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;now2 = &quot;</span>+now2);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">now</span> = <span class="hljs-number">2022</span>-<span class="hljs-number">08</span>-<span class="hljs-number">19</span>T<span class="hljs-number">00</span>:<span class="hljs-number">35</span>:<span class="hljs-number">35</span>.<span class="hljs-number">245237600</span><br><span class="hljs-attribute">now1</span> = <span class="hljs-number">2022</span>-<span class="hljs-number">08</span>-<span class="hljs-number">19</span>T<span class="hljs-number">00</span>:<span class="hljs-number">35</span>:<span class="hljs-number">35</span>.<span class="hljs-number">259200800</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>[Asia/Shanghai]<br><span class="hljs-attribute">now2</span> = <span class="hljs-number">2022</span>-<span class="hljs-number">08</span>-<span class="hljs-number">18</span>T<span class="hljs-number">12</span>:<span class="hljs-number">35</span>:<span class="hljs-number">35</span>.<span class="hljs-number">260198300</span>-<span class="hljs-number">04</span>:<span class="hljs-number">00</span>[America/Marigot]<br></code></pre></td></tr></table></figure>
<h1 id="重复注解与类型注解"><a href="#重复注解与类型注解" class="headerlink" title="重复注解与类型注解"></a>重复注解与类型注解</h1><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>自从Java 5中引入 <code>注解</code> 以来，注解开始变得非常流行，并在各个框架和项目中被广泛使用。不过注解有一个很大的限 制是：在同一个地方不能多次使用同一个注解。JDK 8引入了重复注解的概念，允许在同一个地方多次使用同一个注 解。在JDK 8中使用<code>@Repeatable</code>注解定义重复注解。</p>
<p>重复注解的使用步骤：</p>
<ol>
<li><p>定义一个重复注解的容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotations &#123;<br>    MyAnnotation[] value();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>定义一个可重复的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(MyAnnotations.class)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>配置多个重复的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation(&quot;test1&quot;)</span><br><span class="hljs-meta">@MyAnnotation(&quot;test2&quot;)</span><br><span class="hljs-meta">@MyAnnotation(&quot;test3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnoTest01</span> </span>&#123;<br><br>    <span class="hljs-meta">@MyAnnotation(&quot;fun1&quot;)</span><br>    <span class="hljs-meta">@MyAnnotation(&quot;fun2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">//......</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>解析得到指定的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析重复注解</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>    <span class="hljs-comment">//获取类中标注的重复注解</span><br>    MyAnnotation[] annotationsByType = AnnoTest01.class.getAnnotationsByType(MyAnnotation.class);<br>    <span class="hljs-keyword">for</span> (MyAnnotation myAnnotation : annotationsByType) &#123;<br>        System.out.println(myAnnotation.value());<br>    &#125;<br>    <span class="hljs-comment">//获取方法上标注的重复注解</span><br>    MyAnnotation[] test01s = AnnoTest01.class.getMethod(<span class="hljs-string">&quot;test01&quot;</span>).getAnnotationsByType(MyAnnotation.class);<br>    <span class="hljs-keyword">for</span> (MyAnnotation test01 : test01s) &#123;<br>        System.out.println(test01.value());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">test<span class="hljs-number">1</span><br>test<span class="hljs-number">2</span><br>test<span class="hljs-number">3</span><br>fu<span class="hljs-symbol">n1</span><br>fu<span class="hljs-symbol">n2</span><br></code></pre></td></tr></table></figure>
<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>JDK8为<code>@Target</code>元注解新增了两种类型： TYPE_PARAMETER、TYPE_USE </p>
<ul>
<li><code>TYPE_PARAMETER</code> ：表示该注解能写在类型参数的声明语句中</li>
<li><code>TYPE_USE</code> ：表示注解可以在任何用到类型的地方使用</li>
</ul>
<p>TYPE_PARAMETER的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE_PARAMETER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TypeParam &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以把注解放在泛型上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeDemo01</span>&lt;@<span class="hljs-title">TypeParam</span> <span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;<span class="hljs-meta">@TypeParam</span> K extends Objects&gt; <span class="hljs-function">K <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>TYPE_USE的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE_USE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NotNull &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以把注解放在类型的前面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeDemo02</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@NotNull</span> Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Integer a, <span class="hljs-meta">@NotNull</span> Integer b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JDK8新特性笔记</div>
      <div>http://yoursite.com/2022/08/14/JDK8新特性笔记/</div>
    </div>
    <div class="license-meta">
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="设计模式笔记（一）六大设计原则">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设计模式笔记（一）六大设计原则</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/11/Java-NIO%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Netty%E6%A1%86%E6%9E%B6/" title="Java NIO笔记（二）Netty框架">
                        <span class="hidden-mobile">Java NIO笔记（二）Netty框架</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
