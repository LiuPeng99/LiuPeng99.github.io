

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、Java SE基础（上）1、运算符（上）简介：短路运算符 和 位运算  考点：计算机基础运算知识  运算符 &amp;和&amp;&amp; 以及 |和|| 的区别 1234567891011121314&amp; 按位与操作	两个二进制数同时为1时，结果才为1	1&amp;1 &#x3D; 1	1&amp;0 &#x3D; 0	0&amp;1 &#x3D; 0	0&amp;0 &#x3D; 0| 按位或操作	两个二进制数中有一个为">
<meta property="og:type" content="article">
<meta property="og:title" content="后端面试">
<meta property="og:url" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name">
<meta property="og:description" content="一、Java SE基础（上）1、运算符（上）简介：短路运算符 和 位运算  考点：计算机基础运算知识  运算符 &amp;和&amp;&amp; 以及 |和|| 的区别 1234567891011121314&amp; 按位与操作	两个二进制数同时为1时，结果才为1	1&amp;1 &#x3D; 1	1&amp;0 &#x3D; 0	0&amp;1 &#x3D; 0	0&amp;0 &#x3D; 0| 按位或操作	两个二进制数中有一个为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-1.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-2.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-3.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-4.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-5.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-6.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-7.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-8.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-9.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-10.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-11.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-12.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-13.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-14.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-15.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-16.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-17.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-18.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-19.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-20.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-21.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-22.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-23.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-24.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-25.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-26.png">
<meta property="og:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-27.png">
<meta property="article:published_time" content="2022-07-01T01:40:48.355Z">
<meta property="article:modified_time" content="2022-09-17T13:47:04.180Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/2022/07/01/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/后端面试/image-1.png">
  
  
  
  <title>后端面试 - </title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="后端面试"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-01 09:40" pubdate>
          2022年7月1日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          68k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          563 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">后端面试</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、Java-SE基础（上）"><a href="#一、Java-SE基础（上）" class="headerlink" title="一、Java SE基础（上）"></a>一、Java SE基础（上）</h1><h2 id="1、运算符（上）"><a href="#1、运算符（上）" class="headerlink" title="1、运算符（上）"></a>1、运算符（上）</h2><p><strong>简介：短路运算符 和 位运算</strong></p>
<ul>
<li><p>考点：计算机基础运算知识</p>
</li>
<li><p>运算符 &amp;和&amp;&amp; 以及 |和|| 的区别</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp; 按位与操作</span><br>	两个二进制数同时为<span class="hljs-number">1</span>时，结果才为<span class="hljs-number">1</span><br>	<span class="hljs-number">1</span><span class="hljs-meta">&amp;1 = 1</span><br>	<span class="hljs-number">1</span><span class="hljs-meta">&amp;0 = 0</span><br>	<span class="hljs-number">0</span><span class="hljs-meta">&amp;1 = 0</span><br>	<span class="hljs-number">0</span><span class="hljs-meta">&amp;0 = 0</span><br><span class="hljs-string">| 按位或操作</span><br>	两个二进制数中有一个为<span class="hljs-number">1</span>时，结果就为<span class="hljs-number">1</span><br>	<span class="hljs-number">1</span><span class="hljs-string">|1 = 1</span><br>	<span class="hljs-number">1</span><span class="hljs-string">|0 = 1</span><br>	<span class="hljs-number">0</span><span class="hljs-string">|1 = 1</span><br>	<span class="hljs-number">0</span><span class="hljs-string">|0 = 0</span><br>	<br><span class="hljs-meta">&amp;和| 称为位运算符</span><br></code></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;和&amp;&amp;</span><br>区别：<span class="hljs-meta">&amp;两边都要运算，而&amp;&amp;先算左侧，若左侧为false，那么右侧将不再运算。判断语句中推荐使用&amp;&amp; 效率更高。</span><br><br><span class="hljs-string">|和||</span><br>区别：<span class="hljs-string">|要对所有条件进行判断，而||只要满足左侧的条件，那么右侧将不再运算。</span><br><br><span class="hljs-meta">&amp;&amp;和|| 称为短路运算符 在判断语句中常见</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>用最有效的方法计算 2乘以8</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing">答案：<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">3</span><br>原理：将一个数m左移n位，相当于m乘以<span class="hljs-number">2</span>的n次方，位运算是CPU直接支持的，所以效率高。<br><br>常见的JDK源码里面的<span class="hljs-keyword">HashMap</span>的默认容量为<span class="hljs-number">16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br>直接二进制操作，表示<span class="hljs-number">1</span>左移<span class="hljs-number">4</span>位，变<span class="hljs-number">10000</span>，转为十进制就是<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2、运算符（下）"><a href="#2、运算符（下）" class="headerlink" title="2、运算符（下）"></a>2、运算符（下）</h2><p><strong>简介：异或运算</strong></p>
<ul>
<li><p>考点：计算机基础运算知识</p>
</li>
<li><p>写个方法，传递两个非0的int数值进去，实现变量交换的方式，有几种方式？（不借助第三个临时变量）</p>
<ul>
<li><p>方式一：数学等量代换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d&quot;</span>, a, b);<br>        a = a + b; <span class="hljs-comment">// a1 = a + b</span><br>        b = a - b; <span class="hljs-comment">// b = a1 - b = (a + b) -b 即 b = a</span><br>        a = a - b; <span class="hljs-comment">// a = a1 - b = (a + b) - (a) 即 a = b</span><br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\na=%d,b=%d&quot;</span>, a, b);<br>	&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式二：异或运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap02</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d&quot;</span>, a, b);<br>        a = a ^ b; <span class="hljs-comment">// a1 = a^b</span><br>        b = b ^ a; <span class="hljs-comment">// b = b^a1 = b^a^b = a</span><br>        a = a ^ b; <span class="hljs-comment">// a = a1^b = a^b^a = b</span><br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\na=%d,b=%d&quot;</span>, a, b);<br>	&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="3、类型"><a href="#3、类型" class="headerlink" title="3、类型"></a>3、类型</h2><p><strong>简介：Java数据类型划分</strong></p>
<ul>
<li><p>考点：Java基础类型的划分和运算</p>
</li>
<li><p>说下Java数据类型分类</p>
<ul>
<li>基础数据类型：byte、short、int、long、float、double、char、boolean</li>
<li>引用数据类型：其他都是引用类型</li>
</ul>
</li>
<li><p>运算</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">定义变量 int i = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> i++; 和 <span class="hljs-keyword">return</span> ++i; 返回结果是什么<br>    <span class="hljs-number">5</span>              <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>== 和 equals 的区别</p>
<ul>
<li>基本数据类型比较<ul>
<li>用 == 判断是否相等</li>
</ul>
</li>
<li>引用数据类比较<ul>
<li>== 比较的是内存地址是否一样，不同对象的内存地址不一样</li>
<li>equals 比较的是具体的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4、try-catch-finally"><a href="#4、try-catch-finally" class="headerlink" title="4、try-catch-finally"></a>4、try-catch-finally</h2><p><strong>简介：try-catch-finally异常处理模块的返回值问题</strong></p>
<ul>
<li><p>考点：编码规范和执行逻辑</p>
</li>
<li><p>下面代码的 try-catch-finally 语句，try里面有个return，finally里面也有return，结果会返回什么？为什么？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">finally</span> 中的 <span class="hljs-keyword">return</span> 值会覆盖 <span class="hljs-keyword">try</span> 和 <span class="hljs-keyword">catch</span> 中的 <span class="hljs-keyword">return</span> 值。在正常情况（即程序正常执行<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span>语句块，不会在语句中出现退出程序、线程终止等特殊情况）下，都会执行<span class="hljs-keyword">finally</span>语句块，如果<span class="hljs-keyword">finally</span>中有<span class="hljs-keyword">return</span>，则程序会走<span class="hljs-keyword">finally</span>中的<span class="hljs-keyword">return</span>，如果没有，则先执行<span class="hljs-keyword">try</span>或者<span class="hljs-keyword">catch</span>中的<span class="hljs-keyword">return</span>，将其存入临时栈中，执行完<span class="hljs-keyword">finally</span>语句后最终返回临时栈中的值。<br><br><span class="hljs-keyword">public</span> static int test1() &#123;<br>        int i = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = i / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> --i;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            --i;<br>            <span class="hljs-keyword">return</span> i--;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            --i;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//返回值是9</span><br><span class="hljs-keyword">catch</span>中执行到<span class="hljs-keyword">return</span>语句时，不会真正的<span class="hljs-keyword">return</span>，即只是会计算<span class="hljs-keyword">return</span>中的表达式，之后将本应返回的结果（本题为<span class="hljs-number">9</span>）保存在一个临时栈中，接着执行<span class="hljs-keyword">finally</span>中的语句，最后才会从临时栈中取出之前的结果返回。<br><br><span class="hljs-keyword">public</span> static int test2() &#123;<br>        int i = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = i / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> --i;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            --i;<br>            <span class="hljs-keyword">return</span> i--;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            --i;<br>            <span class="hljs-keyword">return</span> i--;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//返回值是7</span><br><span class="hljs-keyword">catch</span>和<span class="hljs-keyword">finally</span>都包含<span class="hljs-keyword">return</span>，会执行<span class="hljs-keyword">catch</span>里面的<span class="hljs-keyword">return</span>语句，但并不返回。最终<span class="hljs-keyword">return</span>的是<span class="hljs-keyword">finally</span>里面的值。<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5、try-with-resource"><a href="#5、try-with-resource" class="headerlink" title="5、try-with-resource"></a>5、try-with-resource</h2><p><strong>简介：JDK9新特性 try-with-resource</strong></p>
<ul>
<li><p>考点：变成基础和是否有学习新知识</p>
</li>
<li><p>有了解新版的JDK处理IO流吗？编写下基础代码, 从一个txt文本里面，拷贝里面的内容到另外一个txt文本里面</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">JDK7之后的写法，JDK9⼜进⾏了改良，但是变化不⼤，记住下⾯的写法即可<br>需要关闭的资源只要实现了java<span class="hljs-selector-class">.lang</span>.AutoCloseable，就可以⾃动被关闭<br><span class="hljs-function"><span class="hljs-title">try</span><span class="hljs-params">()</span></span>⾥⾯可以定义多个资源，它们的关闭顺序是在try()中后定义的资源先关闭<br></code></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span> (<br>                FileInputStream fis = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;C:/Users/LiuPeng/Desktop/test.txt&quot;</span>);<br>                BufferedInputStream bis = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedInputStream</span>(fis);<br>                FileOutputStream fos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileOutputStream</span>(<span class="hljs-string">&quot;C:/Users/LiuPeng/Desktop/copy.txt&quot;</span>);<br>                BufferedOutputStream bos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedOutputStream</span>(fos);<br>        ) &#123;<br>            <span class="hljs-keyword">int</span> size;<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span> ((size = bis.<span class="hljs-built_in">read</span>(buf)) != <span class="hljs-number">-1</span>) &#123;<br>                bos.<span class="hljs-built_in">write</span>(buf, <span class="hljs-number">0</span>, size);<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (Exception e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6、文件API和递归算法"><a href="#6、文件API和递归算法" class="headerlink" title="6、文件API和递归算法"></a>6、文件API和递归算法</h2><p><strong>简介：常见的文件API掌握，熟悉递归算法</strong></p>
<ul>
<li><p>考点：文件API使用，简单递归逻辑代码编写、代码编写规范、简洁性</p>
</li>
<li><p>代码编写需求：找出某目录下的所有子目录及子文件并打印到控制台上</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//找出某目录下的所有子目录及子文件并打印到控制台上</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; paths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-built_in">getAllFIlePaths</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-built_in">File</span></span>(<span class="hljs-string">&quot;C:\\IDEA\\IdeaProjects\\back-end interview&quot;</span>), paths);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> path : paths) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(path);<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAllFIlePaths</span><span class="hljs-params">(<span class="hljs-built_in">File</span> filePath, List&lt;<span class="hljs-keyword">String</span>&gt; paths)</span> </span>&#123;<br><br>        <span class="hljs-built_in">File</span>[] files = filePath.<span class="hljs-built_in">listFiles</span>();<br>        <span class="hljs-keyword">if</span> (files == null) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">File</span> file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">isDirectory</span>()) &#123;<br>                paths.<span class="hljs-built_in">add</span>(file.<span class="hljs-built_in">getPath</span>());<br>                <span class="hljs-built_in">getAllFIlePaths</span>(file, paths);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                paths.<span class="hljs-built_in">add</span>(file.<span class="hljs-built_in">getPath</span>());<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二、Java-SE基础（下）"><a href="#二、Java-SE基础（下）" class="headerlink" title="二、Java SE基础（下）"></a>二、Java SE基础（下）</h1><h2 id="1、字符串"><a href="#1、字符串" class="headerlink" title="1、字符串"></a>1、字符串</h2><p><strong>简介：常用字符串的考查点</strong></p>
<ul>
<li><p>下面这句话中创建了几个对象？</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;abc&quot;</span>); <br></code></pre></td></tr></table></figure>
<p>创建一个对象：常量池存在，则直接new一个对象在堆内存</p>
<p>创建两个对象：常量池不存在，则一个在常量池，一个在堆内存，堆内存对象是常量池对象的一个拷贝副本。</p>
</li>
<li><p>下面代码是比较什么？输出结果是什么？为什么？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;abc&quot;</span>); <br><span class="hljs-keyword">String</span> str2 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">String</span> str3 = <span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(str1 == str2); <span class="hljs-comment">//false</span><br>System.out.<span class="hljs-built_in">println</span>(str2 == str3); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>
<p>== 比较的 str1 和 str2 对象的内存地址，由于 str1 指向的是堆内存的地址，str2 看到 “abc” 已经在常量池存在，就不会再新建，所以 str2 指向了常量池的内存地址，所以 == 判断结果输出false，两者不相等</p>
<p>在上面把 “abc” 同时赋值给了 str2 和 str3 两个字符串对象，指向的都是同一个常量池的内存地址，所以第二个打印语句中的 == 比较输出结果是 true</p>
</li>
<li><p>下面代码的输出结果是什么？如果需要两个都为true，应该如何修改？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str1 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">String</span> str2 = str1 + <span class="hljs-string">&quot;c&quot;</span>;  <span class="hljs-comment">//变量 + 常量 = 来自堆</span><br><span class="hljs-keyword">String</span> str3 = <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>; <span class="hljs-comment">//常量 + 常量 = 来自常量池</span><br>System.out.<span class="hljs-built_in">println</span>(str2 == <span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">//false</span><br>System.out.<span class="hljs-built_in">println</span>(str3 == <span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>
<p>String str2 = str1 + “c”;  //变量 + 常量 = 来自堆。任何数据和字符串进行加号（+）运算，最终得到是一个拼接的新的字符串。拼接的原理是由 StringBuilder 或者 StringBuffe r类和里面的 append 方法实现拼接，然后调用 toString() 把拼接的对象转换成字符串对象，最后把得到字符串对象的地址赋值给变量。</p>
<p>“ab” , ”c” 两个本来就是字符串常量，进行+符号拼接之后变成了 “abc” ，“abc” 本身就是字符串常量（Java中有常量优化机制），所以常量池立马会创建一个 “abc” 的字符串常量对象，在进行str3 ==  ”abc” ,这个时候，常量池存在 “abc” 。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">如果需要使第一个输出语句为<span class="hljs-literal">true</span>，则需要把变量改为常量即可<br>fianl <span class="hljs-keyword">String</span> str1 = <span class="hljs-string">&quot;ab&quot;</span>;<br>在<span class="hljs-keyword">String</span>前再加一个<span class="hljs-keyword">final</span>是固定了它的指引，让他不会再指向别的地址。当加上<span class="hljs-keyword">final</span>以后，这个值其实就已经在常量池中存在了，当调用这个变量时会把这个变量时，程序会把它当成一个常量来对待。<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2、字符串相关构建类"><a href="#2、字符串相关构建类" class="headerlink" title="2、字符串相关构建类"></a>2、字符串相关构建类</h2><p><strong>简介：常用字符串相关构建类的使用和区别</strong></p>
<ul>
<li><p>常用类的掌握情况</p>
</li>
<li><p>String，StringBuffer和StringBuilder之间的区别是什么？分别在哪些场景下使用？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">三者都是<span class="hljs-keyword">final</span>修饰的， 不允许被继承<br>在本质都是<span class="hljs-keyword">char</span>[]字符数组实现<br></code></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span>是不可变对象，任何对<span class="hljs-built_in">String</span>改变都是会产生一个新的<span class="hljs-built_in">String</span>对象<br><span class="hljs-built_in">StringBuffer</span>和StringBuilder是可变的，对应的字符串的改变不会产生新的对象<br><br><span class="hljs-built_in">StringBuffer</span>的读写方法都使用了synchronized修饰，同一时间只有一个线程进行操作，所以是线程安全的，效率相对较低<br>StringBuilder因为没有加锁，不具备多线程安全，但效率更高<br></code></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">使用场景：<br>    操作少量的数据用<span class="hljs-built_in">String</span>，但是经常改变内容且操作数据多的情况下最好不要用 <span class="hljs-built_in">String</span> ，因为每次都生成中间对象导致性能会降低<br><br>	多线程下操作大量的字符串，且需要保证线程安全 则用<span class="hljs-built_in">StringBuffer</span><br>    <br>    单线程下操作大量的字符串，在业务允许的情况下，虽然线程不安全但是不影响，则用StringBuilder<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3、面向对象"><a href="#3、面向对象" class="headerlink" title="3、面向对象"></a>3、面向对象</h2><p><strong>简介：面向对象思想OOP</strong></p>
<ul>
<li><p>考点：面向对象思想OOP的理解</p>
</li>
<li><p>面向对象的四大特性是什么？</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">抽象<br>	关键词<span class="hljs-keyword">abstract</span>声明的类叫作抽象类，<span class="hljs-keyword">abstract</span>声明的⽅法叫抽象⽅法<br>	⼀个类⾥包含了⼀个或多个抽象⽅法，类就必须指定成抽象类<br>	抽象⽅法属于⼀种特殊⽅法，只含有⼀个声明，没有⽅法体<br>	抽象支付 pay(金额，订单号)，具体实现则可以是微信支付，支付宝支付，银行卡支付<br><br>封装<br>	把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口<br>	在java中通过关键字<span class="hljs-keyword">private</span>，<span class="hljs-keyword">protected</span>和<span class="hljs-keyword">public</span>实现封装<br>	适当的封装可以让代码更容易理解和维护，也加强了代码的安全性<br>	<br>继承<br>	从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为<br>	<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsPay</span></span>&#123;<br>	<br>	&#125;<br>        <br>	WeixinPay <span class="hljs-keyword">extends</span> AbsPay&#123;<br>	<br>	&#125;<br>        <br>	AliPay <span class="hljs-keyword">extends</span> AbsPay&#123;<br>	<br>	&#125;<br><br>多态<br>	多个不同的对象对同一消息作出响应。同一消息根据不同的对象而采用各种不同的方法<br>	优点：减少耦合、灵活可拓展<br>	⼀般是继承类或者重写⽅法实现<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4、接口"><a href="#4、接口" class="headerlink" title="4、接口"></a>4、接口</h2><p><strong>简介：JDK8 接口新特性</strong></p>
<ul>
<li><p>考点：基础是否扎实和是否了解语言的新特性</p>
</li>
<li><p>Overload和Override的区别？</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">重载<span class="hljs-keyword">Overload</span>：表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同，参数个数或类型不同（同名不同参）<br>重写<span class="hljs-keyword">Override</span>：表示子类中的方法可以与父类中的某个方法的名称和参数完全相同（同名同参）<br></code></pre></td></tr></table></figure>
</li>
<li><p>接口是否可以继承接口？接口是否支持多继承？类是否支持多继承？接口里面是否可以有方法实现？</p>
<ul>
<li>接口里可以有静态方法和方法体</li>
<li>接口中所有的方法必须是抽象方法（JDK8之后就不是）</li>
<li>接口不是被类继承了，而是要被类实现</li>
<li>接口支持多继承, 类不支持多个类继承</li>
</ul>
<p>⼀个类只能继承⼀个类，但是能实现多个接口；一个接口能继承另⼀个或多个接口，接口的继承也使⽤extends关键字，和类继承⼀样</p>
</li>
<li><p>JDK8的接口新特性有哪些？</p>
<ul>
<li>interface中可以有static方法，但必须有方法实现体，该方法只属于该接口，只能通过接口名直接调用该方法</li>
<li>接口中新增default关键字修饰的方法，default方法只能定义在接口中，可以在子类或子接口中被重写，default定义的方法必须有方法体</li>
</ul>
</li>
</ul>
<h1 id="三、Java集合List"><a href="#三、Java集合List" class="headerlink" title="三、Java集合List"></a>三、Java集合List</h1><h2 id="1、Java集合List基础（上）"><a href="#1、Java集合List基础（上）" class="headerlink" title="1、Java集合List基础（上）"></a>1、Java集合List基础（上）</h2><p><strong>简介：Java集合LIst常见基础面试题</strong></p>
<ul>
<li>考点：List的基础知识点掌握、对应实现的区别、线程安全、使用场景</li>
<li>Vector、ArrayList、LinkedList的联系和区别？各自的使用场景？<ul>
<li>线程安全：<ul>
<li>Vector：底层是数组实现，线程安全，操作时使用synchronized进行加锁</li>
<li>ArrayList：底层是数组实现，线程不安全，查询和修改快，增加和删除慢</li>
<li>LinkedList：底层是双向链表实现，线程不安全，查询和修改慢，增加和删除快</li>
</ul>
</li>
<li>使用场景：<ul>
<li>Vector：很少使用了</li>
<li>ArrayList：查询和修改场景多时</li>
<li>LinkedList：增加和删除场景多时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、Java集合List基础（下）"><a href="#2、Java集合List基础（下）" class="headerlink" title="2、Java集合List基础（下）"></a>2、Java集合List基础（下）</h2><p><strong>简介：基于List基础篇进行追问</strong></p>
<ul>
<li>考点：List的掌握情况（追问系列）</li>
<li>如果需要保证线程安全，ArrayList应该如何做？（以下方式基于JDK8实现）<ul>
<li>方式一：Collections.synchronizedList(new ArrayList&lt;&gt;()); 使用synchronized加锁</li>
<li>方式二：new CopyOnWriteArrayList&lt;&gt;(); 使用ReentrantLock加锁</li>
<li>方式三：自己写个包装类，根据业务一般是add/update/remove加锁</li>
</ul>
</li>
</ul>
<h2 id="3、CopyOnWriteArrayList"><a href="#3、CopyOnWriteArrayList" class="headerlink" title="3、CopyOnWriteArrayList"></a>3、CopyOnWriteArrayList</h2><p><strong>简介：基于CopyOnWriteArrayList进行追问</strong></p>
<ul>
<li>考点：CopyOnWriteArrayList的掌握情况（追问系列）</li>
<li>了解CopyOnWriteArrayList吗？和Collections.synchronizedList实现线程安全有什么区别？使用场景是怎样的？<ul>
<li>CopyOnWriteArrayList：执行修改操作时，会拷贝一份新的数组进行操作（add、set、remove等），代价很高，在执行完修改后将原来集合指向新的集合来完成修改操作，源码里的ReentrantLock可重入锁来保证不会有多个线程同时拷贝一份数组<ul>
<li>场景：适用于读多写少的并发场景（读操作不需要加锁）</li>
</ul>
</li>
<li>Collections.synchronizedList：线程安全的原因是因为它几乎在每个方法中都使用了synchronized同步锁<ul>
<li>场景：写操作性能比CopyOnWriteArrayList好，但是读操作性能不如CopyOnWriteArrayList</li>
</ul>
</li>
</ul>
</li>
<li>CopyOnWriteArrayList的设计思想是怎样的？有什么缺点？<ul>
<li>设计思想：读写分离+最终一致性</li>
<li>缺点：内存占用问题，写时复制机制，内存里面会同时驻扎两个对象的内存（旧的对象和新写入的对象），如果对象过大则容易发生Young GC和Full GC</li>
</ul>
</li>
</ul>
<h2 id="4、List集合扩容机制"><a href="#4、List集合扩容机制" class="headerlink" title="4、List集合扩容机制"></a>4、List集合扩容机制</h2><p><strong>简介：基于List进行追问，扩容机制</strong></p>
<ul>
<li>考点：List集合扩容机制</li>
<li>说下List的扩容机制是怎样的？<ul>
<li>扩容可分为两种情况：<ul>
<li>第一种情况，当ArrayList的容量为0时，此时添加元素的话，需要扩容，三种构造方法创建的ArrayList在扩容时略有不同：<ol>
<li>无参构造，创建ArrayList后容量为0，添加第一个元素后，容量变为10，此后若需要扩容，则正常扩容。</li>
<li>传容量构造，当参数为0时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</li>
<li>传列表构造，当列表为空时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</li>
</ol>
</li>
<li>第二种情况，当ArrayList的容量大于0，并且ArrayList已满的时候，此时添加元素的话，进行正常扩容，每次扩容到原来的1.5倍。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5、手写ArrayList（上）"><a href="#5、手写ArrayList（上）" class="headerlink" title="5、手写ArrayList（上）"></a>5、手写ArrayList（上）</h2><p><strong>简介：基于List进行追问，代码实战</strong></p>
<ul>
<li><p>考点：源码设计思想、代码编写规范</p>
</li>
<li><p>设计一个简单的ArrayList【需要包含 构造函数(无参和有参)、add(e)、 扩容机制】</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//判断当前集合类是否被并发修改，即迭代器并发修改的fail-fast机制</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-built_in">int</span> modCount = <span class="hljs-number">0</span>;<br>  <br>   <span class="hljs-comment">//默认的容量大小（常量）</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br>  <br>   <span class="hljs-comment">//定义的空数组（final修饰，大小固定为0）</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span>[] EMPTY_ELEMENTDATA = &#123;&#125;;<br>  <br>   <span class="hljs-comment">//定义的不可被序列化的数组，实际存储元素的数组</span><br>   <span class="hljs-keyword">transient</span> <span class="hljs-keyword">Object</span>[] elementData;<br>  <br>   <span class="hljs-comment">//数组中元素的个数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>;<br>  <br>   <span class="hljs-keyword">public</span> MyArrayList() &#123;<br>       <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>   &#125;<br>  <br>   <span class="hljs-keyword">public</span> MyArrayList(<span class="hljs-built_in">int</span> initialCapacity) &#123;<br>       <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[initialCapacity];<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数异常&quot;</span>);<br>       &#125;<br>   &#125;<br>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-built_in">add</span>(<span class="hljs-keyword">Object</span> e) &#123;<br>       <span class="hljs-comment">//判断容量</span><br>       ensureCapacityInternal(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>);<br>       <span class="hljs-comment">//使用下标赋值，尾部插入</span><br>       elementData[<span class="hljs-built_in">size</span>++] = e;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br>  <br>   <span class="hljs-comment">//计算容量+确保容量</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ensureCapacityInternal(<span class="hljs-built_in">int</span> minCapacity) &#123;<br>       <span class="hljs-comment">//用于并发判断</span><br>       modCount++;<br>  <br>       <span class="hljs-comment">//如果是初次扩容，则使用默认的容量</span><br>       <span class="hljs-keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<br>           minCapacity = Math.<span class="hljs-built_in">max</span>(DEFAULT_CAPACITY, minCapacity);<br>       &#125;<br>       <span class="hljs-comment">//判断是否需要扩容，所需的最少容量 大于 现在数组的长度 则需要扩容</span><br>       <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">int</span> oldCapacity = elementData.length;<br>           <span class="hljs-built_in">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>           <span class="hljs-comment">//如果新容量 &lt; 所需最小容量 ，则所需最小容量赋给新容量</span><br>           <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>               newCapacity = minCapacity;<br>           &#125;<br>           <span class="hljs-comment">//创建数组</span><br>           <span class="hljs-keyword">Object</span>[] objects = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[newCapacity];<br>           <span class="hljs-comment">//将旧的数组拷贝到新的数组中</span><br>           System.arraycopy(elementData, <span class="hljs-number">0</span>, objects, <span class="hljs-number">0</span>, elementData.length);<br>           <span class="hljs-comment">//修改引用</span><br>           elementData = objects;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6、手写ArrayList（下）"><a href="#6、手写ArrayList（下）" class="headerlink" title="6、手写ArrayList（下）"></a>6、手写ArrayList（下）</h2><p><strong>简介：基于List进行追问，代码实战</strong></p>
<ul>
<li><p>考点：源码设计思想、代码编写规范</p>
</li>
<li><p>设计一个简单的ArrayList【remove(index)、get(index) 、indexOf(o) ,set(int index,Object o)】</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">private <span class="hljs-type">void</span> range<span class="hljs-keyword">Check</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &gt; size || <span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span>) &#123;<br>           throw <span class="hljs-built_in">new</span> IndexOutOfBoundsException(&quot;数组越界&quot;);<br>       &#125;<br>   &#125;<br>  <br>   //根据索引删除元素<br>   <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>       range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br>  <br>       //用于并发判断<br>       modCount++;<br>  <br>       <span class="hljs-keyword">Object</span> oldValue = elementData[<span class="hljs-keyword">index</span>];<br>       //计算要删除的位置后面还有多少个元素<br>       <span class="hljs-type">int</span> numMoved = size - <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">System</span>.arraycopy(elementData, <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>, elementData, <span class="hljs-keyword">index</span>, numMoved);<br>       &#125;<br>       //将多出的位置设置为空，没有引用对象，GC可以回收，如果不为空，将多保存一个引用，可能会造成内存泄露<br>       elementData[<span class="hljs-comment">--size] = null;</span><br>       <span class="hljs-keyword">return</span> oldValue;<br>   &#125;<br>  <br>   //通过索引获取对象<br>   <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>       range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br>       <span class="hljs-keyword">return</span> elementData[<span class="hljs-keyword">index</span>];<br>   &#125;<br>  <br>   //判断对象所在的位置<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> indexOf(<span class="hljs-keyword">Object</span> o) &#123;<br>       <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>               <span class="hljs-keyword">if</span> (elementData[i] == <span class="hljs-keyword">null</span>) &#123;<br>                   <span class="hljs-keyword">return</span> i;<br>               &#125;<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>               <span class="hljs-keyword">if</span> (o.equals(elementData[i])) &#123;<br>                   <span class="hljs-keyword">return</span> i;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br>  <br>   //根据索引修改元素<br>   <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">set</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-keyword">Object</span> e) &#123;<br>       range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br>       <span class="hljs-keyword">Object</span> oldValue = elementData[<span class="hljs-keyword">index</span>];<br>       elementData[<span class="hljs-keyword">index</span>] = e;<br>       <span class="hljs-keyword">return</span> oldValue;<br>   &#125;<br>   <br>   //获取数组实际大小<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> size() &#123;<br>       <span class="hljs-keyword">return</span> this.size;<br>   &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="四、Java集合Map"><a href="#四、Java集合Map" class="headerlink" title="四、Java集合Map"></a>四、Java集合Map</h1><h2 id="1、Java集合Map基础（上）"><a href="#1、Java集合Map基础（上）" class="headerlink" title="1、Java集合Map基础（上）"></a>1、Java集合Map基础（上）</h2><p><strong>简介：Java集合Map常见基础面试题</strong></p>
<ul>
<li>考点：Map相关基础知识掌握情况</li>
<li>了解Map吗？用过哪些Map的实现？<ul>
<li>HashMap、Hashtable、TreeMap、LinkedHashMap、ConcurrentHashMap</li>
</ul>
</li>
<li>说下HashMap和Hashtable的区别？<ul>
<li>HashMap：底层是基于<strong>数组+链表+[ JDK8 红黑树]</strong>，非线程安全，默认容量是16，允许有null的键和值</li>
<li>Hashtable：底层是基于哈希表，线程安全（加了synchronized），默认容量是11，不允许有null的键和值</li>
</ul>
</li>
</ul>
<h2 id="2、hashCode和equals"><a href="#2、hashCode和equals" class="headerlink" title="2、hashCode和equals"></a>2、hashCode和equals</h2><p><strong>简介：在对象的比较、排重中hashcode和equals经常需要重写，也是map和set里面常用知识</strong></p>
<ul>
<li><p>考点：hashcode和equals掌握情况</p>
</li>
<li><p>介绍下对象的hashCode()和equals()，使用场景？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php">hashcode<br>	顶级类<span class="hljs-keyword">Object</span>里面的方法，所有的类都是继承<span class="hljs-keyword">Object</span>,返回是一个<span class="hljs-keyword">int</span>类型的数值<br>	根据一定的hash规则(存储地址，字段，长度等)，映射成一个数值，即散列值<br><br>equals<br>	顶级类<span class="hljs-keyword">Object</span>里面的方法，所有的类都是继承<span class="hljs-keyword">Object</span>,返回是一个<span class="hljs-keyword">boolean</span>类型<br>	根据自定义的匹配规则，用于匹配两个对象是否一样，一般逻辑如下<br>    <span class="hljs-comment">//判断地址是否一样</span><br>    <span class="hljs-comment">//非空判断和Class类型判断</span><br>    <span class="hljs-comment">//强转</span><br>    <span class="hljs-comment">//对象里面的字段一一匹配</span><br>    <br>使用场景：对象比较、或者集合容器里面排重、比较、排序<br></code></pre></td></tr></table></figure>
</li>
<li><p>代码实战：编写一个User对象，重写hashcode和equals方法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">private</span> int age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Date</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setAge</span>(<span class="hljs-params">int age</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Date</span> <span class="hljs-function"><span class="hljs-title">getTime</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">Date</span> time</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.time = time;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age, time);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        User user = (User) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(name, user.name) &amp;&amp; age == user.age &amp;&amp; Objects.equals(time, user.time);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3、Java集合Map基础（下）"><a href="#3、Java集合Map基础（下）" class="headerlink" title="3、Java集合Map基础（下）"></a>3、Java集合Map基础（下）</h2><p><strong>简介：Java集合Map常见基础面试题</strong></p>
<ul>
<li><p>考点：Map相关基础知识掌握情况</p>
</li>
<li><p>HashMap和TreeMap之间如何选择？使用场景？</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">HashMap:</span> 散列桶(数组+链表+[JDK8红黑树])，可以实现快速的存储和检索，但缺点是包含无序的元素，适用于在Map中插入、删除和定位元素<br><br><span class="hljs-symbol">TreeMap:</span>使用存储结构是一个平衡二叉树-&gt;红黑树，可以自定义排序规则，向TreeMap的构造方法中传入Comparator对象来覆盖元素的默认排序规则<br>能便捷的实现内部元素的各种排序，但是性能一般比HashMap差，适用于自然排序或者自定义排序<br>(微信支付签名工具类就用TreeMap这个类)<br></code></pre></td></tr></table></figure>
</li>
<li><p>Set和Map的关系</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">核心是不会保存重复的元素，存储一组唯一的对象<br><br><span class="hljs-built_in">Set</span>的每一种实现都是对应<span class="hljs-built_in">Map</span>里面的一种封装<br><br>HashSet对应的就是HashMap<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashSet</span>(<span class="hljs-params"></span>)</span> &#123;<br>	map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br><br>TreeSet对应的就是TreeMap<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">TreeSet</span>(<span class="hljs-params"></span>)</span> &#123;<br>	<span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,<span class="hljs-built_in">Object</span>&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>常见Map的排序规则是怎样的？</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">添加顺序：<span class="hljs-variable">LinkedHashMap</span><br>自然排序：<span class="hljs-variable">TreeMap</span><br>自定义排序：<span class="hljs-function"><span class="hljs-title">TreeMap</span>(<span class="hljs-variable">Comparator</span> <span class="hljs-variable">comparator</span>)</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4、Java集合Map进阶"><a href="#4、Java集合Map进阶" class="headerlink" title="4、Java集合Map进阶"></a>4、Java集合Map进阶</h2><p><strong>简介：Java集合Map面试题进阶</strong></p>
<ul>
<li>考点：Map基础知识点的进阶</li>
<li>如果需要线程安全，且效率高的Map，应该如何做？<ul>
<li>方式一：concurrent包下的ConcurrentHashMap，不仅满足线程安全而且效率比Hashtable高</li>
<li>方式二：Collections.synchronizedMap(new HashMap&lt;&gt;());包装后返回的map是加了互斥锁的</li>
</ul>
</li>
</ul>
<h2 id="5、HashMap（上）"><a href="#5、HashMap（上）" class="headerlink" title="5、HashMap（上）"></a>5、HashMap（上）</h2><p><strong>简介：深入底层HashMap实现原理</strong></p>
<ul>
<li><p>考点：是否掌握HashMap的底层实现</p>
</li>
<li><p>介绍下HashMap的工作原理？</p>
<p>HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry接口）实现，HashMap 通过 put &amp; get 方法存储和获取。</p>
<p>存储对象时，将 K/V 键值传给 put() 方法：</p>
<p>①、<br>调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；</p>
<p>②、<br>调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；</p>
<p>③、<br>i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；</p>
<p>ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；</p>
<p>iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。</p>
<p>（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）</p>
<p>获取对象时，将 K 传给 get() 方法：<br>①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；<br>②、顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。</p>
<p>hashCode是定位的，存储位置；equals是定性的，比较两者是否相等。</p>
</li>
</ul>
<p>  HashMap调用Put(K key,V value)添加一个键值对的具体过程如下图所示：</p>
<p>  <img src="后端面试/image-1.png" srcset="/img/loading.gif" lazyload alt="image-1"></p>
<p>  说明：</p>
<ol>
<li>size表示HashMap中K-V的实际数量，注意这个size不是数组的长度</li>
<li>threshold（临界值）= capacity（容量）* loadFactor（加载因子）这个值是当前已经占用数组长度的最大值，size超过这个临界值就会重新 resize()扩容 ，扩容后的HashMap容量是之前的2倍</li>
</ol>
<ul>
<li><p>能否解释下什么是Hash碰撞？常见的解决办法有哪些，HashMap采用哪种方法？</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Hash</span>碰撞：两个不同的<span class="hljs-built_in">Key</span>值经过计算后，得到的<span class="hljs-built_in">Hash</span>值相同，要放到相同的<span class="hljs-variable">bucket</span>中<br><br>解决方法：拉链法、开放地址法、再哈希法<br><br><span class="hljs-variable">HashMap</span>采用的拉链法<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6、HashMap（下）"><a href="#6、HashMap（下）" class="headerlink" title="6、HashMap（下）"></a>6、HashMap（下）</h2><p><strong>简介：深入底层HashMap实现原理</strong></p>
<ul>
<li><p>考点：是否掌握HashMap的底层实现</p>
</li>
<li><p>为什么HashMap底层要采用 数组+链表+红黑树</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">数组：<span class="hljs-variable">transient</span> <span class="hljs-variable">Node</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span><span class="hljs-variable">V</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">table</span><span class="hljs-operator">;</span>根据对象的<span class="hljs-variable">key</span>的<span class="hljs-variable">hash</span>值确定对象在哪个<span class="hljs-variable">bucket</span><br>链表：解决<span class="hljs-built_in">Hash</span>冲突，将<span class="hljs-built_in">Hash</span>值一样的对象存在一个链表中<br>红黑树：当位于同一个链表中的元素较多，即<span class="hljs-variable">hash</span>值相等的元素较多时，通过<span class="hljs-variable">key</span>值在链表中依次查找的效率很低。因此引入红黑树是为了提升查询效率，从原来的<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>到<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">logn</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树而是当长度达到8才开始？<ul>
<li>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</li>
<li>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</li>
</ul>
</li>
</ul>
<h2 id="7、ConcurrentHashMap"><a href="#7、ConcurrentHashMap" class="headerlink" title="7、ConcurrentHashMap"></a>7、ConcurrentHashMap</h2><p><strong>简介：并发包里面ConcurrentHashMap面试题</strong></p>
<ul>
<li><p>考点：是否掌握并发包下的ConcurrentHashMap基础和原理</p>
</li>
<li><p>为什么 ConcurrentHashMap 比 HashTable 效率要高？</p>
<ul>
<li>HashTable：<ul>
<li>使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞</li>
</ul>
</li>
<li>ConcurrentHashMap：<ul>
<li>JDK1.7版本：ConcurrentHashMap的数据结构是由 Segment数组+HashEntry数组+链表组成。对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。Segment类继承ReentrantLock来保证线程安全。</li>
<li>JDK1.8版本：摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用CAS（读）和synchronized（写）来操作，锁粒度更细。</li>
</ul>
</li>
</ul>
</li>
<li><p>ConcurrentHashMap的put的核心逻辑（JDK8以上版本）</p>
<p><img src="后端面试/image-2.png" srcset="/img/loading.gif" lazyload alt="image-2"></p>
</li>
</ul>
<h1 id="五、并发编程基础"><a href="#五、并发编程基础" class="headerlink" title="五、并发编程基础"></a>五、并发编程基础</h1><h2 id="1、进程、线程、协程"><a href="#1、进程、线程、协程" class="headerlink" title="1、进程、线程、协程"></a>1、进程、线程、协程</h2><p><strong>简介：是否掌握进程、线程、协程的区别</strong></p>
<ul>
<li><p>考点：是否掌握进程、线程、协程的区别</p>
</li>
<li><p>能否解释下什么是否掌握进程、线程、协程之间有什么联系和区别？</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">进程：进程是计算机中已运行程序的实体，是操作系统资源分配的最小单位<br><br>线程：线程是在进程中执行的一个任务，是<span class="hljs-variable">CPU</span>调度和执行的最小单位<br><br>协程：又称为微线程，是一种用户态的轻量级线程，协程不像线程和进程需要进行系统内核上的上下文切换，协程的上下文切换是由用户自己决定的，有自己的上下文，所以说是轻量级的线程，协程也称之为用户级别的线程，一个线程可以多个协程<span class="hljs-operator">,</span>线程进程都是同步机制，而协程则是异步<br><br>联系：一个进程至少有一个线程，一个进程可以有多个线程，多个线程可共享数据。<br><br>区别：进程和线程的本质区别在于是否单独占有内存地址空间及其它系统资源（比如<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>）<br>		进程单独占有一定的内存地址空间；线程共享所属进程占有的内存地址空间和资源<br></code></pre></td></tr></table></figure>
</li>
<li><p>协程对于多线程的优缺点是什么？</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">优点：<br>    非常快速的上下文切换，不用系统内核的上下文切换，减小开销<br>    单线程即可实现高并发，单核CPU可以支持上万的协程<br>    由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁<br>缺点：<br>    协程无法利用多核资源，本质也是个单线程<br>    协程需要和进程配合才能运行在多CPU上<br>    目前<span class="hljs-keyword">java没成熟的第三方库，存在风险</span><br><span class="hljs-keyword"></span>    调试<span class="hljs-built_in">debug</span>存在难度，不利于发现问题<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2、并发、并行、串行"><a href="#2、并发、并行、串行" class="headerlink" title="2、并发、并行、串行"></a>2、并发、并行、串行</h2><p><strong>简介：是否知道并发、并行、串行的区别</strong></p>
<ul>
<li><p>考点：计算机基础中并发、并行、串行的概念</p>
</li>
<li><p>说下并发、并行、串行的区别，最好举例说明</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">并发：多个任务在同一个CPU核上，按细分的时间片段轮流（交替）执行，从逻辑上来看那些任务是“同时进行”。【两个人用一台电脑】<br><br>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。【两个人分配了两台电脑】<br><br>串行：有<span class="hljs-built_in">n</span>个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全的情况，也就不存在临界区的问题。【两个人排队使用一台电脑】<br></code></pre></td></tr></table></figure>
<p><img src="后端面试/image-3.png" srcset="/img/loading.gif" lazyload alt="image-3"></p>
</li>
</ul>
<h2 id="3、Java多线程的实现方式"><a href="#3、Java多线程的实现方式" class="headerlink" title="3、Java多线程的实现方式"></a>3、Java多线程的实现方式</h2><p><strong>简介：Java多线程的实现方式和区别</strong></p>
<ul>
<li><p>考点：Java多线程基础知识</p>
</li>
<li><p>Java里面实现多线程有哪几种方式，比较常用的是哪些？</p>
<ol>
<li><p>继承Thread类</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Thread类本质上也是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start<span class="hljs-literal">()</span>方法。start<span class="hljs-literal">()</span>方法是一个native方法，它将启动一个新线程，并执行run<span class="hljs-literal">()</span>方法<br>优点：代码编写简单直接操作<br>缺点：没返回值，继承一个类后，没法继承其他的类，拓展性差<br><br>public <span class="hljs-keyword">class</span> ThreadDemo01 extends Thread&#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;继承Thread类实现多线程，线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>&#125;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    ThreadDemo01 threadDemo01 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo01()</span>;<br>    threadDemo01.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;demo01&quot;</span>)</span>;<br>    threadDemo01.start<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口<strong>【常用】</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">实现Runnable接口并实现其中的run<span class="hljs-literal">()</span>方法，然后通过构造Thread实例，传入Runnable实现类，然后调用Thread的start<span class="hljs-literal">()</span>方法即可开启一个新线程<br>优点：线程类可以实现多个接口，可以再继承一个类<br>缺点：没返回值，不能直接启动，需要通过构造一个Thread实例再传入Runnable实现类进去启动<br><br>public <span class="hljs-keyword">class</span> ThreadDemo02 implements Runnable&#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;实现Runnable接口实现多线程，线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>&#125;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    ThreadDemo02 threadDemo02 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo02()</span>;<br>    Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">threadDemo02</span>)</span>;<br>    thread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;demo02&quot;</span>)</span>;<br>    thread.start<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>匿名内部类</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">JDK8之后采用lambda表达式<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>	Thread thread = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		System.out.println(<span class="hljs-string">&quot;匿名内部类实现多线程，线程名称：&quot;</span> + Thread.currentThread().getName());</span></span><br><span class="hljs-params"><span class="hljs-function">	&#125;)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">thread</span>.<span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-string">&quot;demo03&quot;</span>)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">thread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;主线程名称：&quot;</span> + Thread.currentThread().getName())</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>实现Callable接口通过FutureTask包装器</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs livescript">首先需要一个实现Callable接口的实例，然后实现该接口的唯一方法call逻辑，接着把Callable实例包装成FutureTask传递给Thread实例启动新线程。FutureTask本质上也实现了Runnable接口，所以同样可以用来构造Thread实例。<br>优点：有返回值，拓展性高<br>缺点：JDK5以后才支持，需要重写call方法，结合多个类比如FutureTask和Thread类<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-title">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Object</span>&gt; &#123;</span><br>    @Override<br>    public <span class="hljs-built_in">Object</span> call() throws Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;实现Callable接口实现多线程，线程名称：&quot;</span>+Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是返回值&quot;</span>;<br>    &#125;<br>&#125;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br><br>	<span class="hljs-regexp">// MyTask myTask = new MyTask();</span><br><span class="hljs-regexp">	//</span> FutureTask&lt;<span class="hljs-built_in">Object</span>&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myTask);<br><br>	FutureTask&lt;<span class="hljs-built_in">Object</span>&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		System.out.println(<span class="hljs-string">&quot;实现Callable接口实现多线程，线程名称：&quot;</span> + Thread.currentThread().getName());</span></span><br><span class="hljs-params"><span class="hljs-function">		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是返回值&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">	&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">	<span class="hljs-title">Thread</span> <span class="hljs-title">thread</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(futureTask)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">thread</span>.<span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-string">&quot;demo04&quot;</span>)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">thread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;主线程名称：&quot;</span> + Thread.currentThread().getName())</span>;</span><br><span class="hljs-function">	<span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">		<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(futureTask.get())</span>;</span><br><span class="hljs-function">	&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">        //阻塞等待中被中断，则抛出</span><br><span class="hljs-function">        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(ExecutionException e)</span> &#123;</span><br><span class="hljs-function">        //执行过程发送异常被抛出</span><br><span class="hljs-function">        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>通过线程池<strong>【常用】</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">自定义Runnable接口，实现run方法，创建线程池，调用执行方法并传入对象<br>优点：安全、性能高，因为复用了线程<br>缺点：JDK5以后才支持，需要结合Runnable进行使用<br><br>public <span class="hljs-keyword">class</span> ThreadDemo05 implements Runnable&#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;通过线程池实现多线程，线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>&#125;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>	ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(3)</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>		executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo05()</span>);<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    <span class="hljs-comment">//关闭线程池</span><br>    executorService.shutdown<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="4、Java线程的状态"><a href="#4、Java线程的状态" class="headerlink" title="4、Java线程的状态"></a>4、Java线程的状态</h2><p><strong>简介：线程有几种状态有哪些，分别解释下</strong></p>
<ul>
<li><p>考点：是否掌握线程常见的状态</p>
</li>
<li><p>操作系统中的线程状态有哪些？</p>
<ol>
<li><strong>新建状态 NEW</strong>: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</li>
<li><strong>就绪状态 RUNNABLE</strong>: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li>
<li><strong>运行状态: RUNNING</strong> 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li>
<li><strong>阻塞状态: BLOCKED</strong>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，该线程会释放占⽤的所有资源，JVM会把该线程放入“等待池”中。进⼊这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被 唤醒，wait是object类的方法</li>
<li>同步阻塞：线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)，则JVM会把该线程放入“锁池”中。</li>
<li>其他阻塞：运⾏的线程执行 sleep() 或 join() 发出了 I/O请求时，JVM会把该线程置为阻塞状 态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态，sleep是Thread类的方法。</li>
</ul>
</li>
<li><strong>死亡状态: TERMINATED</strong> 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li>
</ol>
<p><img src="后端面试/image-4.png" srcset="/img/loading.gif" lazyload alt="image-4"></p>
</li>
<li><p>Java中Thread对象的状态有哪些？</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">public enum State &#123;<br>    NEW,<span class="hljs-regexp">//</span>新建态<br>    RUNNABLE,<span class="hljs-regexp">//</span>运行态<br>    BLOCKED,<span class="hljs-regexp">//</span>阻塞态<br>    WAITING,<span class="hljs-regexp">//</span>等待态<br>    TIMED_WAITING,<span class="hljs-regexp">//</span>有时间限制的等待态<br>    TERMINATED;<span class="hljs-regexp">//</span>死亡态<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="后端面试/image-5.png" srcset="/img/loading.gif" lazyload alt="image-5"></p>
</li>
</ul>
<ol>
<li><p>NEW 新建态：</p>
<p>处于NEW状态的线程此时尚未启动，还没调用Thread实例的start()方法。</p>
</li>
<li><p>RUNNABLE 运行态：</p>
<p>表示当前线程正在运行中。处于RUNNABLE状态的线程可能在Java虚拟机中运行，也有可能在等待其他系统资源（比如I/O）。</p>
<p>Java线程的<strong>RUNNABLE</strong>状态其实是包括了传统操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态的</p>
</li>
<li><p>BLOCKED 阻塞态：</p>
<p>线程没有申请到synchronize同步锁，就会处于阻塞状态，等待锁的释放以进入同步区。</p>
</li>
<li><p>WAITING 等待态：处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</p>
<p>调用如下3个方法会使线程进入等待状态：</p>
<ul>
<li>Object.wait()：使当前线程处于等待状态直到另一个线程调用notify唤醒它；</li>
<li>Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait()方法；</li>
<li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。</li>
</ul>
</li>
<li><p>TIMED_WAITING 超时等待态：</p>
<p>线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li>
<li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li>
<li>Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li>
<li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li>
<li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li>
</ul>
</li>
<li><p>TERMINATED 终止：</p>
<p>此时线程已执行完毕。</p>
</li>
</ol>
<h2 id="5、Java线程的常见方法"><a href="#5、Java线程的常见方法" class="headerlink" title="5、Java线程的常见方法"></a>5、Java线程的常见方法</h2><p><strong>简介：Java线程常见的方法</strong></p>
<ul>
<li><p>考点：常见线程的API操作是否熟悉</p>
</li>
<li><p>是否了解多线程开发里面常用的方法，sleep/yield/join wait/notify/notifyAll, 分别解释下</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">sleep</span><br>	属于线程Thread的方法<br>	让线程暂缓执行，等待时间结束后再恢复<br>	交出CPU使用权，不会释放锁<br>	进入阻塞状态TIMED_WAITING，睡眠结束后变为就绪状态RUNNABLE<br>	<br>yield<br>	属于线程Thread的方法<br>	暂停当前线程的对象，去执行其他线程<br>	交出CPU使用权，不会释放锁，和<span class="hljs-keyword">sleep</span>类似<br>	让相同优先级的线程轮流执行，但是不保证每个线程都一定能轮到<br>	不会让线程进入阻塞状态，而是直接变为就绪状态，但是保留了CPU的执⾏资格，所以有可能cpu下次进⾏线程调度还会让这个线程获取到执⾏权继续执⾏<br><br><span class="hljs-keyword">join</span><br>	属于线程Thread的方法<br>	在主线程上运行调用该方法，会让主线程休眠，不会释放已经持有的对象锁<br>	让调用<span class="hljs-keyword">join</span>方法的线程先执行完毕，再执行其他线程<br>	类似让救护车、警车优先通行<br>	<br><span class="hljs-keyword">wait</span><br>	属于Object的方法<br>	当前线程调用对象的<span class="hljs-keyword">wait</span>方法，会释放锁，进入线程的等待队列<br>	需要依靠notify、notifyAll唤醒，或者<span class="hljs-keyword">wait</span>(timeout)自动唤醒<br>	<br>notify<br>	属于Object的方法<br>	唤醒在对象监视器上等待的单个线程，选择是任意的<br><br>notifyAll<br>	属于Object的方法<br>	唤醒在对象监视器上等待的全部线程<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6、Java线程的转换流程图"><a href="#6、Java线程的转换流程图" class="headerlink" title="6、Java线程的转换流程图"></a>6、Java线程的转换流程图</h2><p><strong>简介：线程有几种状态和API，画出转换流程图</strong></p>
<ul>
<li><p>考点：常见线程状态和API结合考查</p>
</li>
<li><p>画下线程的状态转换图和这些转换过程常用的api也标记下</p>
<p><img src="后端面试/image-6.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
</ul>
<h2 id="7、Java并发编程核心知识点（一）"><a href="#7、Java并发编程核心知识点（一）" class="headerlink" title="7、Java并发编程核心知识点（一）"></a>7、Java并发编程核心知识点（一）</h2><p><strong>简介：并发编程常见知识点考查</strong></p>
<ul>
<li><p>考点：并发编程常见知识点考查</p>
</li>
<li><p>平时业务代码里面使用过多线程吗，能举例几个多线程的业务场景吗？</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">异步任务：用户注册、记录日志<br>定时任务：定时备份日志、备份数据库<br>分布式计算：Hadoop处理任务MapReduce，<span class="hljs-literal">master</span>-worker<br>服务器编程：Socket网络编程，一个连接一个线程<br></code></pre></td></tr></table></figure>
</li>
<li><p>你知道有哪些非线程安全的数据结构吗？</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">HashMap</span>、ArrayList、LinkedList<br></code></pre></td></tr></table></figure>
</li>
<li><p>在Java中有哪些方法可以用来保证线程安全？</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">加锁：<span class="hljs-keyword">synchronized</span>、ReentrantLock<br>使用线程安全类（原子类AtomicXXX、并发容器、同步容器）CopyOnWriteArrayList/ConcurrentHashMap等<br>ThreadLocal本地私有变量/信号量Semaphore等<br>使用<span class="hljs-keyword">volatile</span>声明变量（要使 <span class="hljs-keyword">volatile</span> 变量提供理想的线程安全性，必须同时满足两个条件：①对变量的写操作不依赖于当前值。②该变量没有包含在具有其他变量的不变式中。）<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="8、Java并发编程核心知识点（二）"><a href="#8、Java并发编程核心知识点（二）" class="headerlink" title="8、Java并发编程核心知识点（二）"></a>8、Java并发编程核心知识点（二）</h2><p><strong>简介：并发编程常见知识点考查</strong></p>
<ul>
<li><p>考点：并发编程常见知识点考查</p>
</li>
<li><p>了解volatile关键字不？能否解释下它和synchronized有什么大的区别？</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">volatile</span>是轻量级的<span class="hljs-keyword">synchronized</span>，保证被<span class="hljs-keyword">volatile</span>修饰的共享变量对所有线程总是可⻅的（可见性），也就是当⼀个线程修改了⼀个被<span class="hljs-keyword">volatile</span>修饰共享变量的值，新值总是可以被其他线程⽴即得知，避免出现脏读现象。<br><br><span class="hljs-keyword">volatile</span>：保证可见性，但不能保证原子性<br><span class="hljs-keyword">synchronized</span>：保证可见性，也保证原子性<br><br>使用场景：<br><span class="hljs-number">1</span>、不能修饰写入操作依赖当前值的变量；比如num++、num=num+<span class="hljs-number">1</span>，不是原子操作，虽然肉眼看上去是，但在JVM字节码层面不是原子操作<br><span class="hljs-number">2</span>、由于禁止了指令重排，所以JVM相关的优化没有了，效率会偏弱<br></code></pre></td></tr></table></figure>
</li>
<li><p>为什么会出现脏读现象？</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JAVA内存模型简称JMM</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">JMM规定所有的变量存在主内存中，每个线程都有自己的工作内存,线程对变量的操作都在工作内存中进行，不能直接对主内存就行操作</span><br><span class="hljs-keyword"></span><br>使用volatile修饰变量<br>每次读取前必须从主内存获取到最新的值<br>每次写入需要立刻写到主内存中<br></code></pre></td></tr></table></figure>
<p><img src="后端面试/image-7.png" srcset="/img/loading.gif" lazyload alt="image-7"></p>
</li>
</ul>
<h2 id="9、Java并发编程核心知识点（三）"><a href="#9、Java并发编程核心知识点（三）" class="headerlink" title="9、Java并发编程核心知识点（三）"></a>9、Java并发编程核心知识点（三）</h2><p><strong>简介：并发编程常见知识点考查：指令重排、happens-before</strong></p>
<ul>
<li><p>考点：并发编程常见知识点考查</p>
</li>
<li><p>你说volatile可以避免指令重排，能否解释下什么是指令重排？</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">指令重排序分两类：编译器重排序、运行时重排序<br><br>JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(在不改变程序结果的前提下)<br><br>例子：<br><span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span> <span class="hljs-comment">//1</span><br><span class="hljs-built_in">int</span> b = <span class="hljs-number">4</span> <span class="hljs-comment">//2</span><br><span class="hljs-built_in">int</span> c =<span class="hljs-number">5</span> <span class="hljs-comment">//3 </span><br><span class="hljs-built_in">int</span> h = a*b*c <span class="hljs-comment">//4</span><br><br>定义顺序 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span><br>计算顺序 <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span> 和 <span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> 结果都是一样<br><br>虽然指令重排序可以提高执行效率，但是多线程上可能会影响结果，有什么解决办法？<br><br>解决办法：内存屏障<br>解释：内存屏障就是一类同步屏障指令，是CPU或者编译器在对内存随机访问的操作中的一个同步点，只有在此点之前的所有读写操作都执行后才可以执行此点之后的操作<br></code></pre></td></tr></table></figure>
</li>
<li><p>知道 happens-before吗，能否简单解释下？</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">先行发生原则，<span class="hljs-variable">volatile</span>的内存可见性就提现了该原则之一<br><br>例子：<br><span class="hljs-operator">//</span>线程<span class="hljs-variable">A</span>操作<br><span class="hljs-variable">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br><br><span class="hljs-operator">//</span>线程<span class="hljs-variable">B</span>操作<br><span class="hljs-variable">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-variable">k</span><span class="hljs-operator">;</span><br><br><span class="hljs-operator">//</span>线程<span class="hljs-built_in">C</span>操作<br><span class="hljs-variable">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><br>分析：<br>假设线程<span class="hljs-variable">A</span>中的操作“<span class="hljs-variable">k</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>”先行发生于线程<span class="hljs-variable">B</span>的操作“<span class="hljs-variable">j</span><span class="hljs-operator">=</span><span class="hljs-variable">k</span>”，那确定在线程<span class="hljs-variable">B</span>的操作执行后，变量<span class="hljs-variable">j</span>的值一定等于<span class="hljs-number">1</span>，依据有两个：一是先行发生原则，“<span class="hljs-variable">k</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>”的结果可以被观察到；二是第三者线程<span class="hljs-built_in">C</span>还没出现，线程<span class="hljs-variable">A</span>操作结束之后没有其他线程会修改变量<span class="hljs-variable">k</span>的值。<br><br>但是考虑线程<span class="hljs-built_in">C</span>出现了，保持线程<span class="hljs-variable">A</span>和线程<span class="hljs-variable">B</span>之间的先行发生关系，线程<span class="hljs-built_in">C</span>出现在线程<span class="hljs-variable">A</span>和线程<span class="hljs-variable">B</span>的操作之间，但是线程<span class="hljs-built_in">C</span>与线程<span class="hljs-variable">B</span>没有先行发生关系，那<span class="hljs-variable">j</span>的值会是多少？答案是<span class="hljs-number">1</span>和<span class="hljs-number">2</span>都有可能，因为线程<span class="hljs-built_in">C</span>对变量<span class="hljs-variable">k</span>的影响可能会被线程<span class="hljs-variable">B</span>观察到，也可能不会，所以线程<span class="hljs-variable">B</span>就存在读取到不符合预期数据的风险，不具备多线程安全性<br><br>先行发生的八大原则：<br><span class="hljs-number">1</span>、程序次序规则（<span class="hljs-variable">Program</span> <span class="hljs-built_in">Order</span> <span class="hljs-built_in">Rule</span>）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作；<br><span class="hljs-number">2</span>、管程锁定规则（<span class="hljs-built_in">Monitor</span> <span class="hljs-variable">Lock</span> <span class="hljs-built_in">Rule</span>）：一个<span class="hljs-variable">unlock</span>操作先行发生于后面对同一个锁的<span class="hljs-variable">lock</span>操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后；<br><span class="hljs-number">3</span>、<span class="hljs-variable">volatile</span>变量规则（<span class="hljs-variable">Volatile</span> <span class="hljs-variable">Variable</span> <span class="hljs-built_in">Rule</span>）：对一个<span class="hljs-variable">volatile</span>变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后；<br><span class="hljs-number">4</span>、线程启动规则（<span class="hljs-built_in">Thread</span> <span class="hljs-variable">Start</span> <span class="hljs-built_in">Rule</span>）：<span class="hljs-built_in">Thread</span>对象的<span class="hljs-variable">start</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法先行发生于此线程的每一个动作；<br><span class="hljs-number">5</span>、线程终止规则（<span class="hljs-built_in">Thread</span> <span class="hljs-variable">Termination</span> <span class="hljs-built_in">Rule</span>）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过<span class="hljs-built_in">Thread</span><span class="hljs-string">::join</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法是否结束、<span class="hljs-built_in">Thread</span><span class="hljs-string">::isAlive</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>的返回值等手段检测线程是否已经终止执行；<br><span class="hljs-number">6</span>、线程中断规则（<span class="hljs-built_in">Thread</span> <span class="hljs-variable">Interruption</span> <span class="hljs-built_in">Rule</span>）：对线程<span class="hljs-variable">interrupt</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过<span class="hljs-built_in">Thread</span><span class="hljs-string">::interrupted</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法检测到是否有中断发生；<br><span class="hljs-number">7</span>、对象终结规则（<span class="hljs-variable">Finalizer</span> <span class="hljs-built_in">Rule</span>）：一个对象的初始化完成（构造函数执行结束）先行发生于它的<span class="hljs-variable">finalize</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法的开始；<br><span class="hljs-number">8</span>、传递性（<span class="hljs-variable">Transitivity</span>）：如果操作<span class="hljs-variable">A</span>先行发生于操作<span class="hljs-variable">B</span>，操作<span class="hljs-variable">B</span>先行发生于操作<span class="hljs-built_in">C</span>，那就可以得出操作<span class="hljs-variable">A</span>先行发生于操作<span class="hljs-built_in">C</span>的结论。<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="六、并发编程进阶"><a href="#六、并发编程进阶" class="headerlink" title="六、并发编程进阶"></a>六、并发编程进阶</h1><h2 id="1、并发编程三要素"><a href="#1、并发编程三要素" class="headerlink" title="1、并发编程三要素"></a>1、并发编程三要素</h2><p><strong>简介: 常见的并发编程三要素</strong></p>
<ul>
<li><p>考点：考查是否知道并发编程三要素</p>
</li>
<li><p>并发编程三要素是否知道，能否分别解释下，举个简单的例子？</p>
<p>并发编程三要素分别是：原子性、可见性、有序性</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs gradle">原子性：<br>在⼀个操作中cpu不可以在中途暂停然后再调度，即不能被中断操作，要么全部执⾏完成，要么都不执⾏。就好⽐转账，从账户A向账户B转<span class="hljs-number">1000</span>元，那么必然包括<span class="hljs-number">2</span>个操作：从账户A减去<span class="hljs-number">1000</span>元，往账户B加上<span class="hljs-number">1000</span>元。两个操作必须全部完成。<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> calc() &#123;<br>	<span class="hljs-keyword">count</span>++; <span class="hljs-comment">//非原子性，除非用原子类，即java.util.concurrent.atomic里的原子变量类</span><br>&#125;<br><br>操作步骤：<br><span class="hljs-number">1</span>：将 <span class="hljs-keyword">count</span> 从主存读到⼯作内存中的副本中<br><span class="hljs-number">2</span>：进行+<span class="hljs-number">1</span>的运算<br><span class="hljs-number">3</span>：将结果写⼊⼯作内存<br><span class="hljs-number">4</span>：将⼯作内存的值刷回主存(什么时候刷⼊由操作系统决定，不确定的)<br><br>解决办法：<br>解决办法是可以用<span class="hljs-keyword">synchronized</span>或Lock(比如ReentrantLock)来把这个多步操作“变成”原子操作，但是不能用<span class="hljs-keyword">volatile</span>，因为前面有说到<span class="hljs-keyword">volatile</span>不能修饰有依赖值的情况。<br><br>核心思想：<br>把一个方法或者代码块看做一个整体，保证是一个不可分割的整体。<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 并发编程三要素之原子性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @author LiuPeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> demo01 &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//使用synchronized，保证方法被锁住</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> calc01() &#123;<br>        <span class="hljs-keyword">count</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">//使用lock，保证代码块被锁住，每个对象都是有锁，只有获得这个锁才可以进行对应的操作</span><br>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> calc02() &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">count</span>++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>  <br>&#125;<br>关键字：<span class="hljs-keyword">synchronized</span><br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">有序性：<br>程序执行的顺序按照代码的先后顺序执行，因为处理器可能会对指令进行重排序<br>JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(在不改变程序结果的前提下)<br><br>int a = <span class="hljs-number">3</span> <span class="hljs-regexp">//</span><span class="hljs-number">1</span><br>int b = <span class="hljs-number">4</span> <span class="hljs-regexp">//</span><span class="hljs-number">2</span><br>int c =<span class="hljs-number">5</span> <span class="hljs-regexp">//</span><span class="hljs-number">3</span> <br>int h = a*b*c <span class="hljs-regexp">//</span><span class="hljs-number">4</span><br><br>上面的例子 执行顺序<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> 和 <span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> 结果都是一样，指令重排序可以提高执行效率，但是多线程上可能会影响结果<br><br>假如下面的场景，正常是顺序处理<br><span class="hljs-regexp">//</span>线程<span class="hljs-number">1</span><br>before();<span class="hljs-regexp">//</span>处理初始化工作，处理完成后才可以正式运行下面的run方法<br>flag = true; <span class="hljs-regexp">//</span>标记资源处理好了，如果资源没处理好，此时程序就可能出现问题<br><span class="hljs-regexp">//</span>线程<span class="hljs-number">2</span><br><span class="hljs-keyword">while</span>(flag)&#123;<br>    run(); <span class="hljs-regexp">//</span>核心业务代码<br>&#125;<br><br>指令重排序后，导致顺序换了，程序出现问题，且难排查<br><br><span class="hljs-regexp">//</span>线程<span class="hljs-number">1</span><br>flag = true; <span class="hljs-regexp">//</span>标记资源处理好了，如果资源没处理好，此时程序就可能出现问题<br><span class="hljs-regexp">//</span>线程<span class="hljs-number">2</span><br><span class="hljs-keyword">while</span>(flag)&#123;<br>    run(); <span class="hljs-regexp">//</span>核心业务代码<br>&#125;<br>before();<span class="hljs-regexp">//</span>处理初始化工作，处理完成后才可以正式运行下面的run方法<br><br>关键字：volatile、synchronized<br></code></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart">可见性：<br>一个线程A对共享变量的修改,另一个线程B能够立刻看到<br><br><span class="hljs-comment">// 线程 A 执行</span><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 线程 A 执行</span><br><span class="hljs-built_in">num</span>++;<br><span class="hljs-comment">// 线程 B 执行</span><br>System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num的值：&quot;</span> + <span class="hljs-built_in">num</span>);<br><br>线程A执行 <span class="hljs-built_in">num</span>++ 后再执行线程 B，线程 B可能有<span class="hljs-number">2</span>个结果，可能是<span class="hljs-number">0</span>和<span class="hljs-number">1</span>。<br><br>原因是 <span class="hljs-built_in">num</span>++ 在线程A中执行运算，并没有立刻更新到主内存当中，而线程B就去主内存当中读取并打印，此时打印的就是<span class="hljs-number">0</span>；<br>也可能线程A执行完成更新到主内存了,线程B的值是<span class="hljs-number">1</span>。<br>所以需要保证线程的可见性<br><br>关键字：volatile、synchronized、<span class="hljs-keyword">final</span><br></code></pre></td></tr></table></figure>
<p>volatile本身就包含了禁止指令重排序的语义，而synchronized关键字是由“⼀个变量在同⼀时刻只允许⼀条线程对其进行lock操作”这条规则明确的。</p>
<p>synchronized关键字同时满足以上三种特性，但是volatile关键字不满足原子性。</p>
<p>在某些情况下，volatile的同步机制的性能确实要优于锁(使⽤synchronized关键字或 java.util.concurrent包⾥⾯的锁)，因为volatile的总开销要比锁低。 </p>
<p>我们判断使用volatile还是加锁的唯⼀依据就是volatile的语义能否满足使用的场景(原子性)</p>
</li>
</ul>
<h2 id="2、常见进程-线程调度算法"><a href="#2、常见进程-线程调度算法" class="headerlink" title="2、常见进程/线程调度算法"></a>2、常见进程/线程调度算法</h2><p><strong>简介: 常见的进程、线程间调度算法</strong></p>
<ul>
<li><p>考点：考查是否知道常见进程和线程间的调度算法</p>
</li>
<li><p>说下你知道的调度算法，比如进程间的调度？</p>
<ol>
<li><p>先来先服务调度算法：</p>
<p>​    按照作业/进程到达的先后顺序进行调度，即：优先考虑在系统中等待时间最长的作业</p>
<p>​    排在长进程后的短进程的等待时间长，不利于短作业/进程</p>
</li>
<li><p>短作业优先调度算法：</p>
<p>​    短进程/作业（要求服务时间最短）在实际情况中占有很大比例，为了使他们优先执行</p>
<p>​    对长作业不友好</p>
</li>
<li><p>高响应比优先调度算法：</p>
<p>​    在每次调度时，先计算各个作业的优先权；</p>
<p>​    优先权=响应比=（等待时间+要求服务时间）/要求服务时间=总响应时间/要求服务时间</p>
<p>​    选择优先权高的进行服务，需要计算优先权信息，增加了系统的开销</p>
</li>
<li><p>时间片轮转调度算法：</p>
<p>​    轮流为的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>
<p>​    由于高频率的进程切换，会增加开销，且不区分任务的紧急程度</p>
</li>
<li><p>优先级调度算法：</p>
<p>​    根据任务的紧急程度进行调度，高优先级的先处理，低优先级的慢处理</p>
<p>​    如果高优先级任务很多且持续产生，那么低优先级的就可能很慢才被处理</p>
</li>
</ol>
</li>
<li><p>常见的线程间的调度算法是怎样的？Java是哪种？</p>
<p>​    线程调度是指系统为线程分配CPU使用权的过程，主要分为两种：</p>
<ol>
<li><p>协同式线程调度（分时调度）：</p>
<p>线程执行时间由线程本身来控制，线程把自己的工作执行完成后，要主动通知系统切换到另外一个线程上。</p>
<ul>
<li>好处：实现简单，且切换操作对线程自己是可知的，没有线程同步问题</li>
<li>坏处：线程执行时间是不可控的，如果一个线程有问题，可能一直堵塞在那里</li>
</ul>
</li>
<li><p>抢占式线程调度：</p>
<p>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中的Thread.yield()可以让出执行时间，但无法获取执行时间），线程执行时间是可控，也不会有一个线程导致整个进程堵塞</p>
</li>
</ol>
<p><strong>Java线程调度就是采取抢占式调度</strong>，优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那就随机选择一个线程。</p>
</li>
</ul>
<p>如果希望某些线程多分配一些时间，而某些线程少分配一些时间，可以通过设置优先级来完成。Java线程的优先级可以指定整数1到10，当多个线程运行时，VM一般会优先运行高优先级的线程（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）</p>
<p>在两个线程同时处于就绪Runnable状态时，优先级越高的线程越容易被执行。但不是优先级高就一定会先执行，只是机会越大而已。</p>
<p>有人会说 wait、notify不就是线程本身控制的么？</p>
<p>其实不是，wait是可以让出执行时间，notify之后无法获取执行时间，随机等待队列里面获取而已</p>
<h2 id="3、java多线程里面常用的锁"><a href="#3、java多线程里面常用的锁" class="headerlink" title="3、java多线程里面常用的锁"></a>3、java多线程里面常用的锁</h2><ul>
<li><p>考点：考查对常见的锁是否掌握</p>
</li>
<li><p>你日常开发里面用过java里面有哪些锁？分别解释下？</p>
<ul>
<li><p>悲观锁：</p>
<p>​    当线程去操作数据的时候，总认为别的线程会去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞，比如synchronized</p>
<p>​    悲观锁适用于<strong>写操作多</strong>的场景</p>
</li>
<li><p>乐观锁：</p>
<p>​    每次去拿数据的时候都认为别人不会修改，只有更新的时候会判断别人是否更新了数据，通过版本来判断，如果数据被更改了就拒绝更新，比如CAS（但严格来说并不是锁，而是通过原子性来保证数据的同步，比如数据库的乐观锁，通过版本控制来实现，CAS不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响）</p>
<p>​    乐观锁适用于<strong>读操作多</strong>的场景，乐观锁的吞吐量会比悲观锁多</p>
</li>
<li><p>公平锁：</p>
<p>​    指多个线程按照申请锁的顺序来获取锁，简单来说，一个线程组里能保证每个线程都能拿到锁，比如ReentrantLock（底层是同步队列 FIFO:First Input First Output来实现）</p>
</li>
<li><p>非公平锁：</p>
<p>​    获取锁的方式是随机的，保证不了每个线程都能拿到锁，比如synchronized、ReentrantLock</p>
<p>​    非公平锁<strong>性能高于</strong>公平锁，更能重复利用CPU的时间</p>
</li>
<li><p>可重入锁：</p>
<p>​    也叫递归锁，指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，不会发生死锁，比如synchronized、ReentrantLock</p>
<p>​    可重入锁能在一定程度上<strong>避免死锁</strong></p>
</li>
<li><p>不可重入锁：</p>
<p>​    若当前线程执行某个方法时已经获取了该锁，那么在方法中尝试再次获取锁时就无法获取而是被阻塞</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>&#123;<br>	<span class="hljs-comment">//获取锁 TODO</span><br>	<span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>&#123;<br>	<span class="hljs-comment">//获取锁 TODO</span><br>    <span class="hljs-comment">//其他操作</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>自旋锁：</p>
<p>​    一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够成功获取锁，直到获取锁时才会退出循环，任何时刻最多只有一个执行单元获得锁，比如TicketLock、CLHLock、MSCLock</p>
<p>​    不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU</p>
</li>
<li><p>共享锁：</p>
<p>​    也叫S锁/读锁，只能查看而无法修改和删除的一种锁，加锁后其他用户可以并发读取、查询数据，但不能修改、增加、删除数据，该锁可以被多个线程持有，用于资源数据共享</p>
</li>
<li><p>互斥锁：</p>
<p>​    也叫X锁/排他锁/写锁/独占锁/独享锁，获得互斥锁的线程既能读数据又能修改数据，该锁每次只能被一个线程持有，加锁后任何试图再次加锁的线程都会被堵塞，直到当前线程解锁</p>
</li>
<li><p>死锁：</p>
<p>​    两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法让程序继续进行下去</p>
</li>
</ul>
</li>
</ul>
<p>  下面三种是JVM为了提高锁的获取与释放效率而做的优化，针对Synchronized的锁升级，锁的状态是通过对象监视器在对象头中的字段来表明，是不可逆的过程</p>
<ul>
<li><p>偏向锁：</p>
<p>​    一段同步代码一直被一个线程访问，那么该线程会自动获取锁，获取锁的代价更低</p>
</li>
<li><p>轻量级锁：</p>
<p>​    当锁是偏向锁的时候，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，但不会阻塞，而且性能会更高</p>
</li>
<li><p>重量级锁:</p>
<p>​    当锁为轻量级锁的时候，其他线程虽然是自旋，但自旋不会一直循环下去，当自旋一定次数的时候还没有获取到锁，就会进入阻塞，该锁升级为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能也会降低</p>
</li>
</ul>
<h2 id="4、多线程死锁"><a href="#4、多线程死锁" class="headerlink" title="4、多线程死锁"></a>4、多线程死锁</h2><ul>
<li><p>考点：考查对常见的死锁是否掌握</p>
</li>
<li><p>上机实战：写一个多线程死锁的例子</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="后端面试/image-8.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> DeadLockDemo &#123;<br>    <span class="hljs-keyword">private</span> static Object resource1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> static Object resource2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//资源 2</span><br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>            synchronized (resource1) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>                &#125; catch (InterruptedException e) &#123;<br>                    e.print<span class="hljs-constructor">StackTrace()</span>;<br>                &#125;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                synchronized (resource2) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>            synchronized (resource2) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>                &#125; catch (InterruptedException e) &#123;<br>                    e.print<span class="hljs-constructor">StackTrace()</span>;<br>                &#125;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                synchronized (resource1) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>产生死锁的四个必要条件？</p>
<ol>
<li><p>互斥条件：</p>
<p>​    资源不能共享，该资源任意一个时刻只能由一个线程占用</p>
</li>
<li><p>请求与保持条件：</p>
<p>​    一个线程因请求其他资源而发生阻塞时，对已获得的资源保持不释放</p>
</li>
<li><p>不剥夺条件：</p>
<p>​    线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有等自己使用完毕后才会释放资源</p>
</li>
<li><p>循环等待条件：</p>
<p>​    多个线程之间形成一种头尾相接的循环等待资源关系，每个线程都占用对方需要申请的下个资源</p>
</li>
</ol>
</li>
</ul>
<p>  只要发生死锁，以上四个条件都成立；只要有其中一个不满足，就不会发生死锁。</p>
<ul>
<li><p>如何预防和避免线程死锁？</p>
<ul>
<li><p><strong>如何预防死锁？</strong>破坏死锁产生的必要条件即可：</p>
<ul>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：依靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ul>
</li>
<li><p><strong>如何避免死锁？</strong></p>
<ul>
<li>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>安全状态</strong>：指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。</p>
</blockquote>
<p>我们对（线程 2） 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>    synchronized (resource1) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>        synchronized (resource2) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">1</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource<span class="hljs-number">2</span><br><span class="hljs-attribute">Thread</span>[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource<span class="hljs-number">2</span><br><br><span class="hljs-attribute">Process</span> finished with exit code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure>
<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h2 id="5、多线程不可重入锁"><a href="#5、多线程不可重入锁" class="headerlink" title="5、多线程不可重入锁"></a>5、多线程不可重入锁</h2><ul>
<li><p>考点：考查对常见的不可重入锁是否掌握</p>
</li>
<li><p>上机实战：设计一个简单的不可重入锁</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">不可重入锁：<br>若当前线程执行某个方法时已经获取了该锁，那么在方法中尝试再次获取锁时就无法获取而是被阻塞<br><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>&#123;<br>	<span class="hljs-comment">//获取锁 TODO</span><br>	<span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>&#123;<br>	<span class="hljs-comment">//获取锁 TODO</span><br>    <span class="hljs-comment">//其他操作</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> UnreentrantLock &#123;<br><br>    <span class="hljs-keyword">private</span> boolean isLocked = <span class="hljs-literal">false</span>;<br><br>    public synchronized void lock<span class="hljs-literal">()</span> throws InterruptedException &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入lock加锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>        <span class="hljs-comment">//判断是否已经被锁，如果被锁则当前请求的线程进行等待</span><br>        <span class="hljs-keyword">while</span> (isLocked) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入wait等待 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>            wait<span class="hljs-literal">()</span>;<br>        &#125;<br>        <span class="hljs-comment">//进行加锁</span><br>        isLocked = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    public synchronized void unlock<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入unlock解锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>        isLocked = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//唤醒对象锁池里面的一个线程</span><br>        notify<span class="hljs-literal">()</span>;<br>    &#125;<br>    <br>&#125;<br><br>public <span class="hljs-keyword">class</span> UnreentrantLockTest &#123;<br><br>    <span class="hljs-keyword">private</span> UnreentrantLock unreentrantLock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UnreentrantLock()</span>;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            unreentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodA方法被调用&quot;</span>);<br>            <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            unreentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            unreentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodB方法被调用&quot;</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            unreentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>       <span class="hljs-keyword">new</span> <span class="hljs-constructor">Main()</span>.<span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">进入lock加锁 <span class="hljs-selector-tag">main</span><br>methodA方法被调用<br>进入lock加锁 <span class="hljs-selector-tag">main</span><br>进入wait等待 <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6、多线程可重入锁"><a href="#6、多线程可重入锁" class="headerlink" title="6、多线程可重入锁"></a>6、多线程可重入锁</h2><ul>
<li><p>考点：考查对常见的重入锁是否掌握</p>
</li>
<li><p>上机实战：设计一个简单的可重入锁</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">可重入锁：<br>也叫递归锁，指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，不会发生死锁<br>public <span class="hljs-keyword">class</span> ReentrantLock &#123;<br><br>    <span class="hljs-keyword">private</span> boolean isLocked = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//用于记录是否是重入的线程</span><br>    <span class="hljs-keyword">private</span> Thread lockedOwner = null;<br><br>    <span class="hljs-comment">//累计加锁次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> lockedCount = <span class="hljs-number">0</span>;<br><br>    public synchronized void lock<span class="hljs-literal">()</span> throws InterruptedException &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入lock加锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br><br>        Thread thread = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>        <span class="hljs-comment">//判断是否是同一个线程获取锁</span><br>        <span class="hljs-keyword">while</span> (isLocked<span class="hljs-operator"> &amp;&amp; </span>lockedOwner != thread) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入wait等待 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;当前锁状态 isLocked =  &quot;</span> + isLocked);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;当前count数量 lockedCount =  &quot;</span> + lockedCount);<br>            wait<span class="hljs-literal">()</span>;<br>        &#125;<br>        <span class="hljs-comment">//进行加锁</span><br>        isLocked = <span class="hljs-literal">true</span>;<br>        lockedOwner = thread;<br>        lockedCount++;<br>    &#125;<br><br>    public synchronized void unlock<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;进入unlock解锁 &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br><br>        Thread thread = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>        <span class="hljs-comment">//判断解锁与加锁的线程是否是同一个</span><br>        <span class="hljs-keyword">if</span> (thread<span class="hljs-operator"> == </span>this.lockedOwner) &#123;<br>            lockedCount--;<br>            <span class="hljs-keyword">if</span> (lockedCount<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>                isLocked = <span class="hljs-literal">false</span>;<br>                lockedOwner = null;<br>                <span class="hljs-comment">//唤醒对象锁池里面的一个线程</span><br>                notify<span class="hljs-literal">()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br>public <span class="hljs-keyword">class</span> ReentrantLockTest &#123;<br><br>    <span class="hljs-keyword">private</span> ReentrantLock reentrantLock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantLock()</span>;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            reentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodA方法被调用&quot;</span>);<br>            <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            reentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public void <span class="hljs-keyword">method</span><span class="hljs-constructor">B()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            reentrantLock.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;methodB方法被调用&quot;</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            reentrantLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantLockTest()</span>.<span class="hljs-keyword">method</span><span class="hljs-constructor">A()</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">进入lock加锁 main<br>methodA方法被调用<br>进入lock加锁 main<br>methodB方法被调用<br>进入unlock解锁 main<br>进入unlock解锁 main<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7、多线程的synchronized"><a href="#7、多线程的synchronized" class="headerlink" title="7、多线程的synchronized"></a>7、多线程的synchronized</h2><ul>
<li><p>考点：考查对常见的synchronized是否掌握，新版JDK6里面优化了什么</p>
</li>
<li><p>对synchronized了解不，能否介绍下你对synchronized的理解</p>
<p>​    synchronized 关键字解决的是多个线程之间访问资源的同步性，常用在 普通方法、静态方法、代码块。是非公平、可重入的锁</p>
<p>​    每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程会阻塞等待。锁被释放后，对象会从队列中取出一个线程并唤醒，具体唤醒哪一个是不确定的。</p>
<ul>
<li>方法：生成的字节码文件中会多一个ACC_SYNCHRONIZED标识位，当一个线程访问方法时，会去检查是否存在ACC_SYNCHRONIZED标识，如果存在，执行的线程将会先获取monitor，获取成功之后才能执行方法体，方方法执行完成后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象，也叫隐式同步</li>
<li>代码块：加了synchronized关键字的代码块，生成的字节码文件会多出monitorenter 和 monitorexit 两条指令，每个monitor维护者一个记录着拥有次数的计数器，未被使用的monitor的计数器为0，当一个线程执行monitorenter 之后，该计数器自增1；当同一个线程执行monitorexit之后，该计数器自减1；当计数器为0的时候，monitor将被释放，也叫显式同步</li>
</ul>
<p>两种本质上没什么区别，底层都是通过monitor来实现同步</p>
</li>
<li><p>JDK6 后进行了优化，你知道哪些大的变化？</p>
<p>​    JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>​    锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p>
<blockquote>
<p>注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
</blockquote>
</li>
</ul>
<h2 id="8、高性能的Compare-and-Swap"><a href="#8、高性能的Compare-and-Swap" class="headerlink" title="8、高性能的Compare and Swap"></a>8、高性能的Compare and Swap</h2><p><strong>简介：并发编程面试核心点CAS考查</strong></p>
<ul>
<li><p>考点：考查对常见的CAS是否掌握</p>
</li>
<li><p>了解CAS不？，能否解释下什么是CAS？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">CAS全称是 Compare and Swap 比较再交换，是实现并发的一种技术<br>底层是通过Unsafe类实现原子性操作，包含三个操作数——内存地址（V）、预期原值（<span class="hljs-selector-tag">A</span>）、新值(<span class="hljs-selector-tag">B</span>)<br>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值，如果在第一轮循环中，<span class="hljs-selector-tag">a</span>线程获取地址里面的值被<span class="hljs-selector-tag">b</span>线程修改了，那么<span class="hljs-selector-tag">a</span>线程需要自旋，直到下次循环才可能有机会执行。<br><br>CAS属于乐观锁，乐观锁的性能比悲观锁好；<br>AtomicXXX等原子类底层就是CAS实现，所以在一定程度上比synchronized性能好，因为synchronized是悲观锁。<br></code></pre></td></tr></table></figure>
<p><img src="后端面试/image-9.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li><p>CAS会存在什么比较严重的问题？</p>
<ol>
<li>自旋时间长，CPU利用率增加，CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，CPU资源会一直被占用</li>
<li>存在ABA问题</li>
</ol>
</li>
<li><p>能否解释下什么是ABA问题，怎么避免这个问题呢？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">ABA问题：如果一个变量V初次读取是<span class="hljs-selector-tag">A</span>值，并且在准备赋值的时候也是<span class="hljs-selector-tag">A</span>值，那就能说明<span class="hljs-selector-tag">A</span>值没有被修改过吗？其实是不能的，因为变量V可能被其他线程改回<span class="hljs-selector-tag">A</span>值，结果就是会导致CAS操作误认为从来没被修改过，从而赋值给V<br><br>解决办法：给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。<br>在JDK5中，已经提供了AtomicStampedReference来解决问题，检查当前引用是否等于预期引用，其次检查当前标志是否等于预期标志，如果都相等就会以原子的方式将引用和标志都设置为新值<br></code></pre></td></tr></table></figure>
<p><img src="后端面试/image-10.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
</ul>
<h1 id="七、并发底层原理"><a href="#七、并发底层原理" class="headerlink" title="七、并发底层原理"></a>七、并发底层原理</h1><h2 id="1、AQS核心底层"><a href="#1、AQS核心底层" class="headerlink" title="1、AQS核心底层"></a>1、AQS核心底层</h2><p><strong>简介: 常见的并发编程AQS考查</strong></p>
<ul>
<li><p>考点：考查是否知道并发编程AQS</p>
</li>
<li><p>知道AQS吗？能否介绍下它的核心思想是什么？</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">AQS</span>的全称为（<span class="hljs-selector-tag">AbstractQueuedSynchronizer</span>），这个类在<span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>包下面。它是一个<span class="hljs-selector-tag">Java</span>提高的底层同步工具类，比如<span class="hljs-selector-tag">CountDownLatch</span>、<span class="hljs-selector-tag">ReentrantLock</span>，<span class="hljs-selector-tag">Semaphore</span>，<span class="hljs-selector-tag">ReentrantReadWriteLock</span>，<span class="hljs-selector-tag">SynchronousQueue</span>，<span class="hljs-selector-tag">FutureTask</span>等等皆是基于<span class="hljs-selector-tag">AQS</span>的<br><br>只要搞懂了<span class="hljs-selector-tag">AQS</span>，那么<span class="hljs-selector-tag">J</span><span class="hljs-selector-class">.U</span><span class="hljs-selector-class">.C</span>中绝大部分的<span class="hljs-selector-tag">api</span>都能轻松掌握<br><br>简单来说：是用一个<span class="hljs-selector-tag">int</span>类型的变量表示同步状态，并提供了一系列的<span class="hljs-selector-tag">CAS</span>操作来管理这个同步状态对象<br>一个是 <span class="hljs-selector-tag">state</span>（用于计数器，类似<span class="hljs-selector-tag">gc</span>的回收计数器）<br>一个是线程标记（当前线程是谁加锁的），<br>一个是阻塞队列（用于存放其他未拿到锁的线程)<br><br>例子：线程<span class="hljs-selector-tag">A</span>调用了<span class="hljs-selector-tag">lock</span>()方法，通过<span class="hljs-selector-tag">CAS</span>将<span class="hljs-selector-tag">state</span>赋值为<span class="hljs-selector-tag">1</span>，然后将该锁标记为线程<span class="hljs-selector-tag">A</span>加锁。如果线程<span class="hljs-selector-tag">A</span>还未释放锁时，线程<span class="hljs-selector-tag">B</span>来请求，会查询锁标记的状态，因为当前的锁标记为 线程<span class="hljs-selector-tag">A</span>，线程<span class="hljs-selector-tag">B</span>未能匹配上，所以线程<span class="hljs-selector-tag">B</span>会加入阻塞队列，直到线程<span class="hljs-selector-tag">A</span>触发了 <span class="hljs-selector-tag">unlock</span>() 方法，这时线程<span class="hljs-selector-tag">B</span>才有机会去拿到锁，但是不一定肯定拿到<br></code></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">acquire(<span class="hljs-built_in">int</span> arg) 源码讲解，类似加锁lock操作<br>    <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire()</span>尝试直接去获取资源，如果成功则直接返回,AQS里面未实现但没有定义成abstract，因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared，类似设计模式里面的适配器模式<br><br>    add<span class="hljs-constructor">Waiter()</span> 根据不同模式将线程加入等待队列的尾部，有Node.EXCLUSIVE互斥模式、Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail方法以CAS将当前线程节点加入到等待队列的末尾。否则通过enq(node)方法初始化一个等待队列<br><br>    acquire<span class="hljs-constructor">Queued()</span>使线程在等待队列中获取资源，一直获取到资源后才返回,如果在等待过程中被中断，则返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br><br>release(<span class="hljs-built_in">int</span> arg)源码讲解 类似解锁unlock操作<br>    独占模式下线程释放指定量的资源，里面是根据<span class="hljs-keyword">try</span><span class="hljs-constructor">Release()</span>的返回值来判断该线程是否已经完成释放掉资源了；在自义定同步器在实现时，如果已经彻底释放资源(state=<span class="hljs-number">0</span>)，要返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>    unparkSuccessor方法用于唤醒等待队列中下一个线程<br></code></pre></td></tr></table></figure>
</li>
<li><p>你知道的AQS有几种同步方式，实现同步器一般要覆盖哪些方法？</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">独占式: 比如ReentrantLock<br><br>共享式：比如Semaphore<br><br>存在组合：组合式的如ReentrantReadWriteLock，AQS为使用提供了底层支撑，使用者可以自由组装实现<br><br><span class="hljs-number">1.</span> boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">2.</span> boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Release(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">3.</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">try</span><span class="hljs-constructor">AcquireShared(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">4.</span> boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">ReleaseShared(<span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> <br><span class="hljs-number">5.</span> boolean is<span class="hljs-constructor">HeldExclusively()</span><br><br>不需要全部实现，根据获取的锁的种类可以选择实现不同的方法，比如<br>实现支持独占锁的同步器应该实现tryAcquire、 tryRelease、isHeldExclusively<br>实现支持共享获取的同步器应该实现tryAcquireShared、tryReleaseShared、isHeldExclusively<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意：线程获取锁成功后直接返回，不会进入等待队列里面，只有失败的时候才会</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//线程获取锁成功后 直接返回，不会进入等待队列里面，只有失败的时候才会</span><br>public final void acquire(<span class="hljs-built_in">int</span> arg) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span><span class="hljs-operator"> &amp;&amp; </span>acquire<span class="hljs-constructor">Queued(<span class="hljs-params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))<br>　　self<span class="hljs-constructor">Interrupt()</span>;<br>&#125;<br>​<br>=========<br><span class="hljs-comment">//获取失败则将当前线程封装为Node.EXCLUSIVE的Node节点插入AQS阻塞队列的尾部</span><br> final boolean acquire<span class="hljs-constructor">Queued(<span class="hljs-params">final</span> Node <span class="hljs-params">node</span>, <span class="hljs-params">int</span> <span class="hljs-params">arg</span>)</span> &#123;<br>        boolean failed = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            boolean interrupted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                final Node p = node.predecessor<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">if</span> (p<span class="hljs-operator"> == </span>head<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span>) &#123;<br>                    set<span class="hljs-constructor">Head(<span class="hljs-params">node</span>)</span>;<br>                    p.next = null; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    return interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (should<span class="hljs-constructor">ParkAfterFailedAcquire(<span class="hljs-params">p</span>, <span class="hljs-params">node</span>)</span><span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">                    </span>park<span class="hljs-constructor">AndCheckInterrupt()</span>)<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; finally &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancel<span class="hljs-constructor">Acquire(<span class="hljs-params">node</span>)</span>;<br>        &#125;<br>    &#125;<br>==================<br><span class="hljs-comment">//调用LockSupport.park(this)方式阻塞自己</span><br> <span class="hljs-keyword">private</span> final boolean park<span class="hljs-constructor">AndCheckInterrupt()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LockSupport</span>.</span></span>park(this);<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>interrupted<span class="hljs-literal">()</span>;<br> &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2、ReentrantLock核心底层"><a href="#2、ReentrantLock核心底层" class="headerlink" title="2、ReentrantLock核心底层"></a>2、ReentrantLock核心底层</h2><p><strong>简介: 源码解析ReentrantLock实现原理</strong></p>
<ul>
<li>考点：考查是否知道ReentrantLock底层实现</li>
<li>java里面的公平锁和非公平锁你知道多少，有没看过ReentrantLock源码？</li>
</ul>
<p><img src="后端面试/image-11.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>ReentrantLock中公平锁和非公平锁的区别？</li>
</ul>
<p><img src="后端面试/image-12.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="3、ReentrantLock和synchronized"><a href="#3、ReentrantLock和synchronized" class="headerlink" title="3、ReentrantLock和synchronized"></a>3、ReentrantLock和synchronized</h2><p><strong>简介: 解析ReentrantLock和synchronized的区别</strong></p>
<ul>
<li><p>考点：考查ReentrantLock和synchronized的掌握情况</p>
</li>
<li><p>ReentrantLock和synchronized使用的场景是什么，实现机制有什么不同</p>
<ol>
<li><p>底层实现：</p>
<ul>
<li><p>synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait/notify方法；</p>
</li>
<li><p>ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁；</p>
</li>
</ul>
</li>
<li><p>是否可手动释放：</p>
<ul>
<li>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用；</li>
<li>ReentrantLock 则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活；</li>
</ul>
</li>
<li><p>是否可中断：</p>
<ul>
<li>synchronized 是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成；</li>
<li>ReentrantLock 则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断；</li>
</ul>
</li>
<li><p>是否是公平锁：</p>
<ul>
<li>synchronized为非公平锁；</li>
<li>ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁；</li>
</ul>
</li>
<li><p>锁是否可绑定条件Condition</p>
<ul>
<li>synchronized不能绑定；</li>
<li>ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程；</li>
</ul>
</li>
<li><p>锁的对象</p>
<ul>
<li>synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；</li>
<li>ReentrantLock锁的是线程，根据进入的线程和int类型的state来标识锁的获得/争抢；</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4、ReentrantReadWriteLock"><a href="#4、ReentrantReadWriteLock" class="headerlink" title="4、ReentrantReadWriteLock"></a>4、ReentrantReadWriteLock</h2><p><strong>简介: 讲解ReentrantReadWriteLock读写锁的掌握情况</strong></p>
<ul>
<li>考点：考查ReentrantReadWriteLock读写锁的掌握情况</li>
<li>知道ReentrantReadWriteLock吗？和ReentrantLock有啥不同？</li>
</ul>
<p><img src="后端面试/image-13.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs processing">ReentrantReadWriteLock<br>    <span class="hljs-number">1</span>、是读写锁接口ReadWriteLock接口的一个具体实现，实现了读写锁的分离，<br>    <span class="hljs-number">2</span>、支持公平和非公平，底层也是基于AQS实现<br>    <span class="hljs-number">3</span>、允许从写锁降级为读锁<br>        流程：先获取写锁，然后获取读锁，最后释放写锁；但不能从读锁升级到写锁<br>    <span class="hljs-number">4</span>、重入：读锁后还可以获取读锁；获取了写锁之后既可以再次获取写锁又可以获取读锁<br>    <br>核心：读锁是共享的，写锁是独占的。 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，主要是提升了读写的性能<br><br>ReentrantLock是独占锁且可重入的，相比<span class="hljs-keyword">synchronized</span>而言功能更加丰富也更适合复杂的并发场景，但跟ReentrantReadWriteLock相比较的话ReentrantLock也有弊端，假如有两个线程A/B访问数据，加锁是为了防止线程A在写数据， 线程B在读数据造成的数据不一致； 但线程A在读数据，线程C也在读数据，读数据是不会改变数据没有必要加锁，但是还是加锁了，降低了程序的性能，所以就有了ReadWriteLock读写锁接口<br><br>场景：读多写少，比如设计一个缓存组件 或 提高Collection的并发性<br>class CachedData &#123;<br>	<span class="hljs-keyword">Object</span> data;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">boolean</span> cacheValid;<br>    <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br> <br>    <span class="hljs-keyword">void</span> processCachedData() &#123;<br>      rwl.readLock().lock();<br>      <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>        <span class="hljs-comment">// Must release read lock before acquiring write lock</span><br>        rwl.readLock().unlock();<br>        rwl.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// Recheck state because another thread might have</span><br>          <span class="hljs-comment">// acquired write lock and changed state before we did.</span><br>          <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            data = ...<br>            cacheValid = <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-comment">// Downgrade by acquiring read lock before releasing write lock</span><br>          rwl.readLock().lock();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          rwl.writeLock().unlock(); <span class="hljs-comment">// Unlock write, still hold read</span><br>        &#125;<br>      &#125;<br> <br>      <span class="hljs-keyword">try</span> &#123;<br>        use(data);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        rwl.readLock().unlock();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br> <br> <br>class RWDictionary &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-keyword">String</span>, Data&gt; m = <span class="hljs-keyword">new</span> TreeMap&lt;<span class="hljs-keyword">String</span>, Data&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock r = rwl.readLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock w = rwl.writeLock();<br> <br>    <span class="hljs-keyword">public</span> Data <span class="hljs-built_in">get</span>(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>) &#123;<br>      r.lock();<br>      <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> m.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; r.unlock(); &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span>[] allKeys() &#123;<br>      r.lock();<br>      <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> m.keySet().toArray(); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; r.unlock(); &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Data put(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>, Data value) &#123;<br>      w.lock();<br>      <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> m.put(<span class="hljs-built_in">key</span>, value); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; w.unlock(); &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">clear</span>() &#123;<br>      w.lock();<br>      <span class="hljs-keyword">try</span> &#123; m.<span class="hljs-built_in">clear</span>(); &#125;<br>      <span class="hljs-keyword">finally</span> &#123; w.unlock(); &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5、阻塞队列BlockingQueue"><a href="#5、阻塞队列BlockingQueue" class="headerlink" title="5、阻塞队列BlockingQueue"></a>5、阻塞队列BlockingQueue</h2><p><strong>简介: 讲解阻塞队列BlockingQueue的掌握情况</strong></p>
<ul>
<li><p>考点：考查阻塞队列BlockingQueue的掌握情况</p>
</li>
<li><p>并发编程里面解决生产者消费者模型你知道哪几种方式？</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs isbl">核心：要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据<br><br>常用的同步方法是采用信号或加锁机制<br><span class="hljs-number">1</span>、<span class="hljs-function"><span class="hljs-title">wait</span>() / <span class="hljs-title">notify</span>()方法</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-number">2</span>、<span class="hljs-title">await</span>() / <span class="hljs-title">signal</span>()方法</span><br><span class="hljs-function">    用<span class="hljs-variable">ReentrantLock</span>和<span class="hljs-variable">Condition</span>实现等待/通知模型</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-number">3</span>、<span class="hljs-variable">Semaphore</span>信号量</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-number">4</span>、<span class="hljs-variable">BlockingQueue</span>阻塞队列</span><br><span class="hljs-function">    <span class="hljs-variable">ArrayBlockingQueue</span></span><br><span class="hljs-function">    <span class="hljs-variable">LinkedBlockingQueue</span></span><br><span class="hljs-function">        <span class="hljs-variable">put</span>方法用来向队尾存入元素，如果队列满，则阻塞</span><br><span class="hljs-function">    　　 <span class="hljs-variable">take</span>方法用来从队首取元素，如果队列为空，则阻塞</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>你知道阻塞队列BlockingQueue不？介绍下常见的阻塞队列？</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">BlockingQueue: j<span class="hljs-selector-class">.u</span>.c包下的提供了线程安全的队列访问的接口，并发包下很多高级同步类的实现都是基于阻塞队列实现的<br><br><span class="hljs-number">1</span>、当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满<br><span class="hljs-number">2</span>、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列里面是非空的时候<br><br>常见的阻塞队列<br>    ArrayBlockingQueue：<br>        基于数组实现的一个阻塞队列，需要指定容量大小，FIFO先进先出顺序<br>    <br>    LinkedBlockingQueue：<br>        基于链表实现的一个阻塞队列，如果不指定容量大小，默认 Integer<span class="hljs-selector-class">.MAX_VALUE</span>, FIFO先进先出顺序<br>    <br>    PriorityBlockingQueue：<br>        一个支持优先级的无界阻塞队列，默认情况下元素采用自然顺序升序排序，也可以自定义排序实现 java<span class="hljs-selector-class">.lang</span>.Comparable接口<br>    <br>    DelayQueue：<br>        延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，里面的对象必须实现java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.Delayed</span> 接口并实现CompareTo和getDelay方法<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6、并发队列ConcurrentLinkedQueue"><a href="#6、并发队列ConcurrentLinkedQueue" class="headerlink" title="6、并发队列ConcurrentLinkedQueue"></a>6、并发队列ConcurrentLinkedQueue</h2><p><strong>简介: 讲解非阻塞队列ConcurrentLinkedQueue的掌握情况</strong></p>
<ul>
<li><p>考点：考查非阻塞队列ConcurrentLinkedQueue的掌握情况</p>
</li>
<li><p>你知道非阻塞队列ConcurrentLinkedQueue不，它怎么实现线程安全的？</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">线程安全原因：<br>ConcurrentLinkedQueue是基于链表实现的无界线程安全队列，采用FIFO进行排序<br>保证线程安全的三要素：原子、有序、可见性<br><br><span class="hljs-number">1</span>、底层结构是<span class="hljs-keyword">Node</span><span class="hljs-title">，链表头部和尾部节点是head</span>和tail，使用节点变量和内部类属性使用volatile声明保证了有序和可见性<br><br><span class="hljs-number">2</span>、插入、移除、更新操作使用CAS无锁操作，保证了原子性<br><br><span class="hljs-number">3</span>、假如多线程并发修改导致 CAS 更新失败，采用for循环插入保证更新操作成功<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7、并发编程的最佳实践"><a href="#7、并发编程的最佳实践" class="headerlink" title="7、并发编程的最佳实践"></a>7、并发编程的最佳实践</h2><p><strong>简介: 并发编程常用的最佳实践</strong></p>
<ul>
<li><p>考点：考查是否有用多线程，总结个人的最佳实践</p>
</li>
<li><p>平时多线程用的挺多的，写出3条你遵循的多线程最佳实践？</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">给不同模块的线程起名称，方便后续排查问题<br><br>使用同步代码块或者同步的方法的时候，尽量减小同步范围<br><br>多用并发集合少用同步集合<br>	支持线程安全<br>		并发集合：ConcurrentHashMap、CopyOnWriteArrayList<br>        同步集合：Hashtable<span class="hljs-regexp">/Vector/</span>同步工具类包装Collections.synXXX<br><br>线上业务需要使用多线程，优先考虑线程池是否更加合适，然后判断哪种线程池比较好，最后才是自己创建单一线程<br></code></pre></td></tr></table></figure>
</li>
<li><p>用过线程池不? 有什么好处， java里有哪些是常用的线程池？</p>
<p><strong>使用线程池的好处：</strong></p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p><strong>java里有哪些是常用的线程池：</strong></p>
<ul>
<li>newFixedThreadPool：一个定长线程池，可控制线程最大并发数</li>
<li>newSingleThreadExecutor：一个单线程化的线程池，用唯一的工作线程来执行任务</li>
<li>newCachedThreadPool：一个可缓存线程池</li>
<li>newScheduledThreadPool：一个定长线程池，支持定时/周期性任务执行</li>
</ul>
</li>
</ul>
<h2 id="8、使用线程池的坑"><a href="#8、使用线程池的坑" class="headerlink" title="8、使用线程池的坑"></a>8、使用线程池的坑</h2><p><strong>简介:常见线程池里面坑是否知道</strong></p>
<ul>
<li>考点：是否知道线程池里面的坑</li>
<li>【阿里巴巴编码规范】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor方式的原因？</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Executors创建的线程池底层也是调用 ThreadPoolExecutor，只不过是使用不同的参数、队列、拒绝策略等,如果使用不当，会造成资源耗尽问题；<br>直接使用ThreadPoolExecutor让使用者更加清楚线程池的规则，常见参数的使用，避免风险<br><br>常见的线程池问题：<br><span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>和<span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>: <br>    队列使用LinkedBlockingQueue，队列长度为 Integer.MAX_VALUE，可能造成堆积，导致OOM<br>    <br><span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>和<span class="hljs-keyword">new</span><span class="hljs-type">ScheduledThreadPool</span>:<br>    线程池里面允许最大的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM<br></code></pre></td></tr></table></figure>
<h2 id="9、ThreadPoolExecutor核心参数"><a href="#9、ThreadPoolExecutor核心参数" class="headerlink" title="9、ThreadPoolExecutor核心参数"></a>9、ThreadPoolExecutor核心参数</h2><p><strong>简介: 并发编程里面的ThreadPoolExecutor参数考查</strong></p>
<ul>
<li>考点：ThreadPoolExecutor常见参数的掌握</li>
<li>ThreadPoolExecutor构造函数里面的参数你是否掌握，能否解释下各个参数的作用？</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,<br>                              <span class="hljs-keyword">int</span> maximumPoolSize,<br>                              <span class="hljs-keyword">long</span> keepAliveTime,<br>                              TimeUnit unit,<br>                              BlockingQueue&lt;Runnable&gt; workQueue,<br>                              ThreadFactory threadFactory,<br>                              RejectedExecutionHandler <span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure>
<ol>
<li><strong>corePoolSize</strong><ul>
<li>核心线程数，线程池也会维护线程的最少数量，默认情况下核心线程会一直存活，即使没有任务也不会受存keepAliveTime控制</li>
<li>在刚创建线程池时线程不会立即启动，直到有任务提交时才开始创建线程并且逐步达到线程数目corePoolSize</li>
</ul>
</li>
<li><strong>maximumPoolSize</strong><ul>
<li>线程池维护线程的最大数量，超过将被阻塞</li>
<li>当核心线程满，且阻塞队列也满时，才会判断当前线程数是否小于最大线程数，才决定是否创建新线程</li>
</ul>
</li>
<li><strong>keepAliveTime</strong><ul>
<li>非核心线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize</li>
</ul>
</li>
<li><strong>unit</strong><ul>
<li>指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS</li>
</ul>
</li>
<li><strong>workQueue</strong><ul>
<li>线程池中的任务队列,常用的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</li>
</ul>
</li>
<li><strong>threadFactory</strong><ul>
<li>创建新线程时使用的工厂</li>
</ul>
</li>
<li><strong>handler</strong><ul>
<li>RejectedExecutionHandler是一个接口且只有一个方法,线程池中的数量大于maximumPoolSize时，拒绝任务的处理策略，默认有4种策略AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</li>
</ul>
</li>
</ol>
<h1 id="八、消息队列"><a href="#八、消息队列" class="headerlink" title="八、消息队列"></a>八、消息队列</h1><h2 id="1、消息队列的优缺点及选型"><a href="#1、消息队列的优缺点及选型" class="headerlink" title="1、消息队列的优缺点及选型"></a>1、消息队列的优缺点及选型</h2><p><strong>简介：对比当下主流的消息队列和选择问题</strong></p>
<ul>
<li><p>考点：是否有了解主流消息队列</p>
</li>
<li><p>消息队列有什么优点和缺点？</p>
<p>优点：</p>
<ul>
<li>异步：<ul>
<li>能提高系统的响应速度、吞吐量。</li>
</ul>
</li>
<li>解耦：<ul>
<li>服务之间进行解耦，可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。</li>
<li>解耦后可以实现数据分发。生产者发送一个消息后，可以由一个或者多个消费者进行处理，并且消费者的增加或者减少对生产者没有影响。</li>
</ul>
</li>
<li>削峰：<ul>
<li>以稳定的系统资源应对突发的流量冲击。</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统可用性降低：<ul>
<li>系统引入外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。<strong>这就需要考虑如何保证MQ的高可用。</strong></li>
</ul>
</li>
<li>系统复杂度提高：<ul>
<li>以前服务之间可以进行同步的服务调用，引入MQ之后，会变成异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：<strong>如何保证消息不会丢失？如何保证消息不被重复调用？如何保证消息传递的顺序性？</strong></li>
</ul>
</li>
<li>消息一致性问题：<ul>
<li>A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，但C系统处理失败了怎么办？<strong>这就需要考虑如何保证消息数据处理的一致性。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>业界主流消息队列和技术选型？</p>
<ul>
<li>ActiveMQ：<a target="_blank" rel="noopener" href="http://activemq.apache.org/">http://activemq.apache.org/</a><ul>
<li>Apache出品，历史悠久，支持多种语言的客户端和协议，支持多种语言Java, .NET, C++ 等</li>
<li>基于JMS Provider的实现</li>
<li>缺点：吞吐量不高，多队列的时候性能下降，存在消息丢失的情况，比较少大规模使用</li>
</ul>
</li>
<li>Kafka：<a target="_blank" rel="noopener" href="http://kafka.apache.org/">http://kafka.apache.org/</a><ul>
<li>是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理大规模的网站中的所有动作流数据(网页浏览，搜索和其他用户的行动)，副本集机制，实现数据冗余，保障数据尽量不丢失；支持多个生产者和消费者</li>
<li>类似MQ，功能较为简单，主要支持简单的MQ功能</li>
<li>缺点：不支持批量和广播消息，运维难度大，文档比较少, 需要掌握Scala</li>
</ul>
</li>
<li>RocketMQ：<a target="_blank" rel="noopener" href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a><ul>
<li>阿里开源的一款的消息中间件, 纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点, 性能强劲(零拷贝技术)，支持海量堆积, 支持指定次数和时间间隔的失败消息重发,支持consumer端tag过滤、延迟消息等，在阿里内部进行大规模使用，适合在电商，互联网金融等领域</li>
<li>基于JMS Provider的实现</li>
<li>缺点：社区相对不活跃，更新比较快，纯java支持</li>
</ul>
</li>
<li>RabbitMQ：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a><ul>
<li>是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、C、用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不错</li>
<li>缺点：使用Erlang开发，阅读和修改源码难度大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、oneway-延迟消息"><a href="#2、oneway-延迟消息" class="headerlink" title="2、oneway/延迟消息"></a>2、oneway/延迟消息</h2><p><strong>简介：是否知道oneway、延迟消息等类型消息的应用</strong></p>
<ul>
<li>考点：是否有了解主流消息队列oneway、延迟消息的使用</li>
<li>消息队列的发送方式有哪几种，使用场景分别是怎样的？</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">SYNC</span> 同步发送<br>应用场景：重要通知邮件、报名短信通知、营销短信系统等<br><br>ASYNC 异步发送<br>应用场景：对RT时间敏感,可以支持更高的并发，回调成功触发相对应的业务，比如注册成功后通知积分系统发放优惠券<br><br>ONEWAY 无需要等待响应<br>应用场景：主要是日志收集，适用于某些耗时非常短，但对可靠性要求并不高的场景, 也就是LogServer, 只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求，不等待应答<br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">发送方式</th>
<th style="text-align:left">发送 TPS</th>
<th style="text-align:left">发送结果反馈</th>
<th style="text-align:left">可靠性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">同步发送</td>
<td style="text-align:left">快</td>
<td style="text-align:left">有</td>
<td style="text-align:left">不丢失</td>
</tr>
<tr>
<td style="text-align:left">异步发送</td>
<td style="text-align:left">快</td>
<td style="text-align:left">有</td>
<td style="text-align:left">不丢失</td>
</tr>
<tr>
<td style="text-align:left">单向发送</td>
<td style="text-align:left">最快</td>
<td style="text-align:left">无</td>
<td style="text-align:left">可能丢失</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>有没用过延迟消息，使用场景是怎样的？</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">延迟消息：<br><span class="hljs-code">    Producer 将消息发送到消息队列 broker服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费</span><br><span class="hljs-code"></span><br>使用场景一：通过消息触发一些定时任务，比如在某一固定时间点向用户发送提醒消息<br>使用场景二：消息生产和消费有时间窗口要求，比如在天猫电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条 延时消息。这条消息将会在 30 分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。 如支付未完成，则关闭订单。如已完成支付则忽略<br></code></pre></td></tr></table></figure>
<h2 id="3、消息的顺序性"><a href="#3、消息的顺序性" class="headerlink" title="3、消息的顺序性"></a>3、消息的顺序性</h2><p><strong>简介：是否知道如何保证消息的顺序性</strong></p>
<ul>
<li><p>考点：如何保证消息的顺序性</p>
</li>
<li><p>你用的队列是否支持顺序消息，是怎么实现顺序消息的？</p>
<ul>
<li><p>消息的顺序性：消息的生产顺序和消费顺序一致</p>
<ul>
<li><p>全局顺序：</p>
<p>​    topic下面全部消息都要有序(很少使用)，适合于性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景，并行度成为消息系统的瓶颈, 吞吐量不够</p>
<p>​    使用场景：在证券处理中，以人民币兑换美元为例子，在价格相同的情况下，先出价者优先处理，则可以通过全局顺序的方式按照 FIFO 的方式进行发布和消费</p>
</li>
<li><p>局部顺序：</p>
<p>​    只要保证一组消息被顺序消费即可，性能要求高</p>
<p>​    使用场景：电商的订单创建，同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息、订单交易成功消息 都会按照先后顺序来发布和消费（阿里巴巴集团内部电商系统均使用局部顺序消息，既保证业务的顺序，同时又能保证业务的高性能）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>以RabbitMQ为例分析如何保证消息的顺序性</strong></p>
<p><strong>出现消费顺序错乱的情况①：</strong></p>
<ul>
<li><strong>一个queue存在多个consumer</strong></li>
</ul>
<p><img src="后端面试/image-14.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>解决方案：</strong>将原来的一个queue拆分成多个queue，每个queue都有一个自己的consumer。该种方案的核心是生产者在投递消息的时候<strong>根据业务数据关键值（例如订单ID哈希值对订单队列数取模）来将需要保证先后顺序的同一类数据（同一个订单的数据）</strong> 发送到同一个queue当中</li>
</ul>
<p><img src="后端面试/image-15.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>出现消费顺序错乱的情况②：</strong></p>
<ul>
<li><strong>一个queue只存在一个consumer，但consumer中使用了多线程进行处理</strong></li>
</ul>
<p><img src="后端面试/image-16.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>解决方案：</strong>在consumer中维护<strong>多个内存队列</strong>，<strong>根据业务数据关键值（例如订单ID哈希值对内存队列数取模）将消息加入到不同的内存队列中</strong>，然后多个真正负责处理消息的线程去各自对应的内存队列当中获取消息进行消费。</li>
</ul>
<p><img src="后端面试/image-17.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>RabbitMQ保证消息顺序性总结：</strong><br>核心思路就是根据业务数据关键值划分成多个消息集合，而且每个消息集合中的消息数据都是有序的，每个消息集合有自己独立的一个consumer。多个消息集合的存在保证了消息消费的效率，每个有序的消息集合对应单个的consumer保证了消息消费时的顺序性。</p>
<h2 id="4、消息的幂等性"><a href="#4、消息的幂等性" class="headerlink" title="4、消息的幂等性"></a>4、消息的幂等性</h2><p><strong>简介：考查怎么样可以避免重复消费</strong></p>
<ul>
<li>考点：是否有真正用过消息队列，是否设计过重复消费</li>
<li>幂等性是什么?<ul>
<li>通俗点说，就一个数据或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的</li>
<li>保证同一条消息不会重复或者重复消费了也不会对系统数据造成异常</li>
</ul>
</li>
<li>哪些情况会导致重复消费？<ul>
<li>在生产者发送消息给rabbitMQ服务器的时候，有可能因为网络波动等情况，导致生产者收不到rabbitMQ服务器的应答，导致生产者再发送一条消息。</li>
<li>也是因为网络波动等问题，导致rabbitMQ服务器在向消费者发送消息的时候，没有收到消费者的应答，重复向消费者发生消息。</li>
</ul>
</li>
<li>如何保证消息的幂等性?<ul>
<li>在消息生产时，MQ内部针对每条生产者发送的消息都会生成一个<code>inner-msg-id</code>作为去重和幂等的依据（消息传递失败并重传），避免重复的消息进入队列；</li>
<li>在消息消费时，要求消息体中必须要有一个<code>bizid</code>（对于同一业务全局唯一，如支付ID、订单ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</li>
</ul>
</li>
<li>你的业务系统有没做消息的重复消费处理，是怎么做的?<ul>
<li>拿到这个消息做数据库的 <code>insert</code> 操作。给这个消息一个唯一主键，那么即使出现重复消费的情况，也会因为主键冲突，而避免数据库出现脏数据。</li>
<li>拿到这个消息做Redis的 <code>set</code> 操作，无论你 <code>set</code> 几次结果都一样，<code>set</code> 操作本身就算是幂等操作。</li>
<li>用第三方介质来做消费记录。如Redis；给消息分配一个全局ID，只要消费过此消息，将以key-value的形式写入Redis。在消费者开始消费之前，先去Redis中查询有没有消费记录即可。</li>
</ul>
</li>
</ul>
<h2 id="5、消息的可靠性"><a href="#5、消息的可靠性" class="headerlink" title="5、消息的可靠性"></a>5、消息的可靠性</h2><p><strong>简介：如何保证消费的可靠性传输</strong></p>
<ul>
<li>考点：是否有研究消息队列的底层原理，保证消息的可靠性传输，消息队列的架构</li>
<li><p>你用了消息队列，你知道这个消息队列如何保证消息的可靠性传输吗？</p>
</li>
<li><p><strong>可能发生消息丢失情况的阶段</strong></p>
<ul>
<li><strong>Producer 发送消息到 Broker 失败</strong>；（发送过程中网络波动、发送到一个不存在的 Exchange等）</li>
<li><strong>Exchange 路由到 Queue 失败</strong>；Exchange 将消息根据 RoutingKey 路由到对应的 Queue 时失败；（此 Exchange 没有绑定 Queue 等）</li>
<li><strong>Consumer 处理消息失败</strong>；已经获取了消息但无法正确处理导致消息丢失（消费者来不及处理就挂掉了等）</li>
</ul>
</li>
</ul>
<p>针对以上可能发生消息丢失的情况可以采取对应的<strong>解决方案：</strong></p>
<p><strong>① Producer 发送消息到 Broker 失败 情况的解决方案：</strong></p>
<ul>
<li><p><strong>transaction 机制：</strong></p>
<ul>
<li>生产者发送数据之前开启 RabbitMQ 的事务 <code>channel.txSelect</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback</code> ，然后重试发送消息；如果收到了消息，那么可以提交事务<code>channel.txCommit</code></li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>开启事务<br>channel.txSelect<br>try &#123;<br>    <span class="hljs-regexp">//</span>这里发送消息<br>&#125; catch (Exception e) &#123;<br>    channel.txRollback<br>    <span class="hljs-regexp">//</span>回滚事务后，这里重试发送消息<br>&#125;<br><span class="hljs-regexp">//</span>提交事务<br>channel.txCommit<br>Copy<br></code></pre></td></tr></table></figure>
<ul>
<li>采用该种方法由于事务机制，会导致吞吐量下降，太消耗性能。</li>
</ul>
</li>
<li><p><strong>confirm机制：</strong>（推荐使用）</p>
<ul>
<li>使用 SpringBoot 时在 application.yml 配置文件中做如下配置</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 发送者开启 <span class="hljs-keyword">confirm</span> 确认机制<br>publisher-<span class="hljs-keyword">confirm</span>-<span class="hljs-keyword">type</span>: correlated<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure>
<ul>
<li>通过<strong>confirmCallback</strong>生产者投递消息后，如果Broker收到消息后，会给生产者一个ACK。生产者通过ACK，可以确认这条消息是否正常发送到Broker，这种方式是消息可靠性投递的核心。</li>
<li>一旦 channel 进入 confirm 模式，所有在该 channel 上的消息都会被指派一个以为的ID（从1开始），一旦消息被投递到所有匹配到的队列之后，RabbitMQ 就会发送一个 <code>ACK</code> 给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了。如果 RabbitMQ 没能处理该消息，则会发送一个 <code>Nack</code> 消息给你，你可以进行重试操作。</li>
</ul>
</li>
<li><p><strong>注意：</strong>transaction 机制和 confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</p>
</li>
</ul>
<p><strong>② Exchange 路由到 Queue 失败 情况的解决方案：</strong></p>
<ul>
<li><strong>开启 RabbitMQ 的持久化机制</strong><ul>
<li>消息写入之后会持久化到磁盘，哪怕 RabbitMQ 挂了，重启之后会自动读取之前存储的数据，一般数据不会丢失。<strong>特殊情况：除非 RabbitMQ 还没持久化就已经挂了，此时会导致少量数据丢失。</strong></li>
<li>解决特殊情况，<strong>持久化机制和 confirm 机制配合使用</strong>；可以在消息持久化磁盘之后，再给生产者发送一个 <code>ACK</code> ，这样，如果消息持久化磁盘之前，RabbitMQ 挂掉了，那么生产者收不到 <code>ACK</code> ，生产者也会自动重发处理。</li>
<li>通过<strong>returnCallback</strong>，消息从交换器发送到对应队列失败时触发</li>
</ul>
</li>
</ul>
<p><strong>③ Consumer 处理消息失败 情况的解决方案：</strong></p>
<ul>
<li><p><strong>关闭自动<code>ACK</code>，使用手动<code>ACK</code></strong></p>
<ul>
<li>使用 SpringBoot 时在 application.yml 配置文件中做如下配置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">listener:</span><br>	<span class="hljs-attr">simple:</span><br>    <span class="hljs-comment"># 设置消费端手动 ack</span><br>    <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br><span class="hljs-string">Copy</span><br></code></pre></td></tr></table></figure>
<ul>
<li>如果消费者来不及处理就挂掉了，没有响应<code>ACK</code>时会重复发送一条信息给其他的消费者</li>
<li>如果出现了异常，且不对异常进行捕获，就会一直重复接受消息，然后一直抛异常。</li>
<li>如果对异常进行了捕获，但是没有在 finally 里<code>ACK</code>，也会一直重复发送消息（<strong>重试机制</strong>）</li>
<li>我们只需要保证幂等性就好了，重复消费也不会造成问题。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@RabbitHandler<br>public void handler<span class="hljs-constructor">Mq(String <span class="hljs-params">msg</span>, Channel <span class="hljs-params">channel</span>, Message <span class="hljs-params">message</span>)</span> throws IOException &#123;<br>	<span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">//业务处理代码</span><br>	...... <br>	<span class="hljs-comment">//手动ACK</span><br>		channel.basic<span class="hljs-constructor">Ack(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>);<br>	&#125; catch (Exception e) &#123;<br>		<span class="hljs-keyword">if</span> (message.get<span class="hljs-constructor">MessageProperties()</span>.get<span class="hljs-constructor">Redelivered()</span>) &#123;<br>			log.error(<span class="hljs-string">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>, e);<br>			<span class="hljs-comment">//拒绝消息</span><br>			channel.basic<span class="hljs-constructor">Reject(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>); <br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			log.error(<span class="hljs-string">&quot;消息即将再次返回队列处理...&quot;</span>, e);<br>			channel.basic<span class="hljs-constructor">Nack(<span class="hljs-params">message</span>.<span class="hljs-params">getMessageProperties</span>()</span>.get<span class="hljs-constructor">DeliveryTag()</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6、消息堆积的处理"><a href="#6、消息堆积的处理" class="headerlink" title="6、消息堆积的处理"></a>6、消息堆积的处理</h2><p><strong>简介：如果消息大量堆积在broker里面，应该怎么处理</strong></p>
<ul>
<li>考点：是否有研究消息队列不可用后的应急方案，是否有架构思维</li>
<li>线上故障了，怎么处理？<ul>
<li>消息堆积了10小时，有几千万条消息待处理，现在怎么办?</li>
<li>修复consumer, 然后慢慢消费？也需要几小时才可以消费完成，新的消息怎么办？</li>
</ul>
</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">核心思想：紧急临时扩容，更快的速度去消费数据<br><br><span class="hljs-bullet">- </span>修复Consumer不消费问题，使其恢复正常消费，根据业务需要看是否要暂停<br><br><span class="hljs-bullet">- </span>临时topic队列扩容，并提高消费者能力，但是如果增加Consumer数量，但是堆积的topic里面的message queue数量固定，过多的consumer不能分配到message queue<br><br><span class="hljs-bullet">- </span>编写临时处理分发程序，从旧topic快速读取到临时新topic中，新topic的queue数量扩容多倍，然后再启动更多consumer进行在临时新的topic里消费<br><br><span class="hljs-bullet">- </span>直到堆积的消息处理完成，再还原到正常的机器数量<br></code></pre></td></tr></table></figure>
<p><img src="后端面试/image-18.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="后端面试/image-19.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="后端面试/image-20.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h1 id="九、MySQL数据库"><a href="#九、MySQL数据库" class="headerlink" title="九、MySQL数据库"></a>九、MySQL数据库</h1><h2 id="1、ACID"><a href="#1、ACID" class="headerlink" title="1、ACID"></a>1、ACID</h2><p><strong>简介：是否掌握事务的ACID原理</strong></p>
<ul>
<li>考点：是否掌握事务的ACID原理</li>
<li>你知道Mysql事务的四大特性不，简单说下？<ul>
<li><strong>原子性Atomicity</strong>：一个事务必须是不可分割的最小工作单元，整个操作要么全部成功，要么全部失败，一般就是通过commit和rollback来控制。</li>
<li><strong>一致性Consistency</strong>：数据库总能从一个一致性的状态转换到另一个一致性的状态。</li>
<li><strong>隔离性Isolation</strong>：一个事务相对于另一个事务是隔离的，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
<li><strong>持久性Durability</strong>：一旦事务提交，其所做的修改就会永久保存到数据库，即使系统崩溃，修改的数据也不会丢失</li>
</ul>
</li>
</ul>
<h2 id="2、脏读-不可重复读-幻读"><a href="#2、脏读-不可重复读-幻读" class="headerlink" title="2、脏读-不可重复读-幻读"></a>2、脏读-不可重复读-幻读</h2><p><strong>简介：考查数据库隔离级别导致的问题</strong></p>
<ul>
<li><p>考点：是否掌握数据库常见隔离级别和对应导致的问题</p>
</li>
<li><p>能否简单解释下脏读、不可重复读、幻读的意思</p>
<ul>
<li><p><strong>脏读</strong>：一个事务读取到另外一个事务未提交的数据</p>
<p>​    例子：A向B转账，<strong>A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了</strong>！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。</p>
</li>
<li><p><strong>不可重复读</strong>：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改</p>
<p>​    注：<strong>A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了】</strong></p>
</li>
<li><p><strong>幻读(虚读)</strong>：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</p>
<p>​    注：<strong>和不可重复读类似，但幻读(虚读)会读到其他事务的插入的数据，导致前后读取不一致</strong></p>
</li>
</ul>
<p><strong>不可重复读和幻读有什么区别呢？</strong></p>
<ul>
<li>不可重复读的重点是内容修改或者记录减少，比如多次读取一条记录发现其中某些记录的值被修改；</li>
<li>幻读的重点在于记录新增，比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>
</ul>
</li>
<li><p>常见的隔离级别由低到高有哪几种，mysql默认是哪种?</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<strong>【MySQL默认是REPEATABLE-READ(可重复读)】</strong></li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>×代表无法解决，√代表能解决</p>
</blockquote>
<h2 id="3、MySQL的存储引擎"><a href="#3、MySQL的存储引擎" class="headerlink" title="3、MySQL的存储引擎"></a>3、MySQL的存储引擎</h2><p><strong>简介：考查mysql的存储引擎</strong></p>
<ul>
<li><p>考点：是否知道Mysql的存储引擎及其区别</p>
</li>
<li><p>说下你知道Mysql常见的存储引擎，新版Mysql默认是哪个</p>
<ul>
<li><strong>Innodb引擎</strong>，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li><strong>MyISAM引擎</strong>(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。</li>
<li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">新版本MySQL 5.5以后默认是Innodb；MySQL 5.5以前默认是MyISAM<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>mysql的存储引擎 Innodb和MyISAM有什么区别，应该怎么选择？</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">区别项</th>
<th style="text-align:center">Innodb</th>
<th style="text-align:center">MyISAM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">事务</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">锁粒度</td>
<td style="text-align:center">行锁，适合高并发</td>
<td style="text-align:center">表锁，不适合高并发</td>
</tr>
<tr>
<td style="text-align:center">是否默认</td>
<td style="text-align:center">默认</td>
<td style="text-align:center">非默认</td>
</tr>
<tr>
<td style="text-align:center">支持外键</td>
<td style="text-align:center">支持外键</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">适合场景</td>
<td style="text-align:center">读写均衡、写大于读、需要事务</td>
<td style="text-align:center">读多写少、不需要事务</td>
</tr>
<tr>
<td style="text-align:center">全文索引</td>
<td style="text-align:center">不支持，可以通过插件实现, 更多使用ElasticSearch</td>
<td style="text-align:center">支持全文索引</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>InnoDB 是聚簇索引；InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效</p>
<p>MyISAM 是非聚簇索引；MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据</p>
</blockquote>
<h2 id="4、MySQL的索引"><a href="#4、MySQL的索引" class="headerlink" title="4、MySQL的索引"></a>4、MySQL的索引</h2><p><strong>简介：考查mysql的功能索引掌握情况</strong></p>
<ul>
<li>考点：mysql的功能索引</li>
<li>mysql常用的功能索引有哪些？分别在什么场景下使用？创建语句是怎样的？</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">索引名称</th>
<th style="text-align:center">特点</th>
<th style="text-align:left">创建语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通索引</td>
<td style="text-align:center">最基本的索引,加速查询</td>
<td style="text-align:left">CREATE INDEX idx_name ON table_name(filed_name)</td>
</tr>
<tr>
<td style="text-align:center">唯一索引</td>
<td style="text-align:center">加速查询，列值唯一，允许为空； <br />组合索引则列值的组合必须唯一</td>
<td style="text-align:left">CREATE UNIQUE INDEX idx_name ON table_name(filed_name_1,filed_name_2)</td>
</tr>
<tr>
<td style="text-align:center">主键索引</td>
<td style="text-align:center">加速查询，列值唯一 <br />一个表只有1个，不允许有空值</td>
<td style="text-align:left">ALTER TABLE table_name ADD PRIMARY KEY ( filed_name )</td>
</tr>
<tr>
<td style="text-align:center">组合索引</td>
<td style="text-align:center">加速查询，多条件组合查询</td>
<td style="text-align:left">CREATE INDEX idx_name ON table_name(filed_name_1,filed_name_2);</td>
</tr>
<tr>
<td style="text-align:center">覆盖索引</td>
<td style="text-align:center">索引包含所需要的字段，不需要“回表”查询； <br />比如查询的两个字段，刚好是组合索引的两个字段</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">全文索引</td>
<td style="text-align:center">对内容进行分词搜索，仅可用于Myisam， 更多用ElasticSearch做搜索</td>
<td style="text-align:left">ALTER TABLE table_name ADD FULLTEXT ( filed_name</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>数据库索引的优缺点？</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
</li>
<li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，当对表中的数据进行增/删/改的时候，索引也要动态的维护，会降低增/删/改的执行效率；</li>
<li>空间方面：索引需要占用物理空间</li>
</ul>
</li>
</ul>
</li>
<li><p>索引的最佳实践？</p>
<ul>
<li>前缀索引，特别是TEXT和BLOG类型的字段，只检索前面几个字符，提高检索速度</li>
<li>尽量使用数据量少的索引，索引值过长查询速度会受到影响</li>
<li>选择合适的索引列顺序</li>
<li>内容变动少，且查询频繁，可以建立多个索引</li>
<li>内容变动频繁，谨慎创建索引</li>
<li>根据业务创建适合的索引类型，比如某个字段常用来做查询条件，才为这个字段建立索引来提高查询速度</li>
<li>组合索引选择业务查询最相关的字段</li>
</ul>
</li>
</ul>
<h1 id="十、数据库设计"><a href="#十、数据库设计" class="headerlink" title="十、数据库设计"></a>十、数据库设计</h1><h2 id="1、数据库查询关键词执行顺序"><a href="#1、数据库查询关键词执行顺序" class="headerlink" title="1、数据库查询关键词执行顺序"></a>1、数据库查询关键词执行顺序</h2><p><strong>简介：数据库查询指令的执行顺序</strong></p>
<ul>
<li>考点：考查数据库查询指令的执行顺</li>
<li>MySQL数据库查询的指令有多个，说下执行顺序 select、where、from、group by、having、order by、limit<ol>
<li><strong>FROM阶段</strong>：标识出查询的来源表，并处理表运算符</li>
<li><strong>WHERE阶段</strong>：初步过滤条件，此时数据还没有分组，所以不能在WHERE中出现对统计的过滤</li>
<li><strong>GROUP BY阶段</strong>：过滤后进行分组，在GROUP BY阶段，数据库认为两个NULL值是相等的，因此会将NULL值分到同一个分组中</li>
<li><strong>HAVING阶段</strong>：对分组后的数据进行二次过滤，COUNT(expr) 会返回expr不为NULL的行数，count(1)、count(*)会返回包括NULL值在内的所有数量</li>
<li><strong>SELECT阶段</strong>：查看哪些结果字段</li>
<li><strong>ORDER BY阶段</strong>：按照怎样的顺序进行排序返回，如果不指定排序，数据并非总是按照主键顺序进行排序的。NULL被视为最小值</li>
<li><strong>LIMIT阶段</strong>：指定返回的记录数，LIMIT n, m的效率是十分低的，一般可以通过在WHERE条件中指定范围来优化 WHERE id &gt; ? limit 10</li>
</ol>
</li>
</ul>
<h2 id="2、数据库表的字段类型"><a href="#2、数据库表的字段类型" class="headerlink" title="2、数据库表的字段类型"></a>2、数据库表的字段类型</h2><p><strong>简介：设计数据库的时候相似类型的字段区分</strong></p>
<ul>
<li><p>考点：是否知道常用的相似字段他们的区别</p>
</li>
<li><p>MySQL中的varchar和char有什么区别，应该怎么选择？</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对比项</th>
<th style="text-align:center">char(16)</th>
<th style="text-align:center">varchar(16)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">长度特点</td>
<td style="text-align:center">长度固定，存储字符</td>
<td style="text-align:center">长度可变，存储字符</td>
</tr>
<tr>
<td style="text-align:center">长度不足情况</td>
<td style="text-align:center">插入的长度小于定义长度时，则右侧用空格填充</td>
<td style="text-align:center">小于定义长度时，按实际插入长度存储</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">存取速度较快</td>
<td style="text-align:center">存取速度较慢</td>
</tr>
<tr>
<td style="text-align:center">使用场景</td>
<td style="text-align:center">适合存储很短的,固定长度的字符串,如手机号，MD5值等</td>
<td style="text-align:center">适合用在长度不固定场景，如收货地址，邮箱地址等</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>MySQL中的datetime和timestamp有什么区别？</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类型</td>
<td style="text-align:left">占据字节</td>
<td style="text-align:left">范围</td>
<td style="text-align:left">时区问题</td>
</tr>
<tr>
<td style="text-align:left">datetime</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">1000-01-01 00:00:00到 9999-12-31 23:59:59</td>
<td style="text-align:left">存储与时区无关，不会发生改变</td>
</tr>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">1970-01-01 00:00:01 到 2038-01-19 11:14:07</td>
<td style="text-align:left">存储的是与时区有关，随数据库的时区而发生改变</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>为什么timestamp只能到2038年？</li>
</ul>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">MySQL的timestamp类型是4个字节，最大值是(2的31次方)<span class="hljs-string">-1</span>，结果是2147483647，<br>转换成北京时间就是2038<span class="hljs-string">-01</span><span class="hljs-string">-19</span> 11:14:07<br></code></pre></td></tr></table></figure>
<h2 id="3、数据表分页优化"><a href="#3、数据表分页优化" class="headerlink" title="3、数据表分页优化"></a>3、数据表分页优化</h2><p><strong>简介：针对海量数据sql分页优化思路</strong></p>
<ul>
<li>考点：是否有海量数据分页优化思路</li>
<li>线上数据库的一个商品表数据量过千万，做深度分页的时候性能很慢，有什么优化思路？</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">现象：千万级别数据很正常，比如数据流水、日志记录等，数据库正常的深度分页会很慢<br>慢的原因：<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> product <span class="hljs-keyword">limit</span> M,N<br>MySQL执行此类<span class="hljs-keyword">SQL</span>时是从第M+<span class="hljs-number">1</span>行开始显示，一共显示N条（显示的记录是M+<span class="hljs-number">1</span>，M+N）所以M越大,MySQL扫描的记录数越多，<span class="hljs-keyword">SQL</span>的性能就会越差<br><br><span class="hljs-number">1</span>、后端、前端缓存<br><br><span class="hljs-number">2</span>、使用ElasticSearch分页搜索<br><br><span class="hljs-number">3</span>、合理使用 mysql 查询缓存，覆盖索引进行查询分页<br>  <span class="hljs-keyword">select</span> title,cateory <span class="hljs-keyword">from</span> product <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">100</span><br>  <br><span class="hljs-number">4</span>、如果id是自增且不存在中间删除数据，使用子查询优化，定位偏移位置的 id<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">100</span>; //<span class="hljs-number">5.</span>秒<br>      <br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">1</span>; // <span class="hljs-number">0.4</span>秒 <br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">and</span>  id&gt;=(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> oper_log <span class="hljs-keyword">where</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;BUY&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">limit</span> <span class="hljs-number">100</span>; //<span class="hljs-number">0.8</span>秒 <br></code></pre></td></tr></table></figure>
<h2 id="4、数据库应用版本更新"><a href="#4、数据库应用版本更新" class="headerlink" title="4、数据库应用版本更新"></a>4、数据库应用版本更新</h2><p><strong>简介：数据库上线流程，版本更新流程</strong></p>
<ul>
<li>考点：是否有正确的数据库部署流程</li>
<li>你公司里面产品迭代更新，开发好代码和数据库，上线流程是怎样的？</li>
</ul>
<p><img src="后端面试/image-21.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h1 id="十一、数据库性能监控和优化"><a href="#十一、数据库性能监控和优化" class="headerlink" title="十一、数据库性能监控和优化"></a>十一、数据库性能监控和优化</h1><h2 id="1、生产环境的数据库的安全保证"><a href="#1、生产环境的数据库的安全保证" class="headerlink" title="1、生产环境的数据库的安全保证"></a>1、生产环境的数据库的安全保证</h2><p><strong>简介：生成环境监控指标和安全</strong></p>
<ul>
<li><p>考点：是否有监控和数据安全思维</p>
</li>
<li><p>针对线上的数据库，你会做哪些监控？，业务性能 + 数据安全的角度分析</p>
<ul>
<li><p><strong>业务性能</strong>：</p>
<ol>
<li><p>应用上线前会审查业务新增的sql、分析sql执行计划</p>
<p>​    比如是否存在 select *    索引建立是否合理</p>
</li>
<li><p>开启慢查询日志，定期分析慢查询日志</p>
</li>
<li><p>监控CPU/内存利用率、读写、网关IO、流量带宽 随着时间变化的统计图</p>
</li>
<li><p>吞吐量QPS/TPS 一天内随着时间变化的统计图</p>
</li>
</ol>
</li>
<li><p><strong>数据安全</strong>：</p>
<ol>
<li>短期增量备份，比如一周一次。定期全量备份，比如一月一次</li>
<li>检查是否存在非授权用户、是否存在弱口令，进行网络防火墙检查</li>
<li>导出数据是否进行脱敏，防止数据泄露或者黑产利用</li>
<li>数据库进行全量操作日志审计，防止数据泄露</li>
<li>数据库账号密码根据业务进行独立，权限独立控制，防止多库共用同一个账号密码</li>
<li>高可用时采用主从架构、多机房部署</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2、MySQL中的日志"><a href="#2、MySQL中的日志" class="headerlink" title="2、MySQL中的日志"></a>2、MySQL中的日志</h2><p><strong>简介：mysql常见日志的考查</strong></p>
<ul>
<li><p>考点：mysql常见日志种类和作用</p>
</li>
<li><p>Mysql有多少种常见的日志？分别解释日志的作用</p>
<ol>
<li><p><strong>redo 重做日志</strong></p>
<p>​    确保事务的持久性，防止在发生故障时，脏页未写入磁盘。重启数据库会进行<strong>redo log</strong>执行重做，达到事务一致性</p>
<blockquote>
<p>脏页：内存数据页与磁盘内存页的内容不一致时的内存页叫做脏页</p>
</blockquote>
</li>
<li><p><strong>undo 回滚日志</strong></p>
<p>​    保证数据的原子性，记录事务发生之前数据的一个版本，用于回滚</p>
<blockquote>
<p>MVCC的实现就是依赖于：隐藏字段、Read View、undo log</p>
</blockquote>
</li>
<li><p><strong>errorlog 错误日志</strong></p>
<p>​    记录MySQL本身启动、停止、运行期间发生的错误信息</p>
</li>
<li><p><strong>slow query log 慢查询日志</strong></p>
<p>​    记录执行时间过程的sql，时间阈值可以配置，只记录执行成功</p>
</li>
<li><p><strong>binlog 二进制日志</strong></p>
<p>​    用于数据库的数据备份、主备、主主、主从 ，保证数据一致性</p>
</li>
<li><p><strong>relay log 中继日志</strong></p>
<p>​    用于数据库主从同步，将主库发送来的binlog先保存在本地，然后在从库进行重放</p>
</li>
<li><p><strong>general log 普通日志</strong></p>
<p>​    记录数据库操作明细，默认关闭，因为开启会降低数据库性能</p>
</li>
</ol>
</li>
</ul>
<h2 id="3、数据库的主从同步"><a href="#3、数据库的主从同步" class="headerlink" title="3、数据库的主从同步"></a>3、数据库的主从同步</h2><p><strong>简介：数据库主从的用途、原理流程</strong></p>
<ul>
<li>考点：是否搭建过主从，并掌握原理</li>
<li>解释下主从复制中的异步复制原理？</li>
</ul>
<p><img src="后端面试/image-22.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><p>搭建数据库主从同步的目的是什么？</p>
<ol>
<li>业务需要，进行读写分离，减少主库压力</li>
<li>容灾使用，用于故障切换</li>
</ol>
</li>
<li><p>同步延迟问题如何解决？</p>
<p>保证性能的情况下，无法百分百的解决，只能缓解</p>
<p><strong>现象</strong>：大量数据的场景下，主库的数据已经写入，但从库中还没有</p>
<p><strong>原因</strong>：</p>
<ol>
<li>主从复制是单线程操作，当主库TPS过高，产生的数据量超过从库SQL执行的执行能力</li>
<li>从库执行了某些很大的SQL操作，导致阻塞等待</li>
<li>服务器硬件问题，如磁盘、CPU、网络延迟</li>
</ol>
<p><strong>缓解方法</strong>：</p>
<ol>
<li>引入缓存；写入主库后，再写入缓存，读取的时候可以先读缓存，没命中再去读从库</li>
<li>读写分离；一主多从，分散主库和从库的压力</li>
<li>提高硬件配置；比如使用SSD固态硬盘、更好的CPU和网络</li>
<li>进行分库分表；减少单机数据库的压力</li>
</ol>
</li>
</ul>
<p><img src="后端面试/image-23.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>什么场景下会出现主从数据不一致？<ol>
<li>复制的延迟导致</li>
<li>主库或从库宕机都会导致复制中断</li>
<li>把一个从库升级为主库时，也可能会导致</li>
</ol>
</li>
<li>主从一致性校验和修复如何做？</li>
</ul>
<p>​    Mysql主从复制是基于binlog复制，难免出现复制数据不一致的风险，导致用户数据访问前后不一致的问题<br>所以要定期开展主从复制数据一致性的校验并修复</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stata">使用Percona公司下的工具<br><br>pt-<span class="hljs-keyword">table</span>-<span class="hljs-keyword">checksum</span>工具进行一致性校验<br><br>  原理：<br>  主库利用表中的索引，将表的数据切割成一个个chunk(块)，然后进行计算得到<span class="hljs-keyword">checksum</span>值。<br>  从库也执相应的操作，并在从库上计算相同数据块的<span class="hljs-keyword">checksum</span>，然后对比主从中各个表的<span class="hljs-keyword">checksum</span>是否一致并存储到数据库，最后通过存储校验结果的表就可以判断出哪些表的数据不一致<br><br><br>pt-<span class="hljs-keyword">table</span>-sync(在从库执行)工具进行数据不一致的修复，可以修复主从结构数据的不一致，也可以修复非主从结构数据的不一致<br><br>  原理：在主库上执行数据的更改，再同步到从库上，不会直接更改成从的数据。在主库上执行更改是基于主库现有的数据，不会更改主库上的数据，可以同步某些表或整个库的数据，但它不会同步表结构、索引，只同步不一致的数据<br><br><br>注意：<br>  默认主库要检查的表在从库都存在，并且同主库表有相同的表结构<br>  如果表中没有索引，pt-<span class="hljs-keyword">table</span>-<span class="hljs-keyword">checksum</span>将没法处理，一般最基本的主键索引要有<br>  pt-<span class="hljs-keyword">table</span>-sync工具会修改数据，使用前最好备份下数据，防止误操作<br></code></pre></td></tr></table></figure>
<ul>
<li>pt-table-checksum怎么保证在计算某个chunk的时候checksum数据一致性？</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">当pt工具在计算主库上某chunk的<span class="hljs-keyword">checksum</span>时，主库可能在更新且从库可能复制延迟，那该怎么保证主库与从库计算的是”同一份”数据，答案把要<span class="hljs-keyword">checksum</span>的行加上<span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>锁并计算，这保证了主库的某个chunk内部数据的一致性<br></code></pre></td></tr></table></figure>
<h1 id="十二、HTTP协议"><a href="#十二、HTTP协议" class="headerlink" title="十二、HTTP协议"></a>十二、HTTP协议</h1><h2 id="1、HTTP协议核心知识"><a href="#1、HTTP协议核心知识" class="headerlink" title="1、HTTP协议核心知识"></a>1、HTTP协议核心知识</h2><p><strong>简介：http状态码和method知识点考查</strong></p>
<ul>
<li>考点：是否掌握Http基础知识，遵循开发规范</li>
<li>常见的Http Method有哪些，使用场景分别是？<ul>
<li><strong>HTTP 1.0</strong> 定义的三种：<ol>
<li>GET：向服务器获取资源，比如常见的查询请求</li>
<li>POST：向服务器提交数据而发送的请求</li>
<li>HEAD：和GET类似，返回的响应中没有具体的内容，用于获取报文头</li>
</ol>
</li>
<li><strong>HTTP 1.1</strong> 定义的六种：<ol>
<li>PUT：一般用于更新请求，比如更新个人信息、商品信息，采用全量更新</li>
<li>PATCH：是PUT方法的补充，更新指定资源的部分数据</li>
<li>DELETE：用于删除指定的资源</li>
<li>OPTIONS：获取服务器支持的HTTP请求方式，服务器性能、跨域检查等</li>
<li>CONNECT：把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据返回给用户；一般网页开发基本不用这个，如果是HTTP代理才会使用，类似于中介</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li>
</ol>
</li>
</ul>
</li>
<li>常见HTTP状态码有哪些？<ul>
<li>1XX：收到请求，需要请求者继续执行操作，很少使用</li>
<li>2XX：请求成功，常用的200</li>
<li>3XX：重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location中获取；网站改版、域名迁移等，多个域名指向同一个主站导流<ul>
<li>301 永久性跳转，比如域名过期，换个域名</li>
<li>302 临时性跳转</li>
</ul>
</li>
<li>4XX：客户端出错，比如语法错误、请求无法完成<ul>
<li>400 请求出错，比如语法协议</li>
<li>403 无访问权限</li>
<li>404 找不到路径对应的接口或者文件</li>
<li>405 提交方式错误，Method not allowed</li>
</ul>
</li>
<li>5XX：服务端出错，服务器在处理请求的过程中发生了错误<ul>
<li>500 服务器内部报错，无法完成请求</li>
<li>503 服务器宕机</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、HTTP协议无状态解决方法之Cookie和Session"><a href="#2、HTTP协议无状态解决方法之Cookie和Session" class="headerlink" title="2、HTTP协议无状态解决方法之Cookie和Session"></a>2、HTTP协议无状态解决方法之Cookie和Session</h2><p><strong>简介：单机情况下 http无状态解决方案，cookie和session</strong></p>
<ul>
<li>考点：是否掌握cookie和session知识点</li>
<li>说下Cookie和Session的区别和联系<ul>
<li>cookie数据保存在客户端；session数据保存在服务端</li>
<li>cookie不是很安全，容易泄露，不能直接明文存储信息</li>
<li>cookie存储的大小和数量有限制</li>
</ul>
</li>
</ul>
<h2 id="3、HTTP协议分布式业务无状态解决方法之JWT"><a href="#3、HTTP协议分布式业务无状态解决方法之JWT" class="headerlink" title="3、HTTP协议分布式业务无状态解决方法之JWT"></a>3、HTTP协议分布式业务无状态解决方法之JWT</h2><p><strong>简介：分布式业务场景的常见登录解决方案JWT</strong></p>
<ul>
<li><p>考点：是否知道JWT</p>
</li>
<li><p>你们公司是用JWT做集群的登录解决是不是，能否介绍下JWT</p>
<ul>
<li><p>JWT 是一个开放标准，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>
</li>
<li><p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>
<ul>
<li>Header 头部：主要描述签名的算法</li>
<li>Payload 负载：主要描述加密对象的信息，比如用户的id、iss签发者、exp过期时间、sub面向的用户等</li>
<li>Signature 签名：主要是把前面两部分进行加密吗，防止别人拿到token进行base解密之后篡改token</li>
</ul>
<p>因此，一个典型的JWT看起来是这个样子的：</p>
<blockquote>
<p>xxxxx.yyyyy.zzzzz</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>简单来说: 就是通过一定规范来生成token，然后可以通过解密算法逆向解密token，这样就可以获取用户信息</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&#123;<br>          id:<span class="hljs-number">666</span>,<br>          <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>          expire:<span class="hljs-number">10000</span><br>      &#125;<br>          <br>      funtion 加密(<span class="hljs-keyword">object</span>, appsecret)&#123;<br>          xxxx<br>          <span class="hljs-keyword">return</span> base64( token);<br>      &#125;<br>      <br>      <span class="hljs-keyword">function</span> 解密(token ,appsecret)&#123;<br>          xxxx<br>          //成功返回<span class="hljs-keyword">true</span>,失败返回<span class="hljs-keyword">false</span><br>      &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用 JWT 的优缺点有哪些？<ul>
<li>优点：<ul>
<li>生成的token可以包含基本信息，比如id、昵称等信息，避免再次查库</li>
<li>存储在客户端，不需要占用服务端的内存资源，使用加解密的方式进行校验，在分布式业务中能较好地提高性能和节省空间</li>
</ul>
</li>
<li>缺点：<ul>
<li>token是经过base64编码的，所以是可以进行解码的，因此token加密前的对象不应该包含敏感信息，比如用户权限、密码等</li>
<li>如果没有服务端存储，则不能做登录失效处理，除非服务端该密钥</li>
</ul>
</li>
</ul>
</li>
<li>生成的token在客户端或者浏览器中具体是如何存储的？<ul>
<li>可以存储在cookie、localStorage、sessionStorage</li>
</ul>
</li>
</ul>
<h2 id="4、HTTP请求从产生到响应的链路"><a href="#4、HTTP请求从产生到响应的链路" class="headerlink" title="4、HTTP请求从产生到响应的链路"></a>4、HTTP请求从产生到响应的链路</h2><p><strong>简介：浏览器网络请求链路</strong></p>
<ul>
<li><p>考点：是否掌握http请求产生到响应的链路</p>
</li>
<li><p>说下常用浏览器输入一个 url 到用户看到结果，中间经过哪些流程？</p>
<ol>
<li>浏览器输入 url，解析 url 是否合法</li>
<li>浏览器检查是否有缓存，如果有则直接显示；没有就进行下一步</li>
<li>进行域名解析（DNS解析），解析获取对应的 IP 地址</li>
<li>浏览器向服务器发送 tcp 连接，完成 tcp 三次握手</li>
<li>握手成功后，浏览器向服务器发送 http 请求</li>
<li>服务器收到处理的请求后，将数据返回到浏览器</li>
<li>浏览器接受 http 响应</li>
<li>浏览器解析响应，如果响应需要缓存，则存入到缓存中</li>
<li>浏览器进行页面渲染</li>
</ol>
</li>
</ul>
<h2 id="5、浏览器同源策略和跨域"><a href="#5、浏览器同源策略和跨域" class="headerlink" title="5、浏览器同源策略和跨域"></a>5、浏览器同源策略和跨域</h2><p><strong>简介：什么是浏览器的同源策略和跨域知识点</strong></p>
<ul>
<li><p>考点：同源策略和跨域知识点</p>
</li>
<li><p>你是否知道什么是浏览器同源策略</p>
<ul>
<li><strong>同源策略</strong>：是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</li>
</ul>
<p>如果两个 URL 的 protocol、port(en-US)如果有指定的话) 和 host 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p>
<p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例：</p>
<p>| URL                                               | 结果 | 原因                                |<br>| :———————————————————————— | :—- | :————————————————— |<br>| <code>http://store.company.com/dir2/other.html</code>        | 同源 | 只有路径不同                        |<br>| <code>http://store.company.com/dir/inner/another.html</code> | 同源 | 只有路径不同                        |<br>| <code>https://store.company.com/secure.html</code>           | 失败 | 协议不同                            |<br>| <code>http://store.company.com:81/dir/etc.html</code>        | 失败 | 端口不同 ( <code>http://</code> 默认端口是 80) |<br>| <code>http://news.company.com/dir/other.html</code>          | 失败 | 主机不同                            |</p>
<ul>
<li>同源策略的限制<ul>
<li>不能读写Cookie、Session Storage、Local Storage、Cache、Indexed DB</li>
<li>DOM 和 JS对象无法获得</li>
<li>AJAX请求不能发送</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么会出现跨域，有什么常见的解决方案?</p>
<ul>
<li><p><strong>跨域</strong>：浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任何一个不同，就属于跨域</p>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li><p>JSONP</p>
</li>
<li><p>页面这层再包装一层服务，目前最多就是nodejs</p>
</li>
<li><p>Http响应头配置允许跨域</p>
<ul>
<li><p>nginx代理服务器</p>
</li>
<li><p>后端程序代码配置</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">程序代码中处理 SpringBoot 通过拦截器配置<br>     <br><span class="hljs-comment">//表示接受任意域名的请求,也可以指定域名</span><br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-params">request</span>.<span class="hljs-params">getHeader</span>(<span class="hljs-string">&quot;origin&quot;</span>)</span>);<br>     <br><span class="hljs-comment">//该字段可选，是个布尔值，表示是否可以携带cookie</span><br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)</span>;<br>     <br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS&quot;</span>)</span>;<br>     <br>response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="十三、Spring-Mybatis框架"><a href="#十三、Spring-Mybatis框架" class="headerlink" title="十三、Spring-Mybatis框架"></a>十三、Spring-Mybatis框架</h1><h2 id="1、Spring框架核心知识点"><a href="#1、Spring框架核心知识点" class="headerlink" title="1、Spring框架核心知识点"></a>1、Spring框架核心知识点</h2><p><strong>简介：常见的spring核心知识点考查</strong></p>
<ul>
<li><p>考点：spring的核心理念</p>
</li>
<li><p>能否介绍下什么是Spring框架的 IOC 和 DI </p>
<ul>
<li>IOC 控制反转：将对象的创建权，反转到Spring容器</li>
<li>DI 依赖注入：Spring创建对象的过程中，将对象依赖的属性通过配置的方式进行注入，在IOC的基础上完成</li>
</ul>
<p>IOC 和 DI 是从不同的角度描述同样的一件事，通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦</p>
</li>
<li><p>Spring里面 bean的scope作用域有哪些，能否解释下？</p>
<ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次di奥永getBean方法时都会创建不同的对象，会频繁的创建和销毁对象。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>
</ul>
</li>
</ul>
<h2 id="2、AOP面向切面编程"><a href="#2、AOP面向切面编程" class="headerlink" title="2、AOP面向切面编程"></a>2、AOP面向切面编程</h2><p><strong>简介：Spring常见面试题AOP</strong></p>
<ul>
<li><p>考点：Spring的AOP相关知识点考查</p>
</li>
<li><p>谈谈你对AOP的理解？</p>
<ul>
<li>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</li>
<li>AOP思想把功能分两个部分，分离系统中的各种关注点<ul>
<li>核心关注点<ul>
<li>业务的主要功能</li>
</ul>
</li>
<li>横切关注点<ul>
<li>非核心、额外增加的功能</li>
</ul>
</li>
<li>用户下单为例子<ul>
<li>核心关注点：创建订单</li>
<li>横切关注点：记录日志、控制事务</li>
</ul>
</li>
</ul>
</li>
<li>好处<ul>
<li>减少代码侵入，解耦</li>
<li>可以统一处理横切逻辑</li>
<li>方便添加和删除横切逻辑</li>
</ul>
</li>
</ul>
</li>
<li><p>能否解释下AOP里面常见的概念，比如 横切、通知、连接点、切入点、切面 ？</p>
<ul>
<li>横切关注点<ul>
<li>对哪些方法进行拦截，拦截后怎么处理，这些就叫横切关注点</li>
<li>比如 权限认证、日志、事务</li>
</ul>
</li>
<li>通知 Advice<ul>
<li>在特定的切入点上执行的增强处理</li>
<li>做啥？ 比如你需要记录日志，控制事务 ，提前编写好通用的模块，需要的地方直接调用</li>
</ul>
</li>
<li>连接点 JointPoint<ul>
<li>需要用到通知的地方，业务流程在运行过程中需要插入切面的具体位置，</li>
<li>一般是方法的调用前后，全部方法都可以是连接点</li>
<li>只是概念，没啥特殊</li>
</ul>
</li>
<li>切入点 Pointcut<ul>
<li>不能全部方法都是连接点，通过特定的规则来筛选连接点, 就是Pointcut，选中那几个你想要的方法</li>
<li>在程序中主要体现为书写切入点表达式（通过通配、正则表达式）过滤出特定的一组 JointPoint连接点</li>
<li>过滤出相应的 Advice 将要发生的joinpoint地方</li>
</ul>
</li>
<li>切面 Aspect<ul>
<li>通常是一个类，里面定义 <strong>切入点+通知</strong> , 定义什么地方、 什么时间点、做什么事情</li>
<li><strong>通知 advice指明了时间和做的事情（前置、后置等）</strong></li>
<li><strong>切入点 pointcut 指定在什么地方干这个事情</strong></li>
<li>web接口设计中，web层-&gt;网关层-&gt;服务层-&gt;数据层，每一层之间也是一个切面，对象和对象，方法和方法之间都是切面</li>
</ul>
</li>
<li><p>目标 target</p>
<ul>
<li>目标类，真正的业务逻辑，可以在目标类不知情的条件下，增加新的功能到目标类的链路上</li>
</ul>
</li>
<li><p>织入 Weaving</p>
<ul>
<li>把切面（某个类）应用到目标函数的过程称为织入</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="后端面试/image-24.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="3、Spring-AOP代理模式"><a href="#3、Spring-AOP代理模式" class="headerlink" title="3、Spring AOP代理模式"></a>3、Spring AOP代理模式</h2><p><strong>简介：Spring常见面试题静态代理和动态代理</strong></p>
<ul>
<li><p>考点：静态代理和动态代理知识点考查</p>
</li>
<li><p>能否解释下什么是静态代理？</p>
<ul>
<li>什么是静态代理<ul>
<li>由程序创建或特定工具自动生成源代码，在程序运行前，代理类的.class文件就已经存在</li>
<li>通过将目标类与代理类实现同一个接口，让代理类持有真实类对象，然后在代理类方法中调用真实类方法，在调用真实类方法的前后添加我们所需要的功能扩展代码来达到增强的目的</li>
</ul>
</li>
<li>优点<ul>
<li>代理使得客户端不需要知道实现类是什么，只需知道代理即可</li>
<li>方便增加功能，拓展业务逻辑</li>
</ul>
</li>
<li>缺点<ul>
<li>代理类中出现大量冗余的代码，非常不利于扩展和维护</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度</li>
</ul>
</li>
</ul>
</li>
<li><p>能否解释下什么是动态代理？</p>
<ul>
<li>在程序运行时，运用反射机制动态创建而成，无需手动编写代码</li>
</ul>
</li>
<li>Spring AOP是用什么代理？<ul>
<li>Spring AOP 就是基于动态代理的<ul>
<li>如果要代理的对象，<strong>实现了某个接口</strong>，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象；</li>
<li>而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="后端面试/image-25.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="4、JDBC和Mybaits"><a href="#4、JDBC和Mybaits" class="headerlink" title="4、JDBC和Mybaits"></a>4、JDBC和Mybaits</h2><p><strong>简介：讲解JDBC和Mybatis基础面试题</strong></p>
<ul>
<li><p>考点：JDBC和Mybatis基础面试题考查</p>
</li>
<li><p>说下JDBC连接数据库的开发步骤</p>
<ol>
<li>加载数据库驱动 DriverManager</li>
<li>获取数据连接对象 Connection</li>
<li>获取语句对象<ul>
<li>语句对象分为Statement和PreparedStatement两种执行语句<ul>
<li>PreparedStatement在执行之前会进行预编译</li>
<li>效率高于Statement，且能够有效防止SQL注入</li>
<li>PreparedStatement支持?占位符，而不是直接拼接，提高可读性</li>
</ul>
</li>
</ul>
</li>
<li>处理结果集 ResultSet</li>
<li>关闭资源（需要注意关闭顺序及处理异常rs.close()、st.close()、conn.close()）</li>
</ol>
</li>
<li><p>能否简单说下Mybatis的四大核心对象及流程?</p>
<ol>
<li><p>SqlSession对象，该对象中包含了执行SQL语句的所有方法。类似于JDBC里面的Connection</p>
</li>
<li><p>Executor接口，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。类似于JDBC里面的Statement/PrepareStatement</p>
</li>
<li><p>MappedStatement对象，该对象是对映射SQL的封装，用于存储要映射的SQL语句的id、参数等信息</p>
</li>
<li><p>ResultHandler对象，用于对返回的结果进行处理，最终得到自己想要的数据格式或类型。可以自定义返回类型</p>
</li>
</ol>
</li>
</ul>
<p><img src="后端面试/image-26.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="5、Mybatis3-X-防止SQL注入"><a href="#5、Mybatis3-X-防止SQL注入" class="headerlink" title="5、Mybatis3.X 防止SQL注入"></a>5、Mybatis3.X 防止SQL注入</h2><p><strong>简介：mybatis3.x 防止sql注入知识点</strong></p>
<ul>
<li>考点：Mybatis防注入知识点考查</li>
<li>${}和#{ }的区别是什么?<ul>
<li>${}是字符串替换；#{ }是预编译处理；</li>
<li>在处理#{}时，会将SQL中的#{}替换为 ? 号，调用PreparedStatement的 set 方法来赋值；</li>
<li>在处理${}时，直接把${}替换成变量的值；</li>
<li>使用#{}可以有效防止SQL注入，提高系统安全性；</li>
</ul>
</li>
</ul>
<h2 id="6、Mybatis的多级缓存"><a href="#6、Mybatis的多级缓存" class="headerlink" title="6、Mybatis的多级缓存"></a>6、Mybatis的多级缓存</h2><p><strong>简介：讲解Mybatis多级缓存面试题</strong></p>
<ul>
<li>考点：Mybatis多级缓存知识点</li>
<li>有没用过Mybatis一级缓存，能否介绍下？<ul>
<li>简介：一级缓存的作用域是SqlSession，同一个SqlSession中执行相同的SQL查询（相同的SQL和参数），第一次回去查询数据库并写入缓存，第二次直接去缓存中获取</li>
<li>基于PerpetualCache 的 HashMap本地缓存，默认开启一级缓存</li>
<li><strong>失效策略</strong>：当执行SQL时两次查询的中间发生了增删改的操作，即insert、update、delete等操作，commit后会清空该SqlSession缓存；比如SqlSession关闭、清空等</li>
</ul>
</li>
<li>有没用过Mybatis二级缓存，能否介绍下？<ul>
<li>简介：当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个<strong>共同的 cache</strong>，也就是二级缓存被多个 SqlSession 共享，是一个<strong>全局的变量</strong>。当开启缓存后，数据的查询执行的流程就是 <strong>二级缓存 -&gt; 一级缓存 -&gt; 数据库</strong></li>
<li>基于PerpetualCache 的 HashMap本地缓存，可自定义存储源，如 Ehcache/Redis等；默认不开启二级缓存</li>
<li><strong>操作流程</strong>：<ul>
<li>第一次调用某个namespace下的SQL去查询信息，查询到的信息会存放该mapper对应的二级缓存区域。</li>
<li>第二次调用同个namespace下的mapper映射文件中，相同的sql去查询信息，会去对应的二级缓存内取结果</li>
</ul>
</li>
<li><strong>失效策略</strong>：执行同个namespace下的mapepr映射文件中的增删改sql，并执行了commit操作,会清空该二级缓存</li>
<li><strong>注意</strong>：实现二级缓存的时候，MyBatis建议返回的POJO是可序列化的， 也就是建议实现Serializable接口</li>
<li><strong>缓存淘汰策略</strong>：会使用默认的 LRU 算法来收回（最近最少使用的）</li>
</ul>
</li>
</ul>
<p><img src="后端面试/image-27.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="7、Mybatis3-X-懒加载"><a href="#7、Mybatis3-X-懒加载" class="headerlink" title="7、Mybatis3.X 懒加载"></a>7、Mybatis3.X 懒加载</h2><p><strong>简介：mybatis3.x懒加载面试题</strong></p>
<ul>
<li><p>考点：Mybatis懒加载知识点</p>
</li>
<li><p>什么是Mybatis3.X的懒加载？</p>
<ul>
<li>按需加载，先查单表，有需要再从关联表查询，能提高数据库性能（并不是所有场景都能够提高）</li>
<li>在mybatis中，resultMap可以实现高级映射(使用association一对一、collection一对多映射)，association、collection具备延迟加载功能。</li>
</ul>
</li>
</ul>
<h1 id="十四、Redis"><a href="#十四、Redis" class="headerlink" title="十四、Redis"></a>十四、Redis</h1><h2 id="1、Redis的基础数据类型"><a href="#1、Redis的基础数据类型" class="headerlink" title="1、Redis的基础数据类型"></a>1、Redis的基础数据类型</h2><p><strong>简介：分布式缓存Redis核心基础</strong></p>
<ul>
<li>考点：Redis基础知识点考查</li>
<li>你们业务用了redis，为啥不用其他缓存，比如memcached呢？<ul>
<li>Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为 丰富的数据类</li>
<li>Redis 的速度比 Memcached 快很</li>
<li>Redis 可以持久化其数据</li>
</ul>
</li>
<li>你用过Redis哪些数据结构？ 说下这些结构的使用场景有哪些？<ul>
<li>String<ul>
<li>简单的kv存储；验证码、分布式锁、热点商品卡片</li>
</ul>
</li>
<li>hash<ul>
<li>存储对象，一个key有多个值；购物车、商品详情</li>
</ul>
</li>
<li>list<ul>
<li>列表型数据、消息队列等；最新评论列表、非实时排行榜</li>
</ul>
</li>
<li>set<ul>
<li>无序集合、去重，交集、并集等；查看共同好友，在社交关系方面、数据排重等可以使用</li>
</ul>
</li>
<li>sroted set<ul>
<li>有序集合，去重；实时排行榜</li>
</ul>
</li>
</ul>
</li>
<li>redis是单线程，为什么这么快？<ul>
<li>基于内存，绝大部分请求是纯粹的内存操作</li>
<li>避免了不必要的CPU上下文切换和其他竞争条件，比如锁操作等</li>
<li>底层是使用多路I/O复用模型，非阻塞IO</li>
<li>redis 利用队列技术将并发访问变为串行访问，消除了传统数据库 串行控制的开销</li>
<li>redis6支持多线程，但只是用来处理网络数据的读写和协议解析上，<strong>底层数据操作还是单线程</strong></li>
</ul>
</li>
</ul>
<h2 id="2、Redis的持久化机制"><a href="#2、Redis的持久化机制" class="headerlink" title="2、Redis的持久化机制"></a>2、Redis的持久化机制</h2><p><strong>简介：Redis的持久化机制</strong></p>
<ul>
<li><p>考点：Redis的持久化机制考查</p>
</li>
<li><p>Redis 的持久化机制是什么？各自的优缺点？</p>
<ul>
<li><strong>RDB持久化</strong>：是指用数据集快照的方式半持久化存储，记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复<ul>
<li><strong>优点</strong>： <ul>
<li>只有一个文件 dump.rdb，方便持久化。</li>
<li>容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以 是 IO 最大化。使 用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
</li>
<li><strong>缺点</strong>： 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li>
</ul>
</li>
<li><strong>AOF持久化</strong>：指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储，保存为 aof 文件<ul>
<li><strong>优点</strong>：<ul>
<li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次</li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis- check-aof 工具解决数据一致性问题</li>
<li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>AOF 文件比 RDB 文件大，且恢复速慢</li>
<li>数据集大的时候，比 rdb 启动效率低。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3、Redis的内存淘汰策略"><a href="#3、Redis的内存淘汰策略" class="headerlink" title="3、Redis的内存淘汰策略"></a>3、Redis的内存淘汰策略</h2><p><strong>简介：缓存的淘汰策略</strong></p>
<ul>
<li>考点：是否有看过缓存设计的知识点</li>
<li>能分别说下FIFO、LRU、LFU这些策略不？<ul>
<li>先进先出First In，First Out<ul>
<li>新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动，淘汰FIFO队列头部的数据</li>
</ul>
</li>
<li>最近最少使用算法 Least recently used<ul>
<li>根据数据的历史访问记录来进行数据淘汰，从设置了过期时间的键中选择空转时间最长的键值对清除掉</li>
<li>新数据插入到链表头部，每当缓存数据被访问，则将数据移到链表头部，当链表满的时候，将链表尾部的数据丢弃</li>
</ul>
</li>
<li>最近使用频率最低算法 Least Frequently Used<ul>
<li>根据数据的历史访问频率来淘汰数据，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉</li>
<li>把数据加入到链表中，按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4、缓存穿透、击穿、雪崩"><a href="#4、缓存穿透、击穿、雪崩" class="headerlink" title="4、缓存穿透、击穿、雪崩"></a>4、缓存穿透、击穿、雪崩</h2><p><strong>简介：缓存穿透、击穿和雪崩你是否可以区分</strong></p>
<ul>
<li><p>考点：缓存穿透-击穿-雪崩知识点</p>
</li>
<li><p>能否说下缓存穿透、击穿、雪崩，及其预防方案？</p>
<ul>
<li><p><strong>缓存穿透</strong></p>
<ul>
<li><p>问题描述：</p>
<p>大量并发查询不存在的 KEY ，在缓存和数据库中都不存在，同时给缓存和数据库带来压力。<code>如：用一个不存在的用户id获取用户信息，这也是黑客利用不存在的key频繁攻击应用的一种方式</code></p>
</li>
<li><p>解决方案：</p>
<ul>
<li>接口层增加校验，对数据的合理性进行校验。<code>如：用户鉴权校验，id 做基础校验，id&lt;=0直接拦截</code></li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，设置一个短的过期时间，防止同个key被一直攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li>
</ul>
</li>
<li><p>SpringCache解决：</p>
<p> 空结果也缓存，防止缓存穿透</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># 指定缓存类型</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-comment"># 是否缓存空结果，防止缓存穿透，默认为true</span><br>      <span class="hljs-attr">cache-null-values:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>缓存击穿</strong></p>
<ul>
<li><p>问题描述：</p>
<p> 缓存中没有但数据库中有的数据（一般是缓存时间到期），当这个热点key在过期的一瞬间，正好有大量的并发请求访问这个key，这些请求都会击穿到数据库，造成瞬时数据库请求量大、压力增大</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>设置热点数据不过期</li>
<li>采用定时任务定时更新缓存</li>
<li>设置互斥锁</li>
</ul>
</li>
<li><p>SpringCache解决：</p>
<p> 缓存的同步 sync，sync 可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存中</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Cacheable</span>(<span class="hljs-keyword">sync</span>=<span class="hljs-keyword">true</span>)<br>Copy<br></code></pre></td></tr></table></figure>
<p>@Cacheable注解中的sync属性，当设置它为true时，只有一个线程的请求会去到数据库，其他线程都会等待直到缓存可用。这个设置可以减少对数据库的瞬间并发访问</p>
</li>
</ul>
</li>
<li><p><strong>缓存雪崩</strong></p>
<ul>
<li><p>问题描述：</p>
<p> 大量的key设置了相同的过期时间，导致缓存在同一时刻大面积的失效，造成大量的请求无法获取缓存，从而将流量压力传导到数据库上，引起雪崩</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>在原有失效时间基础上增加一个随机值，防止同一时间大量数据过期现象发生</li>
<li>使用的热数据尽量分散在不同的机器上</li>
<li>设置热点数据永远不过期，定时任务定时更新</li>
</ul>
</li>
<li><p>SpringCache解决：</p>
<ul>
<li>CacheManager配置多个不同过期时间维度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>后端面试</div>
      <div>http://yoursite.com/2022/07/01/后端面试/</div>
    </div>
    <div class="license-meta">
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/23/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="JVM内存区域">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM内存区域</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/" title="消息队列RabbitMQ的集群模式">
                        <span class="hidden-mobile">消息队列RabbitMQ的集群模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
